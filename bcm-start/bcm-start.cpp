// bcm-start.cpp : Defines the entry points for the console application
//
#define ___MPI_INIT___ 
#define ___nIGROUPS_NGROUPS___
#ifdef  ___MPI_INIT___
#include "mpi.h"
#include "ExchangeMPI.h"
#include "gsmatrix.h"
#endif
#include "nurbs.h"
#include "shapes.h"
#include "cdraft.h"
#define n_MUNI_APPROXIMATION
#define n_INP_CONVERTOR
//----------------------------------------------------------------------------------------
void Inp_nodes_add	(char * ch_NODES, CGrid * nd, int   ID_node_set, int ID_element_set);
void Inp_elements_add(char * ch_NODES, CGrid * nd, int * ID_elements, int ID_element_set);
//----------------------------------------------------------------------------------------
#define n_UWay_CONVERTOR
//----------------------------------------------------------------------------------------
void Convert3D_gmt(char * ch_NODES, CGrid * nd, int ID_part);
void Convert3D_prb(char * ch_NODES, CGrid * nd, int ID_part);
//----------------------------------------------------------------------------------------
#define n_GRAD_MEDIA_DEMO
#define n_ERROR_FUNCTION_REALIZATION
#define n_McDonald_FUNCTION_REALIZATION
#define POTENTIAL_LAME3D_REDECOMPOSITION
#define n_C3D_CONVERTOR
#define n_IGES_CONVERTOR
//----------------------------------------------------------------------------------------
extern void Read_C3D_Header(unsigned short *num_markers, unsigned short *num_channels, unsigned short *first_field, unsigned short *last_field,
							float *scale_factor,	unsigned short *start_record_num, unsigned short *frames_per_field, float *video_rate,	FILE *infile);
extern void Read_C3D_Parameters(unsigned char	**mlabels, unsigned char **alabels,	float *gscale,	float *ascale,	int *zero_off,	FILE *infile);
extern void Read_C3D_Channel(unsigned short channel_num, unsigned short num_markers,	unsigned short num_analog_channels,	unsigned short first_field,
								unsigned short last_field, unsigned short start_byte, unsigned short analog_frames_per_field, short *val, FILE *infile);
extern void Read_C3D_Marker(unsigned short marker_num,	unsigned short num_markers, unsigned short num_analog_channels, unsigned short first_field, unsigned short last_field,
							unsigned short	start_byte,	unsigned short analog_frames_per_field, short **val, unsigned char *res, FILE	*infile);
extern void Read_C3D_Data_int(unsigned short num_markers, unsigned short num_analog_channels, unsigned short first_field, unsigned short last_field, unsigned short start_byte, unsigned short analog_frames_per_field,
								short **x, short **y, short **z, char **residual, char **num_cam, short **analog, FILE *infile);
extern void Read_C3D_Data_float(unsigned short num_markers, unsigned short num_analog_channels, unsigned short first_field, unsigned short last_field, unsigned short start_byte, unsigned short analog_frames_per_field,
									float **x, float **y, float **z, char **residual, char **num_cam, short **analog, FILE *infile);
//----------------------------------------------------------------------------------------
#define n_TEST_CCELLS
#define n_TEST_SHAPES
#define n_TEST_DRAFT_ALL
#define n_TEST_DRAFT_VISCO
#define n_TEST_DRAFT_HYDRO
#define n_TEST_DRAFT_VIBRO
#define n_HEAT2D_ANALYT_HOMOGENIZATION
#define n_HEAT3D_ANALYT_HOMOGENIZATION
#define n_LAME3D_ANALYT_HOMOGENIZATION
#define n_HYDRO3D_ANALYT_HOMOGENIZATION
#define n_TEST_DRAFT_HEAT2D_INTERMEDIATE_PHASE
#define n_TEST_DRAFT_LAME2D_INTERMEDIATE_PHASE
#define n_TEST_DRAFT_LAME3D_INTERMEDIATE_PHASE
#define n_TEST_DRAFT_HYDRO3D_INTERMEDIATE_PHASE
#define n_TEST_DRAFT_HEAT2D_FROM_FEMAP
#define n_TEST_DRAFT_HEAT3D_FROM_FEMAP
#define n_TEST_DRAFT_LAME2D_FROM_FEMAP
#define n_TEST_DRAFT_LAME3D_FROM_FEMAP
#define n_TEST_DRAFT_COHES2D_FROM_FEMAP
//----------------------------------------------------------------------------------------
double CIdent(char * name_ini, double R, double A, double * energy, double l1, double l2, double G1, double G2, double nju1, double nju2, 
										 double Ad = 0, double Bd = 0, int N0 = 5, int id_layer = NULL_STATE, int id_direct = NULL_STATE, int id_visual = NULL_STATE);
double CIdent_sphere3D(double * energy, double rad, double fV, double l1, double l2, 
							  double G1, double G2, double nju1, double nju2, int N0 = 3, int id_visual = 0);
//----------------------------------------------------------------------------------------
#define n_TEST_DRAFT_COHES2D_CONSTRUCTION_FROM_FEMAP
#define n_TEST_DRAFT_GRADIENT2D_FROM_FEMAP
#define n_TEST_DRAFT_HEAT3D_SPHEROID
#define n_TEST_DRAFT_LAME3D_SPHEROID
#define n_DIFFUSION2D_HOMOGENIZATION
#define n_HEAT2D_RANDOM_STRUCTURE
#define n_HEAT3D_RANDOM_STRUCTURE
#define n_LAME3D_RANDOM_STRUCTURE
#define n_HEAT3D_RANDOM_HOMOGENIZATION
#define n_LAME3D_RANDOM_HOMOGENIZATION
#define n_TEST_HEAT3D_RANDOM_HOMOGENIZATION
#define n_TEST_LAME3D_RANDOM_HOMOGENIZATION
//----------------------------------------------------------------------------------------
int	 strata_approx	 (int N, double * data, double * coef);
double strata_approx	 (int N, double * data, double ll0);
double TakeLayer_EH   (int N, double * ff, double * kk, double * ll);
double TakeCylinder_EH(int N, double * ff, double * kk);
double TakeCylinder_KH(int N, double * ff, double * kp, double * mu);
double TakeCylinder_GH(int N, double * ff, double * kp, double * mu, double * nj);
double TakeCylinder_SH(int N, double * ff, double * kp, double * mu, double * nj);
double TakeCylinder_LH(int N, double * ff, double * lm, double * mu, double * nj);
double TakeCylinder_GH(int N, double * ff, double * mu, double * nj);
double TakeSphere_KH	 (int N, double * ff, double * kv, double * mu);
double TakeSphere_GH	 (int N, double * ff, double * kv, double * mu, double * nj);
double TakeSphere_GH_det	(double c0, double nju1, double nju2, double E1, double E2, double alpha = -1);
double TakeSphere_volm_two (double c0, double nju1, double nju2, double E1, double E2, double l1, double l2, double AA = 0.);
double TakeSphere_volm_sym (double c0, double nju1, double nju2, double E1, double E2, double l1, double l2);
double TakeSphere_shear_two(double c0, double nju1, double nju2, double E1, double E2, double l1, double l2, double AA = 0., double BB = 0.);
double TakeSphere_shear		(double c0, double nju1, double nju2, double E1, double E2, double l1, double l2);
double TakeSphere_shear_sym(double c0, double nju1, double nju2, double E1, double E2, double l1, double l2);
double strata_aglom(double t, int N, double * coef);
double strata_aglom(double t, double t0, double B, double ll0);
double aglom_approx(double t, double alpha, double r_max, double r_min, double t_min);
double rigid_approx(double t, double E1_max, double E2_max, double E_min, double alpha, double beta, double t_min);
double rigid_approx(double t, double E1_max, double E2_max, double E_min, double t_min, double E1, double E2, double E3, double t1, double t2, double t3);
double rigid_approx(double t, double E1_max, double E2_max, double E_min, double t_min, double E1, double E2, double E3, double E4, double t1, double t2, double t3, double t4);
//----------------------------------------------------------------------------------------
#define n_DRAFT_LAME_ESHELBY_NONLINEAR_DIAGRAM
#define n_DRAFT_LAME_ESHELBY_COMPARISON_DIAGRAM
#define n_TEST_DRAFT_LAME_ESHELBY_INTERMEDIATE_PHASE
#define n_TEST_DRAFT_LAME_ESHELBY_INTERMEDIATE_PHASE_sph
#define n_TEST_DRAFT_LAME_ESHELBY_INTERMEDIATE_PHASE_cyl
#define n_TEST_DRAFT_LAME_ESHELBY_INTERMEDIATE_PHASE_layer
#define n_TEST_DRAFT_LAME_ESHELBY
#define n_LAME3D_LAYERED_ESHELBY_HOMOGENIZATION
#define n_ESHELBY_CALCULATIONS
#define n_ALUMO_COMPOSITES_CALCULATIONS
#define n_ALUMO_COMPOSITES_EXAMPLES
#define n_WSMP_COMPOSITE_CALCULATION
#define n_MINDL2D_CALCULATIONS
#define n_TEST_DRAFT_HEAT_ESHELBY
#define n_TEST_DRAFT_HEAT_NONLINEAR_LAYER
#define n_TEST_DRAFT_HEAT_FIRST_MEMBER
#define n_TEST_DRAFT_HEAT_FIRST_MEMBER_NONLINEAR_LAYER
//----------------------------------------------------------------------------------------
#ifdef ___MPI_INIT___
CMPIComm comm_mpi;
#endif
#define Message(Msg)   { printf("%s", Msg);  printf("\n");}

int main(int argc, char* argv[])
{
  try {
#ifdef ___IGROUPS_NGROUPS___
	int igroup = 1, ngroups = 1;
#endif
#ifdef ___MPI_INIT___
	int myidgl, numprocsgl;
	int namelen;
	char processor_name[MPI_MAX_PROCESSOR_NAME];

	MPI_Init (&argc,&argv);

	MPI_Comm_size (MPI_COMM_WORLD,&numprocsgl);
	MPI_Comm_rank (MPI_COMM_WORLD,&myidgl);
	MPI_Get_processor_name (processor_name,&namelen);

	std::cout << " Myid = " << myidgl << " Processor name = " << processor_name << std::endl;

	MPI_Comm commloc = MPI_COMM_WORLD;
#ifdef ___IGROUPS_NGROUPS___
	comm_mpi = CMPIExchange::GetCommMPI(ngroups,igroup);
#else
	comm_mpi.SetCommMPI (&commloc);
#endif
#endif
#ifdef ___IGROUPS_NGROUPS___
	if (igroup == 0) {
#endif
	time_t start = time(NULL), sec;
	char buf[2000]; int res, yes = 1;

#ifdef MUNI_APPROXIMATION
{
/////////////////////
//...исходные данные;
	//int  N_muni = 269;
	//double muni[][2] = {//...ненаполненная матрица;
	//{1.,0.00173},		{1.00072,0.00496},{1.01092,0.03958},{1.02204,0.05216},{1.03496,0.04343},{1.04408,0.07734},{1.05296,0.11117},{1.06612,0.12612},{1.07748,0.08906},{1.08696,0.12368},
	//{1.09688,0.15602},{1.10596,0.18592},{1.11556,0.16381},{1.1266, 0.17325},{1.13592,0.19371},{1.14536,0.20315},{1.15568,0.21574},{1.16528,0.22203},{1.1766, 0.22998},{1.18588,0.22596},
	//{1.19436,0.25830},{1.20468,0.28104},{1.21412,0.26932},{1.22296,0.28655},{1.23188,0.29528},{1.241,  0.28733},{1.2502, 0.31731},{1.2606, 0.33462},{1.26884,0.31408},{1.279,  0.33304},
	//{1.28852,0.34083},{1.29784,0.34799},{1.3102, 0.35500},{1.3218, 0.36688},{1.33228,0.37545},{1.34224,0.38332},{1.35488,0.38961},{1.366,  0.40535},{1.37648,0.39363},{1.385,  0.39599},
	//{1.39616,0.41951},{1.40452,0.42895},{1.41424,0.41873},{1.4244, 0.44469},{1.43356,0.42974},{1.44388,0.44312},{1.45696,0.44862},{1.4692, 0.47301},{1.47788,0.46050},{1.4894, 0.50134},
	//{1.50288,0.48489},{1.51124,0.50063},{1.5256, 0.48096},{1.53364,0.49898},{1.54292,0.51786},{1.555,	0.52809},{1.5742,	0.53367},{1.585,	0.52258},{1.59592,0.52337},{1.60504,0.54540},
	//{1.61376,0.53517},{1.62232,0.55885},{1.63116,0.55334},{1.64044,0.55484},{1.6498,	0.56743},{1.65972,0.56908},{1.67044,0.58159},{1.68124,0.57852},{1.6942,	0.57766},{1.70532,0.56908},
	//{1.71552,0.59575},{1.72372,0.60126},{1.7364,	0.60842},{1.75056,0.59182},{1.7604,	0.61070},{1.77024,0.61935},{1.78152,0.63438},{1.79052,0.62258},{1.8016,	0.63438},{1.81344,0.62644},
	//{1.82436,0.63281},{1.83304,0.63981},{1.84356,0.64847},{1.85452,0.64532},{1.86764,0.65799},{1.88208,0.63666},{1.8912,	0.65948},{1.90088,0.67215},{1.9112,	0.68159},{1.92544,0.68308},
	//{1.94012,0.66900},{1.95044,0.68238},{1.95928,0.69567},{1.96812,0.69803},{1.98148,0.68072},{1.99592,0.69339},{2.008,	0.68238},{2.01888,0.69410},{2.02984,0.70205},{2.03876,0.72400},
	//{2.04868,0.71070},{2.059,	0.72172},{2.06964,0.72242},{2.08008,0.72006},{2.08988,0.72950},{2.10092,0.72950},{2.11156,0.73588},{2.12252,0.72478},{2.13588,0.74209},{2.14728,0.73186},
	//{2.15796,0.73816},{2.16964,0.74532},{2.17996,0.76334},{2.1918,	0.74839},{2.20336,0.75862},{2.21376,0.75311},{2.22216,0.76176},{2.23192,0.76971},{2.2444,	0.78615},{2.25536,0.77600},
	//{2.26776,0.77671},{2.2802,	0.77356},{2.3014,	0.77907},{2.31188,0.79174},{2.32076,0.80346},{2.33152,0.78938},{2.3424,	0.80983},{2.35332,0.79717},{2.36348,0.79874},{2.3738,	0.80740},
	//{2.38348,0.81928},{2.39368,0.80983},{2.40464,0.81605},{2.41584,0.81605},{2.42644,0.80983},{2.43744,0.82636},{2.44832,0.81456},{2.45948,0.81928},{2.47012,0.83336},{2.47856,0.85224},
	//{2.48952,0.83572},{2.50296,0.84752},{2.51668,0.83895},{2.52692,0.83423},{2.53612,0.84917},{2.54476,0.86168},{2.55408,0.85862},{2.56592,0.84839},{2.57652,0.86955},{2.58636,0.84988},
	//{2.59692,0.86806},{2.60684,0.86483},{2.6152,	0.86483},{2.62364,0.88450},{2.63352,0.86483},{2.64472,0.88135},{2.65448,0.87907},{2.66376,0.87907},{2.67252,0.89079},{2.68432,0.89237},
	//{2.69284,0.88607},{2.70192,0.90504},{2.71284,0.89237},{2.72688,0.89945},{2.74112,0.89552},{2.74956,0.89158},{2.76076,0.91841},{2.76948,0.91125},{2.78148,0.92856},{2.79496,0.90976},
	//{2.8064,	0.91762},{2.81496,0.92313},{2.82704,0.91841},{2.83856,0.91676},{2.84712,0.92620},{2.8578,	0.92856},{2.8702,	0.91762},{2.88156,0.93879},{2.892,	0.94280},{2.90052,0.95374},
	//{2.91128,0.94280},{2.92648,0.93485},{2.94092,0.94437},{2.95144,0.93485},{2.96164,0.94752},{2.97316,0.95696},{2.98292,0.96790},{2.99676,0.96404},{3.02176,0.97577},{3.02988,0.96082},
	//{3.03864,0.96475},{3.0476,	0.98521},{3.05824,0.96947},{3.06856,0.97341},{3.08044,0.99072},{3.0924,	0.98285},{3.10548,0.99237},{3.11648,0.98049},{3.12512,0.99709},{3.13428,1.01039},
	//{3.145,	1.00724},{3.15736,1.01432},{3.16832,1.00338},{3.1818,	1.00574},{3.19508,1.01747},{3.20612,1.00181},{3.21448,1.02069},{3.22512,1.03006},{3.2334,	1.01511},{3.24384,1.02376},
	//{3.25472,1.02777},{3.26508,1.01983},{3.27536,1.03643},{3.28472,1.02219},{3.29556,1.02691},{3.30772,1.03242},{3.31808,1.04815},{3.32944,1.03006},{3.34052,1.04587},{3.35004,1.03564},
	//{3.36056,1.04658},{3.36876,1.04587},{3.37784,1.04972},{3.39036,1.06153},{3.40096,1.07498},{3.4142,	1.05917},{3.42724,1.07105},{3.43768,1.06389},{3.44852,1.06389},{3.45916,1.06782},
	//{3.46836,1.08993},{3.47912,1.07498},{3.49012,1.07805},{3.49884,1.08749},{3.51076,1.08749},{3.51992,1.08277},{3.52848,1.09693},{3.53684,1.08993},{3.54812,1.09378},{3.55712,1.09614},
	//{3.56976,1.10488},{3.57936,1.10873},{3.58748,1.10016},{3.5988,	1.11432},{3.6108,	1.12211},{3.62092,1.11904},{3.63268,1.11511},{3.6448,	1.13234},{3.65604,1.11817},{3.66632,1.12927},
	//{3.67744,1.13627},{3.68632,1.14729},{3.6954,	1.14972},{3.7046,	1.13478},{3.7298,	1.13706},{3.73968,1.14178},{3.75032,1.14972},{3.76116,1.15594},{3.77296,1.16223},{3.78336,1.16696},
	//{3.7948,	1.15122},{3.8068,	1.17168},{3.81916,1.15122},{3.82724,1.16617},{3.83652,1.16861},{3.84952,1.17246},{3.86108,1.18356},{3.87304,1.16774},{3.88356,1.19300}};

	//int  N_muni = 610;
	//double muni[][2] = {//...микрошунгит;
	//{0.088,  0.068044355},{0.976,  0.127688172},{1.628,  0.128528226},{2.264,  0.127688172},{2.704,  0.145329301},{3.176,  0.20749328 },{3.836,  0.229334677},{4.264,  0.260416667},{4.712,  0.268817204},{5.128,  0.267137097},
	//{5.8,    0.320900538},{6.328,  0.326780914},{6.82,   0.366263441},{7.612,  0.400705645},{8.044,  0.404905914},{8.764,  0.430107527},{9.18,   0.439348118},{9.736,  0.499831989},{10.468, 0.491431452},{11.264, 0.523353495},
	//{12.016, 0.558635753},{12.684, 0.551075269},{13.34,  0.59811828 },{14.1,   0.596438172},{14.868, 0.619119624},{15.488, 0.656081989},{16.112, 0.661122312},{16.876, 0.687163978},{17.3,   0.694724462},{17.704, 0.700604839},
	//{18.44,  0.72328629 },{19.104, 0.75436828 },{19.736, 0.763608871},{20.42,  0.792170699},{21.184, 0.798891129},{21.852, 0.819892473},{22.468, 0.836693548},{23.216, 0.840053763},{23.624, 0.85265457 },{24.356, 0.880376344},
	//{24.932, 0.902217742},{25.688, 0.898857527},{26.116, 0.908098118},{26.524, 0.934139785},{27.204, 0.933299731},{27.896, 0.953461022},{28.524, 0.979502688},{29.2,   0.977822581},{29.96,  1.00890457 },{30.624, 1.003864247},
	//{31.352, 1.026545699},{32.044, 1.045866935},{32.692, 1.054267473},{34.176, 1.076948925},{34.856, 1.101310484},{35.352, 1.118951613},{36.08,  1.122311828},{36.856, 1.15843414 },{37.624, 1.149193548},{38.156, 1.165994624},
	//{38.868, 1.176915323},{39.308, 1.19203629 },{39.748, 1.177755376},{40.156, 1.18531586 },{40.844, 1.205477151},{41.444, 1.233198925},{42.02,  1.228998656},{42.736, 1.255880376},{43.14,  1.240759409},{43.896, 1.267641129},
	//{44.564, 1.261760753},{45.152, 1.292002688},{45.796, 1.306283602},{46.412, 1.304603495},{47.084, 1.333165323},{47.496, 1.323924731},{47.904, 1.312163978},{48.632, 1.344086022},{49.276, 1.354166667},{50.088, 1.350806452},
	//{50.848, 1.375168011},{51.56,  1.358366935},{52.228, 1.386928763},{52.804, 1.397849462},{53.46,  1.41297043 },{53.864, 1.409610215},{54.276, 1.439012097},{55.024, 1.417170699},{55.664, 1.444052419},{56.356, 1.448252688},
	//{57.084, 1.460013441},{57.744, 1.478494624},{58.436, 1.472614247},{59.14,  1.499495968},{59.764, 1.501176075},{60.488, 1.509576613},{60.9,   1.507056452},{61.316, 1.517977151},{62.028, 1.516297043},{62.608, 1.548219086},
	//{63.308, 1.541498656},{64.076, 1.549899194},{64.748, 1.57594086 },{65.3,   1.575100806},{65.984, 1.598622312},{66.764, 1.586861559},{67.508, 1.607862903},{68.276, 1.622143817},{69.048, 1.612063172},{69.7,   1.643145161},
	//{70.28,  1.635584677},{71.048, 1.653225806},{71.464, 1.650705645},{72.124, 1.671706989},{72.692, 1.679267473},{73.452, 1.685147849},{74.18,  1.697748656},{74.788, 1.686827957},{75.46,  1.71875    },{76.82,  1.723790323},
	//{77.496, 1.74563172 },{78.252, 1.73891129 },{78.96,  1.760752688},{79.588, 1.762432796},{80.204, 1.771673387},{80.992, 1.790994624},{81.44,  1.792674731},{81.848, 1.784274194},{82.452, 1.806955645},{83.056, 1.813676075},
	//{83.82,  1.827116935},{84.504, 1.838877688},{85.18,  1.827956989},{85.588, 1.843077957},{86.24,  1.853998656},{86.792, 1.875      },{87.544, 1.858198925},{88.324, 1.887600806},{88.968, 1.886760753},{89.576, 1.896841398},
	//{90.208, 1.917002688},{90.956, 1.908602151},{91.72,  1.92624328 },{92.356, 1.927923387},{92.996, 1.933803763},{93.784, 1.950604839},{94.512, 1.94640457 },{95.2,   1.975806452},{95.872, 1.971606183},{96.44,  1.985047043},
	//{97.08,  2.01108871 },{97.896, 1.997647849},{98.588, 2.02452957 },{99.168, 2.022849462},{99.884, 2.036290323},{100.596,2.050571237},{101.32, 2.034610215},{101.972,2.064012097},{102.692,2.055611559},{103.416,2.074932796},
	//{104.028,2.085013441},{104.732,2.085853495},{105.144,2.100134409},{105.916,2.098454301},{106.5,  2.124495968},{107.172,2.111895161},{107.592,2.137096774},{108,    2.139616935},{108.664,2.133736559},{109.192,2.143817204},
	//{109.888,2.169858871},{110.684,2.158938172},{111.428,2.1875     },{112.02, 2.184979839},{112.672,2.197580645},{113.416,2.217741935},{114.06, 2.200100806},{114.692,2.235383065},{115.332,2.232022849},{116.024,2.246303763},
	//{116.724,2.253024194},{117.324,2.243783602},{118.004,2.278225806},{118.724,2.270665323},{119.364,2.282426075},{120.696,2.293346774},{121.128,2.306787634},{121.776,2.308467742},{122.292,2.335349462},{123.048,2.326108871},
	//{123.456,2.346270161},{124.1,  2.342909946},{124.716,2.368111559},{125.46, 2.361391129},{126.124,2.379032258},{126.748,2.389952957},{127.452,2.373991935},{128.148,2.402553763},{128.8,  2.397513441},{129.464,2.41515457 },
	//{130.116,2.423555108},{130.764,2.423555108},{131.488,2.449596774},{132.056,2.444556452},{132.704,2.466397849},{133.112,2.457157258},{133.792,2.478158602},{134.312,2.474798387},{135.048,2.480678763},{135.808,2.495799731},
	//{136.408,2.500840054},{137.02, 2.526041667},{137.676,2.521841398},{138.352,2.535282258},{138.988,2.552083333},{139.588,2.545362903},{140.288,2.570564516},{140.996,2.561323925},{141.58, 2.580645161},{142.224,2.588205645},
	//{142.872,2.584005376},{143.524,2.605846774},{144.22, 2.599966398},{144.904,2.620127688},{145.696,2.625168011},{146.376,2.622647849},{146.944,2.652889785},{147.64, 2.650369624},{148.316,2.668010753},{148.876,2.679771505},
	//{149.496,2.683971774},{150.112,2.708333333},{150.768,2.698252688},{151.552,2.704973118},{152.18, 2.712533602},{152.668,2.719254032},{153.308,2.743615591},{154.1,  2.728494624},{154.676,2.751176075},{155.364,2.75453629 },
	//{155.784,2.772177419},{156.48, 2.765456989},{156.92, 2.789818548},{157.608,2.795698925},{158.012,2.802419355},{158.632,2.804099462},{159.168,2.807459677},{159.944,2.830141129},{160.684,2.814180108},{161.256,2.844422043},
	//{161.94, 2.841061828},{163.332,2.86374328 },{163.9,  2.858702957},{164.472,2.887264785},{165.176,2.878024194},{165.808,2.889784946},{166.364,2.915826613},{167.108,2.904905914},{167.788,2.926747312},{168.452,2.921706989},
	//{169.044,2.935987903},{169.652,2.957829301},{170.384,2.941028226},{171.032,2.96875    },{171.636,2.961189516},{172.376,2.977990591},{172.952,2.985551075},{173.604,2.983870968},{174.008,3.002352151},{174.696,3.004032258},
	//{175.264,3.027553763},{175.996,3.011592742},{176.688,3.035114247},{177.188,3.045194892},{177.772,3.041834677},{178.508,3.066196237},{179.212,3.052755376},{179.992,3.076276882},{180.644,3.072916667},{181.212,3.086357527},
	//{181.956,3.108198925},{182.572,3.096438172},{183.128,3.127520161},{183.828,3.117439516},{184.512,3.130880376},{185.144,3.146001344},{185.752,3.137600806},{186.408,3.161962366},{187.18, 3.154401882},{187.772,3.167002688},
	//{188.28, 3.188004032},{189.048,3.173723118},{189.624,3.203965054},{190.16, 3.193884409},{190.976,3.209005376},{191.652,3.228326613},{192.172,3.228326613},{192.968,3.245967742},{193.396,3.23000672 },{194.008,3.246807796},
	//{194.468,3.245127688},{195.244,3.264448925},{195.66, 3.257728495},{196.228,3.280409946},{196.78, 3.282090054},{197.584,3.290490591},{198.252,3.290490591},{198.868,3.292170699},{199.58, 3.320732527},{200.292,3.308971774},
	//{200.996,3.327452957},{201.684,3.340893817},{202.304,3.340893817},{202.928,3.369455645},{203.548,3.361055108},{203.956,3.36609543 },{204.38, 3.374495968},{205.448,3.38625672 },{206.244,3.396337366},{206.928,3.392137097},
	//{207.46, 3.414818548},{208.18, 3.411458333},{208.584,3.427419355},{209.256,3.420698925},{209.772,3.441700269},{210.488,3.453461022},{210.892,3.447580645},{211.508,3.447580645},{212.02, 3.463541667},{212.668,3.483702957},
	//{213.32, 3.472782258},{213.924,3.492943548},{214.636,3.492943548},{215.32, 3.501344086},{215.992,3.518145161},{216.62, 3.508064516},{217.292,3.533266129},{217.92, 3.532426075},{218.692,3.528225806},{219.368,3.550907258},
	//{219.976,3.548387097},{220.74, 3.571068548},{221.328,3.564348118},{221.96, 3.579469086},{222.368,3.57358871 },{223.004,3.590389785},{223.476,3.594590054},{224.212,3.598790323},{224.644,3.602150538},{225.32, 3.616431452},
	//{225.78, 3.638272849},{226.504,3.623991935},{227.156,3.648353495},{227.748,3.642473118},{228.512,3.65171371 },{229.08, 3.659274194},{229.672,3.662634409},{230.416,3.682795699},{231.032,3.675235215},{231.672,3.694556452},
	//{232.352,3.705477151},{232.928,3.710517473},{233.656,3.727318548},{234.368,3.712197581},{234.96, 3.735719086},{235.62, 3.739079301},{236.268,3.738239247},{236.82, 3.760920699},{237.576,3.748319892},{237.98, 3.77016129 },
	//{238.584,3.760080645},{239.108,3.797883065},{239.88, 3.786122312},{240.584,3.791162634},{241.16, 3.812163978},{241.848,3.796202957},{242.468,3.826444892},{243.08, 3.81468414 },{243.832,3.828125   },{244.504,3.832325269},
	//{245.116,3.836525538},{245.8,  3.860047043},{246.364,3.854166667},{247.692,3.87936828 },{248.348,3.882728495},{249.056,3.902049731},{249.724,3.891129032},{250.224,3.914650538},{250.98, 3.923051075},{251.664,3.909610215},
	//{252.22, 3.937331989},{252.928,3.925571237},{253.656,3.944052419},{254.18, 3.946572581},{254.856,3.945732527},{255.576,3.976814516},{256.092,3.966733871},{256.74, 3.986055108},{257.44, 3.99109543 },{258.036,3.991935484},
	//{258.72, 4.015456989},{259.356,4.002856183},{259.92, 4.023857527},{260.624,4.025537634},{261.264,4.025537634},{261.744,4.04905914 },{262.44, 4.039818548},{263.164,4.059979839},{263.832,4.04905914 },{264.372,4.065020161},
	//{265.08, 4.08938172 },{265.756,4.074260753},{266.352,4.096942204},{266.916,4.100302419},{267.464,4.115423387},{268.1,  4.125504032},{268.852,4.109543011},{269.368,4.140625   },{269.996,4.144825269},{270.424,4.148185484},
	//{271.044,4.135584677},{271.512,4.163306452},{272.268,4.16750672 },{272.92, 4.166666667},{273.56, 4.189348118},{274.104,4.177587366},{274.816,4.197748656},{275.252,4.180947581},{275.9,  4.207829301},{276.42, 4.204469086},
	//{277.116,4.221270161},{277.772,4.236391129},{278.512,4.219590054},{279.108,4.243111559},{279.764,4.241431452},{280.516,4.251512097},{281.12, 4.259912634},{281.768,4.252352151},{282.296,4.287634409},{282.892,4.275033602},
	//{283.524,4.296034946},{284.232,4.292674731},{284.876,4.296034946},{285.436,4.325436828},{286.1, 4.311995968 },{286.748,4.335517473},{287.328,4.335517473},{287.98, 4.334677419},{288.644,4.364079301},{289.86, 4.369119624},
	//{290.584,4.370799731},{291.244,4.365759409},{291.884,4.38844086 },{292.584,4.379200269},{293.204,4.401041667},{293.86, 4.40188172 },{294.468,4.407762097},{295.032,4.43296371 },{295.748,4.417842742},{296.376,4.442204301},
	//{296.884,4.454805108},{297.584,4.453965054},{298.248,4.471606183},{298.824,4.462365591},{299.476,4.482526882},{300.116,4.482526882},{300.716,4.480846774},{301.272,4.506048387},{302.032,4.490087366},{302.572,4.518649194},
	//{303.14, 4.518649194},{303.788,4.527049731},{304.488,4.543850806},{305.14, 4.534610215},{305.612,4.568212366},{306.28, 4.559811828},{306.932,4.570732527},{307.456,4.585013441},{308.148,4.570732527},{308.82, 4.595094086},
	//{309.324,4.59593414 },{309.96, 4.611055108},{310.66, 4.611895161},{311.292,4.606014785},{311.876,4.642137097},{312.476,4.62953629 },{313.156,4.640456989},{313.776,4.654737903},{314.368,4.654737903},{315.044,4.681619624},
	//{315.676,4.670698925},{316.228,4.689180108},{316.896,4.70094086 },{317.496,4.692540323},{318.108,4.712701613},{318.724,4.710181452},{319.32, 4.727822581},{320.028,4.724462366},{320.568,4.726982527},{321.176,4.762264785},
	//{321.852,4.742103495},{322.432,4.763104839},{322.964,4.77234543 },{323.664,4.769825269},{324.376,4.788306452},{324.796,4.783266129},{325.412,4.806787634},{326.104,4.808467742},{326.596,4.808467742},{327.272,4.832829301},
	//{327.972,4.815188172},{328.448,4.844590054},{329,    4.845430108},{329.688,4.846270161},{330.276,4.86391129 },{331.556,4.879872312},{332.052,4.882392473},{332.74, 4.889112903},{333.348,4.90843414 },{333.916,4.897513441},
	//{334.56, 4.925235215},{335.096,4.924395161},{335.724,4.925235215},{336.364,4.94203629 },{336.9,  4.936995968},{337.492,4.964717742},{338.108,4.961357527},{338.7,  4.961357527},{339.34, 4.97983871 },{339.952,4.972278226},
	//{340.552,5.000840054},{341.08, 4.999159946},{341.712,5.015120968},{342.24, 5.029401882},{342.88, 5.021001344},{343.512,5.042002688},{344.02, 5.037802419},{344.732,5.050403226},{345.42, 5.058803763},{345.996,5.053763441},
	//{346.536,5.082325269},{347.124,5.076444892},{347.808,5.085685484},{348.328,5.092405914},{348.924,5.09156586 },{349.568,5.121807796},{350.128,5.110047043},{350.74, 5.127688172},{351.48, 5.132728495},{351.912,5.144489247},
	//{352.624,5.164650538},{353.04, 5.141969086},{353.672,5.164650538},{354.28, 5.15625	  },{354.916,5.183971774},{355.464,5.182291667},{356.184,5.191532258},{356.764,5.209173387},{357.368,5.198252688},{358.008,5.230174731},
	//{358.588,5.216733871},{359.264,5.231854839},{359.84, 5.243615591},{360.468,5.235215054},{361.092,5.262936828},{361.652,5.255376344},{362.276,5.270497312},{362.92, 5.277217742},{363.464,5.279737903},{364.016,5.306619624},
	//{364.612,5.293178763},{365.044,5.320060484},{365.7,  5.33266129 },{366.344,5.324260753},{366.86, 5.350302419},{367.548,5.33938172 },{368.144,5.357862903},{368.644,5.367943548},{369.256,5.362063172},{369.84, 5.388104839},
	//{370.408,5.380544355},{371.5,  5.404905914},{372.136,5.403225806},{372.66, 5.435987903},{373.116,5.434307796},{373.696,5.452788978},{374.34, 5.454469086},{374.84, 5.456149194},{375.436,5.483030914},{376.08, 5.464549731},
	//{376.564,5.488071237},{377.132,5.496471774},{377.864,5.489751344},{378.368,5.516633065},{378.824,5.514112903},{379.508,5.531754032},{380.08, 5.523353495},{380.56, 5.535114247},{381.16, 5.56031586 },{381.824,5.543514785},
	//{382.364,5.571236559},{382.836,5.577116935},{383.476,5.583837366},{384.02, 5.608198925},{384.572,5.592237903},{385.216,5.619959677},{385.672,5.61827957 },{386.312,5.619119624},{386.832,5.637600806},{387.292,5.63844086 }};

//int  N_muni = 77;
//double muni[][2] = {//...микрошунгит, расчет;
//{2,   0.039709446},{4,  0.076892877},{6,  0.111837822},{8,  0.144793086},{10,	0.175975008},{12,	0.205572588},{14,	0.233751609},{16,	0.260658492},{18,	0.286422654},{20,	0.311159177},
//{22,	0.334970885},{24,	0.357949936},{26,	0.380179215},{28,	0.401733677},{30,	0.422681279},{32,	0.443083898},{34,	0.462998121},{36,	0.482475842},{38,	0.501564882},{40,	0.520309544},
//{42,	0.53875094 },{44,	0.556927441},{46,	0.574875016},{48,	0.592627557},{50,	0.610217125},{52,	0.62767417 },{54,	0.645027838},{56,	0.662306075},{58,	0.679535882},{60,	0.696743457},
//{62,	0.713954245},{64,	0.731193248},{66,	0.748484969},{68,	0.765853619},{70,	0.783323146},{72,	0.800917308},{74,	0.818659774},{76,	0.836573948},{78,	0.854682482},{80,	0.873003615},
//{82,	0.891528337},{84,	0.910168106},{86,	0.928887389},{88,	0.947860394},{90,	0.96717921 },{92,	0.986876879},{94,	1.006984246},{96,	1.027530171},{98,	1.048545033},{100,1.07006032 },
//{102, 1.092108549},{104,1.114723136},{106,1.13793853 },{108,1.161790082},{110,1.186314036},{112,1.211547428},{114,1.237528096},{116,1.264294645},{118,1.291886351},{120,1.320343117},
//{122, 1.349705361},{124,1.380013856},{126,1.411309614},{128,1.443633668},{130,1.477026687},{132,1.511528594},{134,1.547177886},{136,1.584013964},{138,1.622066911},{140,1.661369991},
//{142, 1.70195096 },{144,1.743825072},{146,1.786986625},{148,1.831467297},{150,1.877351024},{152,1.924737135},{154,1.973722178}};

//	int  N_muni = 1304;
//	double muni[][2] = {//...наношунгит;
//   {1.00096,0.06129 },{1.00412,0.091935},{1.00992,0.146774},{1.01704,0.158065},{ 1.024 ,0.157258},{1.02928,0.204032},{1.03224,0.237097},{1.03428,0.254032},{1.03692,0.28871 },{1.04092,0.341129},
//	{1.04612,0.328226},{1.05164,0.356452},{1.05656,0.405645},{1.06076,  0.4   },{ 1.064 ,0.419355},{ 1.067 ,0.480645},{1.07048,0.487903},{ 1.075 ,0.491129},{1.08028,0.535484},{1.08576,0.550806},
//	{1.09064,0.548387},{ 1.0944,0.579032},{1.09748,0.623387},{1.10076,0.617742},{1.10512,0.645161},{1.11092,0.678226},{1.11716,0.675806},{1.12284,0.678226},{1.12736,0.715323},{1.13104,0.729839},
//	{ 1.1346,0.732258},{1.13852,0.773387},{1.14276,0.794355},{ 1.1476,0.794355},{ 1.1522,0.81371 },{ 1.1564,0.841129},{1.16068,0.846774},{ 1.1648,0.862097},{1.16904,0.879032},{1.17368,0.904839},
//	{1.17828,0.903226},{1.18316,0.926613},{ 1.1882,0.942742},{1.19312,0.948387},{1.19788,0.959677},{1.20192,0.982258},{1.20552,1.002419},{1.20948,1.005645},{ 1.2142,1.023387},{ 1.2196,1.044355},
//	{1.22484,1.042742},{1.22936,1.045161},{1.23332,1.081452},{1.23696,1.089516},{ 1.241 ,1.097581},{1.24568,1.112903},{1.25108,1.137903},{1.25672,1.124194},{ 1.2618,1.141935},{1.26632,1.166935},
//	{ 1.2708,1.159677},{1.27504,1.176613},{1.27936,1.206452},{1.28384,1.210484},{1.28848,1.210484},{ 1.293 ,1.237903},{ 1.2972,1.254839},{ 1.3014,1.254032},{1.30612,1.259677},{1.31132,1.291935},
//	{ 1.3166,1.277419},{1.32156,1.293548},{ 1.3254,1.322581},{1.32904,1.326613},{1.33308,1.331452},{ 1.3378,1.350806},{1.34296,1.36371 },{1.34844,1.350806},{1.35388,1.366129},{1.35928,1.390323},
//	{1.36376,1.38629 },{1.36752,1.396774},{1.37132,1.429032},{1.37576,1.421774},{1.38068,1.431452},{1.38588,1.435484},{1.39068,1.459677},{1.39484,1.455645},{1.39844,1.473387},{1.40212,1.502419},
//	{1.40664,1.491935},{1.41208,1.504032},{1.41808,1.512903},{1.42348,1.516935},{ 1.428 ,1.521774},{1.43212,1.541129},{1.43612,1.56129 },{1.44064,1.56129 },{1.44564,1.558065},{ 1.4508,1.590323},
//	{1.45584,1.583871},{1.46012,1.589516},{ 1.4642,1.606452},{1.46836,1.618548},{ 1.4726,1.627419},{1.47712,1.631452},{1.48172,1.659677},{1.48644,1.647581},{1.49128,1.653226},{1.49616,1.685484},
//	{1.50088,1.678226},{1.50504,1.682258},{1.50952,1.702419},{1.51432,1.71129 },{1.51908,1.716129},{1.52336,1.714516},{1.52704,1.759677},{1.53108,1.741935},{1.53568,1.754839},{1.54044,1.779032},
//	{ 1.545 ,1.766935},{1.54952,1.783065},{ 1.5544,1.781452},{1.55956,1.809677},{1.56464,1.798387},{1.56948,1.806452},{1.57352,1.841129},{1.57704,1.829839},{1.58008,1.843548},{1.58348,1.871774},
//	{1.58784,1.862097},{1.59316,1.866129},{ 1.5992,1.875806},{1.60524,1.895968},{1.61088,1.877419},{ 1.615 ,1.903226},{1.61792,1.926613},{ 1.6204, 1.925  },{1.62372,1.939516},{ 1.6284,1.951613},
//	{1.63368,1.96371 },{1.63936,1.944355},{1.64472,1.970161},{1.64916,1.982258},{1.65316,1.978226},{1.65756,1.991935},{1.66216,2.006452},{ 1.6666,2.010484},{1.67096,2.009677},{1.67508,2.028226},
//	{1.68004,2.041935},{ 1.6856,2.035484},{1.69056,2.053226},{1.69488,2.066129},{1.69868,2.06129 },{1.70256,2.076613},{1.70684,2.097581},{1.71152,2.097581},{1.71616,2.093548},{1.72076,2.121774},
//	{1.72488,2.123387},{1.72876,2.129032},{1.73284,2.135484},{ 1.7372,2.159677},{ 1.7418,2.153226},{1.74652,2.156452},{1.75116,2.184677},{1.75528,2.177419},{1.75928,2.189516},{1.76332,2.202419},
//	{1.76772,2.224194},{1.77248,2.209677},{1.77708,2.224194},{1.78128,2.245968},{ 1.7854,2.242742},{ 1.7896,2.243548},{1.79368,2.269355},{ 1.7978,2.274194},{1.80204,2.270968},{ 1.8064,2.289516},
//	{1.81104,2.302419},{1.81548,2.292742},{1.81948,2.309677},{1.82336,2.331452},{1.82728,2.328226},{ 1.831 ,2.337097},{ 1.8348,2.358871},{ 1.839 ,2.366935},{1.84364,2.358871},{1.84808,2.381452},
//	{1.85168,2.387097},{ 1.8552,2.394355},{1.85932,2.393548},{1.86412, 2.425  },{1.86908,2.412097},{1.87344,2.415323},{1.87736,2.445968},{1.88112,2.445968},{1.88496,2.454839},{1.88948,2.458065},
//	{1.89424,2.480645},{1.89848,2.467742},{1.90196,2.484677},{1.90488,2.508871},{1.90868,2.514516},{1.91364,2.509677},{1.91856,2.528226},{ 1.9228,2.540323},{1.92624,2.529839},{1.92968,2.551613},
//	{1.93344,2.570968},{ 1.9378,2.568548},{1.94232,2.579032},{ 1.9466,2.592742},{ 1.9506,  2.6   },{1.95436,2.595161},{1.95816,2.619355},{1.96208,2.631452},{ 1.966 ,2.620968},{1.96988,2.645968},
//	{ 1.9738,2.662097},{1.97804,2.66129 },{1.98224,2.659677},{1.98628,2.691935},{1.99048,2.687903},{1.99464,2.68629 },{ 1.999 ,2.709677},{ 2.0034,2.712097},{ 2.0074,2.716129},{ 2.0108,2.729032},
//	{ 2.0142,2.760484},{2.01796,2.745161},{2.02196,2.760484},{ 2.026 ,2.777419},{2.02988,2.787097},{2.03376,2.782258},{2.03744,2.808065},{2.04128,2.81129 },{2.04552,2.81129 },{2.04996,2.821774},
//	{2.05436,2.839516},{2.05832,2.839516},{2.06184,2.849194},{2.06508, 2.875  },{2.06848,2.879839},{2.07264,2.884677},{2.07708,2.88629 },{ 2.081 ,2.906452},{ 2.0842,2.901613},{2.08688,2.916129},
//	{2.09036,2.943548},{2.09512,2.941935},{2.10008,2.935484},{ 2.1042,2.959677},{2.10776,2.965323},{2.11084,2.966129},{2.11432,2.98871 },{ 2.1182,3.008871},{2.12268,3.001613},{2.12684,3.008871},
//	{2.13012,3.033871},{2.13316,3.031452},{2.13672,3.041935},{2.14104,3.055645},{ 2.1456,3.070968},{2.14964,3.055645},{ 2.1532,3.087097},{ 2.1562,3.103226},{2.15948,3.106452},{2.16328,3.105645},
//	{ 2.1674,3.128226},{2.17144,3.127419},{ 2.175 , 3.125  },{2.17772,3.157258},{2.18076,3.164516},{2.18504,3.173387},{2.18992,3.169355},{2.19436,3.195968},{2.19796,3.183065},{2.20096,3.204839},
//	{2.20412,3.220968},{2.20804,3.231452},{2.21224,3.228226},{2.21628,3.245968},{2.21984,3.262097},{2.22272,3.260484},{2.22588,3.275806},{2.22984,3.294355},{2.23428,3.295161},{2.23836,3.292742},
//	{2.24148, 3.325  },{2.24456,3.329839},{2.24844, 3.325  },{2.25272,3.339516},{2.25652,3.36371 },{2.26012,3.353226},{2.26372,3.367742},{2.26764,3.392742},{ 2.2712,3.392742},{2.27432,3.396774},
//	{2.27772,3.420968},{2.28144,3.428226},{2.28488,3.424194},{2.28832,  3.45  },{2.29208,3.459677},{2.29584,3.459677},{ 2.2996,3.468548},{2.30344,3.494355},{2.30724,3.490323},{2.31132,3.494355},
//	{ 2.3152,3.515323},{2.31828,3.528226},{ 2.3214,3.532258},{2.32504,3.554032},{2.32924,3.562097},{ 2.3334,3.557258},{2.33688,3.565323},{2.33964,3.595161},{2.34268,3.598387},{2.34624,3.606452},
//	{2.35036,3.624194},{2.35472,3.630645},{2.35884,3.626613},{2.36196,3.63629 },{2.36472,3.668548},{2.36804,3.659677},{2.37232,3.674194},{2.37648,3.690323},{2.37984,3.698387},{2.38264,3.699194},
//	{ 2.3858, 3.725  },{2.38968,3.735484},{2.39368,3.722581},{2.39744,3.737903},{2.40076,3.76129 },{2.40376,3.766129},{ 2.4066,3.771774},{2.40992,3.804839},{2.41396,3.794355},{2.41776,3.795161},
//	{2.42108,3.814516},{ 2.424 ,3.841129},{2.42708,3.828226},{ 2.431 ,3.848387},{2.43532,3.862903},{2.43944,3.865323},{2.44252,3.873387},{2.44476,3.904839},{2.44772,3.912097},{2.45156,3.906452},
//	{2.45584,3.929839},{2.46004,3.937903},{ 2.4634,3.934677},{2.46636,3.943548},{ 2.4696,3.978226},{2.47332,3.968548},{ 2.477 ,3.975806},{ 2.4802,3.995968},{2.48316,4.01371 },{2.48624,4.009677},
//	{ 2.4898,4.029032},{2.49364,4.045161},{2.49712,4.040323},{2.50036,4.053226},{2.50336,4.076613},{2.50684,4.08629 },{2.51092,4.076613},{ 2.5152,4.108871},{2.51904,4.112903},{2.52196,4.118548},
//	{2.52452,4.133065},{2.52764,4.16129 },{2.53136,4.150806},{2.53516,4.160484},{2.53844,4.185484},{2.54132,4.187097},{2.54432,4.191129},{ 2.5476,4.216129},{2.55104,4.230645},{ 2.5544, 4.225  },
//	{2.55796,4.244355},{2.56192,4.26129 },{2.56572,4.258065},{ 2.5688,4.266129},{2.57156,4.301613},{2.57492,4.297581},{2.57844,4.301613},{2.58152,4.320968},{2.58452,4.342742},{2.58752,4.329839},
//	{ 2.5908,4.349194},{2.59416,4.372581},{2.59784,4.369355},{2.60148,4.376613},{2.60468,4.398387},{2.60772,4.409677},{2.61084,4.408065},{2.61388,4.435484},{2.61704,4.445161},{2.62032,4.445968},
//	{2.62392,4.455645},{2.62772,4.480645},{ 2.631 , 4.475  },{2.63408,4.48629 },{2.63736,4.507258},{2.64072,4.520968},{2.64428,4.521774},{2.64788,4.540323},{2.65132,4.556452},{2.65428,4.548387},
//	{2.65708,4.570161},{2.66016,4.590323},{2.66348,4.591935},{2.66652,4.597581},{2.66964,4.627419},{2.67316,4.629839},{2.67668,4.630645},{2.67984,4.645161},{2.68236,4.674194},{ 2.685 , 4.675  },
//	{2.68804,4.684677},{2.69144,4.712903},{ 2.695 ,4.705645},{2.69848,4.712903},{ 2.7016,4.730645},{2.70476,4.748387},{2.70796,4.745161},{ 2.711 ,4.770968},{ 2.714 ,4.78629 },{2.71712,4.787903},
//	{2.72044,4.789516},{2.72396,4.816935},{2.72752,4.814516},{2.73104,4.819355},{2.73436,4.844355},{ 2.7378,4.862903},{2.74156,4.852419},{ 2.7446,4.875806},{ 2.747 ,4.904032},{2.74968,4.893548},
//	{ 2.7532,4.905645},{2.75676,4.927419},{2.75972,4.937903},{ 2.7624,4.935484},{2.76536,4.966129},{2.76852,4.976613},{ 2.772 ,4.975806},{ 2.7752,4.983871},{ 2.7782,5.01371 },{2.78128,5.005645},
//	{2.78452,5.020161},{2.78784,5.043548},{ 2.791 ,5.047581},{2.79408,5.047581},{ 2.797 ,5.070161},{2.79984,5.085484},{2.80284,5.083065},{2.80608,5.102419},{2.80948,5.118548},{2.81252,5.122581},
//	{2.81536,5.130645},{2.81824,5.158065},{2.82116,5.160484},{2.82412,5.166129},{2.82736,5.175806},{2.83068,5.198387},{2.83368,5.194355},{2.83628,5.21129 },{ 2.839 ,5.235484},{2.84228,5.241935},
//	{ 2.8456,5.239516},{2.84868,5.262097},{2.85176,5.273387},{2.85488,5.271774},{2.85768,  5.3   },{2.86068,5.320161},{2.86384,5.318548},{2.86676,5.318548},{2.86968,  5.35  },{2.87292,  5.35  },
//	{ 2.8762,5.353226},{2.87948,5.378226},{2.88264,5.389516},{2.88564,5.383871},{2.88872,5.404032},{ 2.892 ,5.422581},{2.89524,5.412903},{2.89844,5.430645},{ 2.9014,5.454839},{2.90432,5.466935},
//	{ 2.907 ,5.467742},{ 2.9098,5.491129},{2.91284,5.506452},{ 2.916 ,5.504839},{2.91904,5.514516},{ 2.9216,5.541129},{2.92356,5.540323},{2.92608,5.558871},{2.92944,5.578226},{ 2.933 ,5.578226},
//	{2.93548,5.581452},{2.93744,5.604839},{2.93996,5.623387},{ 2.9434,5.612097},{ 2.947 ,5.629032},{2.95008,5.645161},{2.95268,5.652419},{2.95544,5.655645},{2.95832,5.687903},{ 2.9616,5.685484},
//	{2.96492,5.687097},{2.96796,5.710484},{2.97012,5.730645},{2.97228,5.73629 },{2.97532,5.745161},{2.97912,5.766935},{2.98276,5.76129 },{2.98552,5.769355},{2.98772,5.791935},{2.99008,5.816129},
//	{ 2.9936,5.806452},{ 2.9974,5.829839},{ 3.0002,5.842742},{3.00232,5.854032},{3.00504,5.858065},{3.00852,5.88871 },{3.01228,5.884677},{3.01568,5.887903},{3.01864,5.912903},{3.02088,5.928226},
//	{3.02336,5.932258},{3.02636,5.945968},{3.02968,5.968548},{3.03268,5.956452},{3.03484,5.978226},{3.03708,5.997581},{3.03956,6.008871},{3.04208,6.002419},{3.04476,6.031452},{3.04712,6.040323},
//	{3.04968,6.043548},{3.05252,6.051613},{ 3.0552,6.078226},{3.05792,6.079032},{3.06104,6.093548},{ 3.0648,6.115323},{3.06832,6.116935},{3.07108,6.121774},{3.07312,6.141935},{3.07508,6.169355},
//	{3.07772,6.162097},{ 3.081 ,6.178226},{3.08412,6.198387},{3.08664,6.202419},{ 3.089 ,  6.2   },{3.09164,6.235484},{3.09444,6.234677},{3.09732,6.23871 },{3.10056,6.264516},{3.10392,6.276613},
//	{3.10736,6.269355},{3.11044,6.283871},{3.11284,6.316129},{ 3.115 ,6.315323},{3.11764,6.326613},{3.12072,6.347581},{3.12384,6.358871},{3.12656,6.356452},{ 3.129 ,6.383871},{3.13136,6.401613},
//	{ 3.1342,6.399194},{3.13696,6.409677},{ 3.1392,6.437903},{3.14128,6.434677},{ 3.144 ,6.443548},{3.14768,6.466935},{3.15116,6.475806},{ 3.1536,6.483065},{3.15548,  6.5   },{3.15828, 6.525  },
//	{3.16184,6.514516},{3.16492,6.528226},{3.16708,6.556452},{3.16892,6.565323},{ 3.1712,6.562903},{3.17344,6.593548},{3.17604,  6.6   },{3.17932,6.595968},{3.18256,6.612097},{3.18548,6.632258},
//	{3.18808,6.637097},{ 3.1906,6.645161},{3.19296, 6.675  },{ 3.1956, 6.675  },{3.19852,6.676613},{3.20148,6.693548},{3.20444,6.718548},{3.20728,6.707258},{3.20956,6.733871},{3.21176,6.758065},
//	{3.21412,6.759677},{3.21684,6.762097},{ 3.2196,6.791935},{3.22216,6.791935},{3.22468,6.797581},{3.22736,6.818548},{  3.23 ,6.83629 },{3.23216,6.830645},{3.23428,6.852419},{3.23672,6.880645},
//	{3.23936,6.873387},{ 3.2422,6.881452},{3.24524,6.907258},{3.24836,6.919355},{3.25104,6.918548},{3.25304,6.941935},{3.25496,6.957258},{3.25728,6.952419},{3.25968,6.962903},{3.26216,6.984677},
//	{ 3.2646,6.987097},{3.26716,6.996774},{3.26992,7.023387},{3.27296,7.030645},{3.27604,7.030645},{3.27888,7.041129},{3.28128,7.066935},{3.28288,7.057258},{3.28456,7.081452},{3.28712,7.104839},
//	{3.29036,7.107258},{3.29328,7.104839},{ 3.2956,7.141935},{ 3.2978,7.145968},{3.30008,7.145968},{3.30208,7.162903},{3.30432,7.184677},{3.30692,7.184677},{3.30964,7.18871 },{3.31204,7.220968},
//	{3.31452,7.218548},{3.31708,7.226613},{3.31976,7.247581},{3.32236,7.266935},{3.32492,7.257258},{3.32752,7.280645},{3.32976,7.295968},{3.33156,7.304839},{3.33372,7.309677},{3.33648,7.33871 },
//	{3.33932,7.341129},{3.34172,7.341935},{3.34408,7.374194},{ 3.3466,7.38629 },{3.34932,7.380645},{ 3.3518,7.395968},{3.35384,7.422581},{3.35592,7.415323},{ 3.3588,7.428226},{3.36184,7.447581},
//	{3.36452,7.462097},{3.36688,7.46129 },{ 3.3686,7.485484},{3.37032,7.507258},{3.37264,7.499194},{ 3.3756,7.51129 },{3.37844,7.537097},{3.38088,7.537903},{3.38304,7.544355},{3.38508,7.575806},
//	{3.38728,7.574194},{ 3.3898,7.583871},{3.39248,7.595968},{3.39508,7.614516},{3.39748,7.612903},{3.39976,7.628226},{3.40208,7.652419},{ 3.4044,7.659677},{ 3.4068,7.662097},{3.40928,7.685484},
//	{3.41156,7.690323},{3.41368,7.691935},{3.41616,7.716129},{3.41868,7.735484},{3.42108,7.739516},{3.42368,7.748387},{3.42644,7.776613},{3.42912,7.776613},{3.43152,7.779839},{ 3.4336,7.805645},
//	{ 3.4358, 7.825  },{3.43816,7.819355},{3.44056,7.845161},{3.44288,7.862903},{3.44488,7.858065},{3.44728,7.866129},{3.44996,7.893548},{3.45224,  7.9   },{3.45416,7.901613},{3.45684,7.935484},
//	{3.46012,7.947581},{3.46296,7.942742},{3.46512,7.958871},{3.46736,7.992742},{3.46964,7.977419},{3.47192,7.999194},{3.47392,8.025806},{3.47612,8.030645},{3.47856,8.022581},{ 3.481 ,  8.05  },
//	{3.48316,8.065323},{ 3.485 ,8.06371 },{3.48748,8.084677},{3.49056,  8.1   },{ 3.4932,8.104839},{3.49532,8.115323},{3.49732,8.148387},{3.49956,8.148387},{3.50192,8.154839},{3.50436,8.164516},
//	{3.50668,8.18629 },{ 3.5092,8.175806},{ 3.5118,8.196774},{ 3.514 ,8.224194},{3.51604,8.225806},{ 3.5186,8.231452},{3.52124,8.253226},{3.52352,8.26371 },{ 3.5256,8.262097},{3.52796,8.292742},
//	{3.53064,8.308871},{3.53292,8.312097},{3.53468,8.321774},{ 3.5366,8.353226},{3.53896,8.346774},{3.54136,8.351613},{3.54336,8.371774},{3.54588,8.390323},{ 3.5488,8.38629 },{ 3.5514,8.407258},
//	{3.55368,8.425806},{3.55568,8.427419},{3.55788,8.433871},{3.56024,8.458871},{3.56244,8.467742},{ 3.5644,8.466129},{3.56608,8.498387},{3.56824,8.509677},{3.57088,8.508871},{3.57332,8.518548},
//	{3.57516,8.551613},{3.57672,8.541129},{3.57884,8.558871},{3.58192,8.583065},{3.58516,8.583871},{ 3.5876,8.581452},{3.58932,8.617742},{3.59104,8.635484},{3.59328,8.625806},{3.59552,8.646774},
//	{3.59748,8.66371 },{3.59928,8.670161},{3.60092,8.677419},{3.60256,8.716129},{3.60464,8.712097},{3.60736,8.712903},{3.60996,8.730645},{3.61192,  8.75  },{3.61404,8.744355},{3.61652,8.764516},
//	{ 3.6192,8.791129},{3.62116,8.791935},{3.62252,8.802419},{ 3.6244,8.822581},{3.62684,8.827419},{3.62932,8.822581},{3.63168,8.852419},{3.63432,8.864516},{ 3.637 ,8.86129 },{3.63944,8.872581},
//	{3.64136,8.908065},{ 3.643 ,8.904839},{3.64512,8.914516},{3.64804,8.93629 },{3.65104,8.939516},{ 3.6534,8.941935},{3.65496,8.964516},{3.65656,8.993548},{3.65896,8.983065},{3.66196,8.985484},
//	{3.66432,9.012097},{3.66608,9.021774},{3.66824, 9.025  },{3.67092,9.056452},{3.67356,9.064516},{3.67612,9.060484},{3.67772,9.067742},{3.67896,9.107258},{3.68092,9.104839},{3.68364,9.109677},
//	{3.68616,9.140323},{3.68784,9.144355},{3.68952,9.146774},{ 3.6916,9.176613},{3.69376,9.187097},{ 3.696 ,9.177419},{3.69804,9.21129 },{3.70032,9.228226},{ 3.7028,9.221774},{3.70476,9.233065},
//	{3.70608,9.269355},{3.70772,9.266129},{3.71004,9.262903},{3.71252,9.279839},{3.71452,9.295161},{3.71592,9.293548},{ 3.7176,9.315323},{ 3.7202,9.337097},{3.72268,9.332258},{3.72452,9.345968},
//	{ 3.7264,9.369355},{ 3.7288,9.376613},{3.73116,9.377419},{3.73292,9.410484},{3.73476, 9.425  },{3.73688,9.422581},{3.73936,9.427419},{3.74196,9.46129 },{3.74392,9.465323},{3.74608,9.479032},
//	{ 3.7486,9.502419},{ 3.751 ,9.503226},{3.75316,  9.5   },{ 3.7546,9.522581},{3.75628,9.545968},{ 3.7592,9.53871 },{3.76252,9.550806},{3.76448,9.575806},{3.76536,9.591129},{3.76716,9.591129},
//	{3.76992,9.615323},{3.77216,9.615323},{3.77356,9.616935},{ 3.775 ,9.63629 },{3.77704,9.658065},{3.77948,9.655645},{ 3.7818,9.667742},{ 3.7834,9.696774},{ 3.7848,9.695161},{3.78656,9.701613},
//	{3.78848,9.725806},{3.79044,9.741129},{3.79248,9.739516},{3.79472,9.769355},{ 3.797 ,9.784677},{3.79948,9.789516},{3.80172,9.793548},{ 3.8036,9.827419},{3.80552,9.833871},{ 3.8076,9.833871},
//	{3.80928,9.859677},{3.81088,9.878226},{3.81304,9.874194},{ 3.8156,9.892742},{3.81736,9.91129 },{3.81884,9.906452},{3.82076,9.923387},{3.82344,9.941935},{3.82596,9.951613},{3.82784,9.93629 },
//	{3.82896,9.959677},{3.83012,9.965323},{ 3.832 ,9.956452},{3.83388,9.974194},{3.83528,10.00645},{ 3.837 ,10.00726},{3.83924,10.02258},{ 3.8416,10.04435},{3.84348,10.05242},{3.84496,10.05645},
//	{3.84672,10.07903},{3.84904,10.10403},{3.85068,10.09919},{3.85232,10.12258},{3.85444,10.14677},{3.85708,10.14758},{ 3.8596,10.14274},{3.86108, 10.175 },{3.86244,10.18629},{3.86492,10.19113},
//	{3.86788,10.20726},{3.87004,10.22742},{3.87164,10.22823},{3.87332,10.23629},{3.87496,10.26371},{ 3.8762,10.26371},{3.87804,10.26855},{ 3.8804,10.29274},{ 3.8822,10.30565},{ 3.8834,10.30161},
//	{3.88472,10.33468},{ 3.8868,10.34839},{3.88908,10.34677},{3.89132,10.35323},{3.89332,10.38065},{3.89508,10.37742},{3.89688,10.38145},{3.89888,10.40887},{3.90104,10.42016},{3.90304,10.41694},
//	{3.90484,10.43226},{ 3.9066,10.45484},{3.90864,10.44839},{3.91068,10.46613},{3.91244,10.48306},{3.91384,10.49597},{3.91532,10.49274},{ 3.9172,10.51371},{3.91904,10.52903},{3.92048,10.52742},
//	{ 3.9222,10.53871},{3.92432,10.5629 },{3.92608,10.55968},{3.92756,10.56935},{3.92916,10.59758},{3.93088,10.60081},{3.93316,  10.6  },{3.93548,10.61532},{ 3.9376,10.6371 },{ 3.9392,10.62984},
//	{3.94064,10.65242},{3.94264,10.67016},{3.94488,10.66855},{3.94672,10.6629 },{ 3.948 ,10.69516},{3.94912,  10.7  },{3.95096,10.70081},{3.95356,10.73145},{3.95596,10.74194},{3.95768,10.73306},
//	{3.95896,10.74597},{3.96056,10.77581},{3.96268,10.77097},{3.96432,10.78387},{ 3.966 ,10.80726},{3.96812,10.81452},{3.97004,10.80081},{3.97132,10.82177},{3.97256,10.8379 },{3.97424,10.8371 },
//	{3.97636,10.84435},{3.97844,10.87419},{3.97992,10.87258},{3.98116,10.88226},{ 3.983 ,10.91532},{3.98532, 10.925 },{3.98764,10.92097},{ 3.9896,10.93065},{3.99128,10.95565},{ 3.9926,10.94919},
//	{3.99384,10.96532},{ 3.9956,10.9871 },{3.99724,10.98952},{3.99856,10.98629},{4.00032,11.01452},{4.00228,11.03226},{4.00408,11.02339},{4.00588,11.04677},{4.00776,11.07258},{4.00964,11.06774},
//	{4.01168,11.07258},{4.01372,11.11048},{4.01532,11.11371},{ 4.0168,11.12097},{4.01884, 11.15  },{4.02104,11.16694},{4.02316,11.15484},{4.02488,11.18145},{4.02656,11.20645},{4.02856,11.20484},
//	{ 4.0306,11.21129},{ 4.0326,11.2379 },{4.03392,11.24677},{4.03512,11.25161},{ 4.0372,11.27339},{4.03932,11.2871 },{4.04088,11.28226},{4.04212,11.30403},{4.04372,11.33387},{4.04552,11.32903},
//	{ 4.0476,11.33952},{4.04976,11.35887},{ 4.0516,11.37258},{4.05352,11.36935},{ 4.0556,11.39597},{4.05732,11.42097},{4.05916,11.42419},{4.06112,11.44113},{4.06324,11.46371},{4.06516,11.46129},
//	{4.06668,11.46855},{ 4.0684,11.49919},{4.07008,11.51452},{4.07212,11.51048},{4.07424,11.50887},{4.07576,11.5379 },{4.07684,11.53387},{ 4.0786,11.55323},{4.08124,11.57742},{4.08364,11.57661},
//	{4.08528,11.57339},{4.08664,11.61129},{4.08828, 11.625 },{4.09056,11.62339},{4.09308,11.64355},{ 4.0952,11.6629 },{4.09696,11.66694},{4.09864,11.67419},{ 4.1006,11.70968},{ 4.1028,11.70806},
//	{4.10508,11.71694},{4.10684,11.73306},{4.10844,11.75242},{4.11048,11.74677},{4.11292,11.77097},{ 4.115 ,11.78952},{4.11672,11.7871 },{ 4.1182,11.79919},{4.11992,11.82742},{4.12156,11.83548},
//	{ 4.123 ,11.83629},{4.12536,11.8621 },{4.12808,11.87016},{4.12988,11.86855},{4.13096,11.88629},{4.13324,11.91935},{ 4.1364,11.90242},{4.13892,11.91694},{4.14028,11.94113},{4.14132,11.96129},
//	{4.14296,11.95887},{4.14548,11.98065},{ 4.148 ,11.99194},{4.14992,11.98226},{4.15188,11.99839},{4.15392,12.02339},{ 4.1558,12.02903},{4.15724,12.03871},{4.15876,12.06694},{4.16004,12.07339},
//	{4.16172, 12.075 },{4.16408,12.08871},{ 4.1664,12.11129},{4.16828,12.10887},{4.17004,12.12258},{4.17224,12.14758},{4.17424,12.15081},{4.17612,12.16048},{ 4.1782,12.18952},{4.18052,12.19274},
//	{4.18224,12.19435},{4.18424,12.21855},{4.18652,12.2371 },{4.18848,12.2379 },{4.19036,12.24516},{4.19216,12.27823},{ 4.1938,12.27419},{4.19532,12.28548},{4.19716,12.30161},{4.19956,12.31855},
//	{4.20172,12.31452},{4.20336,12.33871},{4.20448,12.3621 },{4.20592,12.3621 },{4.20808,12.36613},{4.21032,12.39113},{4.21192,12.40565},{4.21364,12.40323},{4.21592,12.43306},{4.21808,12.44677},
//	{4.21956,12.45161},{4.22108,12.46129},{4.22304,12.4871 },{4.22524,12.47823},{4.22696,  12.5  },{ 4.2286,12.52097},{4.23072,12.52823},{4.23292,12.52742},{4.23488,12.55565},{4.23628,12.57742},
//	{4.23784,12.56774},{4.23976,12.58548},{4.24192,12.61048},{4.24388,12.61452},{4.24572,12.61774},{4.24776,12.65565},{ 4.2498,12.64919},{4.25188,12.65968},{ 4.2538,12.67339},{4.25556,12.70403},
//	{4.25736,12.69758},{4.25932,12.71694},{4.26092,12.74597},{4.26232, 12.75  },{4.26408,12.75645},{ 4.2662,12.77742},{4.26808,12.78226},{4.26968,12.78145},{4.27164,12.8129 },{ 4.274 ,12.82419},
//	{4.27644,12.82661},{4.27812,12.83871},{4.27972,12.87742},{4.28148,12.87581},{ 4.2834,12.87419},{4.28516,12.89597},{4.28664,12.91371},{4.28832,12.91048},{4.29024,12.92984},{4.29228,12.95161},
//	{4.29388,12.94194},{4.29532,12.95806},{4.29664,12.98226},{ 4.2982,12.98952},{4.30032,12.98629},{4.30256,13.01532},{ 4.3046,13.03387},{4.30656,13.03468},{4.30864,13.04435},{4.31068,13.07339},
//	{4.31252,13.06855},{4.31456,13.08629},{4.31696,13.10806},{4.31876,13.10887},{4.31976,13.11532},{4.32148,13.14113},{4.32424,13.15565},{4.32668,13.14758},{4.32824,13.16694},{4.32956,13.18871},
//	{4.33168,13.19032},{4.33372,13.19435},{ 4.335 ,13.23145},{4.33652,13.23548},{ 4.3384,13.24435},{4.34032,13.2629 },{ 4.3424,13.28952},{4.34456,13.28306},{4.34644,13.30645},{4.34808,13.33387},
//	{4.34984,13.33387},{4.35188,13.34032},{ 4.354 ,13.36048},{4.35592,13.37177},{ 4.3576,13.37016},{4.35932,13.39355},{4.36144,13.41371},{ 4.3636,13.41129},{4.36528,13.4129 },{4.36672,13.45484},
//	{4.36868,13.45081},{4.37068,13.45242},{4.37236,13.47984},{4.37424,13.49435},{4.37648,13.48468},{4.37832,13.5121 },{4.37972,13.5371 },{4.38136,13.52661},{4.38344,13.54597},{4.38552,13.57339},
//	{4.38708,13.57661},{4.38872,13.57581},{ 4.3908,13.60968},{4.39296,13.61694},{4.39496,13.62097},{4.39688,13.63629},{4.39876,13.6629 },{4.40028,13.66452},{4.40168,13.67984},{4.40352,13.70323},
//	{ 4.4054,13.70323},{4.40724,13.70726},{4.40916,13.73306},{4.41132,13.74597},{ 4.4134,13.74355},{4.41524,13.77177},{4.41732,13.78871},{ 4.4196,13.79597},{4.42132,13.79597},{4.42312,13.83548},
//	{4.42492,13.8371 },{4.42668,13.84113},{4.42856,13.85887},{4.43044,13.88065},{4.43216, 13.875 },{4.43404,13.89274},{ 4.4362,13.91935},{4.43808,13.91774},{4.43996,13.92742},{4.44184,13.95081},
//	{4.44404,13.97177},{4.44608,13.96532},{ 4.4478,13.99516},{ 4.4498,14.00887},{4.45176,   14   },{4.45348,14.01532},{ 4.4552, 14.05  },{4.45708,14.04274},{4.45896,14.05565},{4.46064,14.08226},
//	{4.46224,14.09355},{4.46424,14.09355},{4.46624,14.11371},{4.46796,14.13145},{4.46976,14.12581},{4.47152,14.14194},{4.47312,14.16694},{4.47488, 14.175 },{ 4.477 ,14.17177},{ 4.4792,14.20242},
//	{4.48088,14.20806},{ 4.4826,14.20887},{4.48456,14.22742},{ 4.4868,14.25323},{4.48852,14.25161},{  4.49 ,14.26532},{4.49188,14.29597},{4.49396,14.29839},{4.49572,14.30242},{ 4.4976,14.32177},
//	{4.50004,14.33952},{ 4.5024,14.33306},{ 4.504 ,14.36452},{4.50532,14.38871},{4.50696,14.39435},{4.50896,  14.4  },{4.51128,14.42984},{ 4.5134,14.42742},{4.51512,14.43387},{4.51716,14.45403},
//	{4.51936,14.47419},{4.52136,14.47097},{ 4.523 ,14.49597},{4.52492,14.51613},{ 4.5268,14.50887},{4.52872, 14.525 },{ 4.5304,14.55323},{4.53228,14.56532},{4.53428,14.5621 },{4.53648,14.58871},
//	{4.53848,14.60403},{4.54016,14.60726},{4.54192,14.61613},{4.54384,14.64113},{4.54584,14.63952},{4.54768,14.65323},{ 4.5494,14.67419},{4.55132,14.67984},{ 4.5534,14.68226},{ 4.555 ,14.69516},
//	{4.55672,14.72258},{4.55888,14.7121 },{4.56096,14.72258},{4.56256,14.74597},{4.56424,14.75323},{4.56648, 14.75  },{ 4.5688,14.7879 },{4.57072,14.79113},{4.57224,14.79113},{4.57376,14.81532},
//	{ 4.5758,14.84113},{4.57772,14.83629},{4.57916,14.84677},{4.58076,14.87984},{4.58304,14.87823},{ 4.585 ,14.88065},{4.58636,14.91048},{4.58832,14.92339},{ 4.5908,14.91452},{ 4.5926,14.95081},
//	{4.59428,14.96371},{4.59628,14.9629 },{4.59844,14.97258},{4.60016,15.00565},{4.60172,15.00645},{4.60356,15.01371},{4.60552,15.04113},{4.60748, 15.05  },{4.60916, 15.05  },{4.61096,15.07016},
//	{4.61292,15.09032},{4.61448,15.07984},{4.61636,15.10403},{4.61872,15.12177},{ 4.6208,15.12984},{4.62228,15.13065},{4.62392,15.15887},{4.62588,15.16855},{4.62784,15.17339},{4.62968,15.18226},
//	{4.63156,15.2129 },{ 4.6334,15.20806},{4.63524,15.22177},{4.63744,15.24919}};

	int  N_muni = 81;
	double muni[][2] = {//...наношунгит, расчет;
{2	,	0.047193413	},{4	,	0.091290125	},{6	,	0.13274721	},{8	,	0.171945794	},{10,	0.20920766	},{12,	0.244807066	},{14,	0.278980133	},{16,	0.311932199	},{18,	0.343843668	},{20,	0.374874663	},
{22,	0.405168834	},{24,	0.434856477	},{26,	0.464057097	},{28,	0.492881646	},{30,	0.521434363	},{32,	0.549814394	},{34,	0.578117282	},{36,	0.60643614	},{38,	0.634862837	},{40,	0.663489062	},
{42,	0.692407133	},{44,	0.72171107	},{46,	0.751497173	},{48,	0.781864907	},{50,	0.812917568	},{52,	0.844762837	},{54,	0.877513626	},{56,	0.911288614	},{58,	0.946213025	},{60,	0.982419326	},
{62,	1.020047975	},{64,	1.059248279	},{66,	1.100179289	},{68,	1.143010676	},{70,	1.187923628	},{72,	1.23511175	},{74,	1.284782003	},{76,	1.337155762	},{78,	1.392469928	},{80,	1.450977838	},
{82,	1.512950372	},{84,	1.578676775	},{86,	1.648465432	},{88,	1.722643933	},{90,	1.801559586	},{92,	1.885578724	},{94,	1.975085877	},{96,	2.070482426	},{98,	2.172184545	},{100,	2.28061999	},
{102,	2.39622472	},{104,	2.519438668	},{106,	2.650699951	},{108,	2.790440244	},{110,	2.939077326	},{112,	3.097000642	},{114,	3.264597129	},{116,	3.442202962	},{118,	3.630123582	},{120,	3.82862398	},
{122,	4.037925944	},{124,	4.25820798	},{126,	4.489599341	},{128,	4.732182223	},{130,	4.985991632	},{132,	5.251019715	},{134,	5.527217883	},{136,	5.814500048	},{138,	6.112747277	},{140,	6.421751298	},
{142,	6.740785797	},{144,	7.067903853	},{146,	7.403100592	},{148,	7.746328675	},{150,	8.097274092	},{152,	8.455488308	},{154,	8.820353716	},{156,	9.191225886	},{158,	9.305624539	},{160,	9.400229861	},
{162,	9.426676049	}};
	double muni_E[][2] = {//...наношунгит, энергия, расчет;
{2	,	0.000470858	},{4	,	0.001817409	},{6	,	0.003951743	},{8	,	0.006798665	},{10,	0.010293542	},{12,	0.014380588	},{14,	0.019011477	},{16,	0.024144236	},{18,	0.02974233	},{20,	0.035773919	},
{22,	0.042211241	},{24,	0.049030102	},{26,	0.056209446	},{28,	0.063731008	},{30,	0.071579008	},{32,	0.079739911	},{34,	0.088202218	},{36,	0.0969563	},{38,	0.105994254	},{40,	0.1153098	},
{42,	0.12489819	},{44,	0.134756142	},{46,	0.144881796	},{48,	0.155274678	},{50,	0.165935683	},{52,	0.176867067	},{54,	0.18807244	},{56,	0.199556777	},{58,	0.211326422	},{60,	0.223389104	},
{62,	0.235753954	},{64,	0.248431527	},{66,	0.261433829	},{68,	0.27477435	},{70,	0.288468097	},{72,	0.302531624	},{74,	0.316983073	},{76,	0.331842215	},{78,	0.347130505	},{80,	0.362871145	},
{82,	0.379089171	},{84,	0.395811539	},{86,	0.413067217	},{88,	0.430887279	},{90,	0.449304996	},{92,	0.46835594	},{94,	0.488078058	},{96,	0.508511747	},{98,	0.529699899	},{100,	0.551687933	},
{102,	0.574523781	},{104,	0.598257863	},{106,	0.62294295	},{108,	0.648634086	},{110,	0.675388348	},{112,	0.703264757	},{114,	0.7323236	},{116,	0.762626659	},{118,	0.794236622	},{120,	0.827216713	},
{122,	0.861630314	},{124,	0.897540618	},{126,	0.935009959	},{128,	0.974099648	},{130,	1.0148698	},{132,	1.057379445	},{134,	1.101687003	},{136,	1.147852606	},{138,	1.195942759	},{140,	1.246029792	},
{142,	1.298237583	},{144,	1.352784572	},{146,	1.40959749	},{148,	1.468632493	},{150,	1.529921601	},{152,	1.593509058	},{154,	1.659442427	},{156,	1.727786009	},{158,	1.746863923	},{160,	1.764605139	},
{162,	1.769577784	}};

////////////////////////////////////////////////////////////////////////////////////
//...аппроксимация потенциалом Муни-Ривлина (второго, третьего, четвертого порядка);
	int N_matr = 4;
	double h1 = 0., h2 = 0., h3 = 0., h4 = 0., sigma = 0., F1, F2, F3, F4, C1, C2, C3, C4, eps, delta, lambda,
		matr[4][4] = {
			{ 0., 0., 0., 0.},
			{ 0., 0., 0., 0.},
			{ 0., 0., 0., 0.},
			{ 0., 0., 0., 0.}
	};

//////////////////////////////////////////////////////////
//...формирование коэффициентов квадратичного функционала;
#define n___ALONGATION___
	for (int i = 0; i < N_muni; i++) {
		//lambda = muni[i][0]; //...исходное - удлинение;
		lambda = 1.+muni[i][0]/100.; //...исходное - деформация в %;
#ifdef ___ALONGATION___
		sigma += sqr(muni[i][1]*lambda);
#else
		sigma += sqr(muni[i][1]);
#endif
		F1 = 2.*(sqr(lambda)-1./lambda);
		F2 = 2.*(lambda-1./sqr(lambda));
		F3 = 2.*(sqr(lambda)+2./lambda-3.)*F1;
		F4 = 2.*(1./sqr(lambda)+2.*lambda-3.)*F2;

		matr[0][0] += F1*F1;
		matr[0][1] += F1*F2;
		matr[0][2] += F1*F3;
		matr[0][3] += F1*F4;
#ifdef ___ALONGATION___
		h1 += F1*muni[i][1]*lambda;
#else
		h1 += F1*muni[i][1];
#endif

		matr[1][0] += F2*F1;
		matr[1][1] += F2*F2;
		matr[1][2] += F2*F3;
		matr[1][3] += F2*F4;
#ifdef ___ALONGATION___
		h2 += F2*muni[i][1]*lambda;
#else
		h2 += F2*muni[i][1];
#endif

		matr[2][0] += F3*F1;
		matr[2][1] += F3*F2;
		matr[2][2] += F3*F3;
		matr[2][3] += F3*F4;
#ifdef ___ALONGATION___
		h3 += F3*muni[i][1]*lambda;
#else
		h3 += F3*muni[i][1];
#endif

		matr[3][0] += F4*F1;
		matr[3][1] += F4*F2;
		matr[3][2] += F4*F3;
		matr[3][3] += F4*F4;
#ifdef ___ALONGATION___
		h4 += F4*muni[i][1]*lambda;
#else
		h4 += F4*muni[i][1];
#endif
	}

/////////////////////////////////////////////////////////////////////////////////
//...формирование коэффициентов квадратичного функционала для потенциала энергии;
	h1 = 0., h2 = 0., h3 = 0., h4 = 0., sigma = 0.,
		matr[0][0] = matr[0][1] = matr[0][2] =	matr[0][3] = 0.,
		matr[1][0] = matr[1][1] = matr[1][2] =	matr[1][3] = 0.,
		matr[2][0] = matr[2][1] = matr[2][2] =	matr[2][3] = 0.,
		matr[3][0] = matr[3][1] = matr[3][2] =	matr[3][3] = 0.;
	for (int i = 0; i < N_muni; i++) {
		//lambda = muni[i][0]; //...исходное - удлинение;
		lambda = 1.+muni[i][0]/100.; //...исходное - деформация в %;
		sigma += sqr(muni[i][1]);
		F1 = (sqr(lambda)+2./lambda-3.);
		F2 = (1./sqr(lambda)+2.*lambda-3.);
		F3 = F1*F1;
		F4 = F2*F2;

		matr[0][0] += F1*F1;
		matr[0][1] += F1*F2;
		matr[0][2] += F1*F3;
		matr[0][3] += F1*F4;
		h1 += F1*muni[i][1];

		matr[1][0] += F2*F1;
		matr[1][1] += F2*F2;
		matr[1][2] += F2*F3;
		matr[1][3] += F2*F4;
		h2 += F2*muni[i][1];

		matr[2][0] += F3*F1;
		matr[2][1] += F3*F2;
		matr[2][2] += F3*F3;
		matr[2][3] += F3*F4;
		h3 += F3*muni[i][1];

		matr[3][0] += F4*F1;
		matr[3][1] += F4*F2;
		matr[3][2] += F4*F3;
		matr[3][3] += F4*F4;
		h4 += F4*muni[i][1];
	}

////////////////////////////////////////////////////////
//...вычисление коэффициентов квадратичного функционала;
	int ii[4] = {0, 0, 0, 0}, kk[4], ll[4], k, l, k0, l0;
	for (int  i = 0; i < N_matr; i++) {
		double f = 0.;
///////////////////////////////////////
//...look for position maximal element;
		for (k = 0; k < N_matr; k++)
			if (ii[k] != 1) 
				for (l = 0; l < N_matr; l++) 
					if (! ii[l]) {
						if (fabs(matr[k][l]) >= f) f = fabs(matr[k0 = k][l0 = l]); 
					}
					else if (ii[l] > 1) {
						break;
					}
		++(ii[l0]);
///////////////////////////////////////////////////////////
//...swapping row for diagonal position of maximal element;
		if (k0 != l0) 
			for (l = 0; l < N_matr; l++) {
				f = matr[k0][l]; matr[k0][l] = matr[l0][l]; matr[l0][l] = f; 
			}
		kk[i] = k0; 
		ll[i] = l0;
		if (matr[l0][l0] == 0.) {
			break;
		}
////////////////////////////////
//...diagonal row normalization;
		double finv = 1./matr[l0][l0]; matr[l0][l0] = 1.;
		for (l = 0; l < N_matr; l++) matr[l0][l] *= finv;
/////////////////////////////////
//...elimination all outher rows;
		for (k = 0; k < N_matr; k++)
			if ( k != l0) {
				finv = matr[k][l0]; matr[k][l0] = 0.;
				for (l = 0; l < 4; l++) matr[k][l] -= matr[l0][l]*finv;
			}
//////////////////////////////////////////////////////////////////////////////////
////...reverse sorting of columns of inverse matrix and memory release and return;
	for (l = N_matr-1; l >= 0; l--)
		if (kk[l] != ll[l])
			for (k = 0; k < N_matr; k++) {
				double f = matr[k][kk[l]]; matr[k][kk[l]] = matr[k][ll[l]]; matr[k][ll[l]] = f;
			}
	}
	//h3 = h4 = 0.;
	C1 = matr[0][0]*h1+matr[0][1]*h2+matr[0][2]*h3+matr[0][3]*h4;
	C2 = matr[1][0]*h1+matr[1][1]*h2+matr[1][2]*h3+matr[1][3]*h4;
	C3 = matr[2][0]*h1+matr[2][1]*h2+matr[2][2]*h3+matr[2][3]*h4;
	C4 = matr[3][0]*h1+matr[3][1]*h2+matr[3][2]*h3+matr[3][3]*h4;
	eps = sigma-h1*C1-h2*C2-h3*C3-h4*C4;
	eps = sqrt(eps);
	delta = eps/sqrt(sigma);

////////////////////////
//...печатаем результат;
	FILE *  result = fopen("Muni-Rivlin_nano-calc4.dat", "w");
	fprintf(result, " C1 = %g\n C2 = %g\n C3 = %g\n C4 = %g\n delta = %g\n ", C1, C2, C3, C4, delta);
	fclose (result);
}
#endif
#ifdef INP_CONVERTOR
{
	//char * name = "c:\\SIMULIA\\Job\\Abaqus\\2015\\Vsevolshskaya_2015\\models\\results\\Variant1 - inject mesh\\Vsevolshskaya.inp";
	char * name = "c:\\SIMULIA\\Job\\Abaqus\\2015\\Vsevolshskaya_2015\\models\\results\\Variant3 - inject big mesh\\Vsevolshskaya.inp";
	int ID_elements[] = {4, -7, -32, -33, -34}, ID_part = 1;

//////////////////////////
//...инициализация задачи;
	CGrid * nd = CreateNodes();

///////////////////////////////////////////////////////
//...чтение модели и граничных условий из файла данных;
	if (nd) {
		sprintf(buf, "Loading model from file '%s'", name);
		Message(" ");
		Message(buf);
		Message("Reading data file ...");

		nd->nodes_inp(name);
		Message("Finish!");
	}
	yes = 0;

////////////////////////////////////
//...добавление в модель новых узлов;
//	int  ID_node_set, ID_element_set;
//	Inp_nodes_add(name, nd, ID_node_set = -13, ID_element_set = -14);

/////////////////////////////////////////
//...добавление в модель новых элементов;
	Inp_elements_add(name, nd, ID_elements, ID_part);

	delete nd;
}
#endif
#ifdef UWay_CONVERTOR
{
	//char * name = "c:\\Users\\Dima\\Programs\\Bcm_all\\Exe\\Testing\\Kashirskoye_add_elements.inp";
	//char * name = "c:\\Users\\Dima\\Programs\\Bcm_all\\Exe\\Testing\\GeoEarth.inp";
	//char * name = "c:\\Users\\Dima\\Programs\\Bcm_all\\Exe\\Testing\\Test_2_plastic_1-1_2.inp";
	char * name = "c:\\Users\\Dima\\Dima\\My_documents\\IAM_RAS\\IAM_RAS_2015\\UWay-convertor_2015\\Testing\\models\\Constru\\copy_small_mesh\\Test_1.inp";
	int ID_part, k = 0;

//////////////////////////
//...инициализация задачи;
	CGrid * nd = CreateNodes();
	yes = 0;

///////////////////////////////////////////////////////
//...чтение модели и граничных условий из файла данных;
	if (nd) {
		sprintf(buf, "Loading model from file '%s'", name);
		Message(" ");
		Message(buf);
		Message("Reading data file ...");

		nd->nodes_inp(name);
		Message("Finish!");
	}

///////////////////////////////////////////////////////////
//...конвертация геометрии и всей задачи из входного файла;
	Convert3D_gmt(name, nd, ID_part = 1);
	Convert3D_prb(name, nd, ID_part);

	delete nd;
}
#endif
#ifdef GRAD_MEDIA_DEMO
{
	//char * name = "./Parametric/Unit2d_4.nas";
	//char * name = "./Parametric/Unit2d_100.nas";
	char * name = "./Parametric/Unit2d_20_20.inp";
	int  i, j, l;

///////////////////////////
//...parameters of problem;
	double K1 = 1.,		//...heat conduction (matrix);
			 K2 = 20.,		//...heat conduction (inclusion);
			 K3 = 0.01,		//...heat conduction (intermediate);
			 //R1 = 0.3/2.,	//...inclusion geometry;
			 //R2 = 0.4/2.;	//...intermediate geometry; 
			 R1 = 0.3/11.,	//...inclusion geometry;
			 R2 = 0.4/11.;	//...intermediate geometry; 
	
//////////////////////////
//...model initialization;
	CDraft<double> * sm = CreateDraftR(HEAT2D_DRAFT);
	sm->set_fasa_hmg(R1, R2, K1, K2, K3);	//...parameters of problem;
	sm->set_mpls(PackInts(7, 7));				//...space degree of multipoles;
	sm->set_quad(PackInts(8, 16));			//...N_elem, N_max -- parameters of quadrature;
	sm->set_normaliz(0.92);						//...normalization coefficient;
	sm->set_lagrange(1e-4);						//...Lagrange coefficient for energy;
	sm->change_solv(PERIODIC_SOLVING);
	sm->solver.change_state(/*EXTERN_STATE*/);
	sm->solver.set_mode(/*REGULARIZATION*//*PRINT_MODE*//*FULLY_MODE*//*| MASKS_MODE | ACCUMULATION*/);
	yes = 0;

//////////////////////////////////
//...reading model from data-file;
	if (sm) {
      sprintf(buf, "Loading model from file '%s'", name);
      Message(" ");
      Message(buf);
      Message("Reading data file ...");

		sm->stru.nodes_in(name);
		sm->bar_condit_in(name);
		sm->LinkUniStruct();
		sm->SetBUniStruct( CLAYER_BLOCK);

		Message("Finish!");
	}

///////////////////////////
//...solving of the probem;
	if (sm->computing_kernel(MAPPING_COMPUT) != OK_STATE) {
		Message("Error in sample computing...");
		delete sm;
		goto err;
	}

//////////////////////////////////
//...печатаем геометрию структуры;
	CGrid * nd = CreateNodes();
	for (i = 0; i < sm->N; i++)
		sm->TestingAll(nd, i, NULL, 1);

	//for (i = 0; i < nd->N; i++) {
	//	nd->X[i] -= 1.5;
	//	nd->Y[i] -= 1.5;
	//	double rr = sqrt(nd->X[i]*nd->X[i]+nd->Y[i]*nd->Y[i]);
	//	nd->X[i] /= sqrt(rr);
	//	nd->Y[i] /= sqrt(rr);
	//}
	nd->grid_out("structure.bln");

	delete nd;
	delete sm;
}
#endif
#ifdef ERROR_FUNCTION_REALIZATION
{
	FILE  * TST = fopen("err_function.dat", "w");
	fprintf(TST, "z,     sum,     F2,    F2-sum,   delta\n");
	for (int i = 0; i <= 3000; i++) {
		int M = 10, k;
		double z = i*.001, hh = 2.*z/sqrt(M_PI), sum = hh, zz = sqr(z),
			dd = -8./3.*(M_PI-3.)/(M_PI-4.), F1 = exp(-zz*(4.+dd*zz)/(M_PI+dd*zz)), F2 = sqrt(1-F1);

		for (k = 1; k <= M; k++) 
			sum += (hh *= (zz = -zz)/k)/(2.*k+1.);
		sum = sum;

		F2 = F2;
		fprintf(TST, "%g,  %g,  %g,  %g,  %g\n", z, sum, F2, F2-sum, 1.-sum/F2);
	}
	fclose(TST);
}
#endif
#ifdef McDonald_FUNCTION_REALIZATION
{
	FILE  * TST = fopen("wo_membrane.dat", "w");
	double R1 = 0., R2 = 1., ww, R0, w0 = 1.737, eps = 1e-14; int k_limit = 500, k = 0;
	do {
		R2 += 1.; k += 1;
		ww = w0_membrane(R2);
	}
	while (ww < w0 && k < k_limit);
	fprintf(TST, "ww = %g, R1 = %g, R2 = %g, w0 = %g, k = %i\n", ww, R1, R2, w0, k);

	k = 0;
	do {
		R0 =.5*(R1+R2); k += 1;
		ww = w0_membrane(R0);
		if (ww <= w0) R1 = R0;
		if (ww >= w0) R2 = R0;
	}
	while (R2-R1 >= eps && k < k_limit);
	R0 = .5*(R1+R2);

	fprintf(TST, "R0 = %g, ww = %g, R1 = %g, R2 = %g, w0 = %g, k = %i\n", R0, ww, R1, R2, w0, k);
	fclose (TST);
}
#endif
#ifdef POTENTIAL_LAME3D_REDECOMPOSITION
{
//////////////////////////
//...model initialization;
	CDraft<double> * sm = CreateDraftR(LAME3D_DRAFT, 8);
	const int n_dim = 1;
	yes = 0;

////////////////////////////////////////////////////////////////////////
//...переразложение сингулярных потенциалов для функций первого порядка;
double TH[21][9] = {
{      -3,       0,       0,       0,       0,       0,       0,       0,      -3 },
{      -0,      -3,      -0,      -0,      -0,      -3,      -0,      -0,      -0 },
{       0,       0,      -9,       0,      -3,       0,      12,       0,       0 },
{      -0,      -0,      -0,    -7.5,      -0,      -0,      -0,     7.5,      -0 },
{    -7.5,       0,       0,       0,       0,       0,       0,       0,     7.5 },
{      -0,   -3.75,      -0,      -0,      -0,   -3.75,      -0,      -0,      -0 },
{       0,       0,   -3.75,       0,    3.75,       0,       0,       0,       0 },
{      -0,      -0,      -0,      -3,      -0,      -0,      -0,      -3,      -0 },
{       0,       0,      -3,       0,      -9,       0,      12,       0,       0 },
{       0,      -3,       0,       0,       0,      -3,       0,       0,       0 },
{    -7.5,       0,       0,       0,       0,       0,       0,       0,     7.5 },
{       0,       0,       0,     7.5,       0,       0,       0,    -7.5,       0 },
{       0,       0,   -3.75,       0,    3.75,       0,       0,       0,       0 },
{       0,    3.75,       0,       0,       0,    3.75,       0,       0,       0 },
{       0,       0,      -3,       0,      -3,       0,       6,       0,       0 },
{      -0,      -0,      -0,      12,      -0,      -0,      -0,      12,      -0 },
{      12,       0,       0,       0,       0,       0,       0,       0,      12 },
{      -0,     7.5,      -0,      -0,      -0,     7.5,      -0,      -0,      -0 },
{       0,       0,     7.5,       0,    -7.5,       0,       0,       0,       0 },
{      -0,      -0,      -0,      -0,      -0,      -0,      -0,      -0,      -0 },
{       0,       0,       0,       0,       0,       0,       0,       0,       0 },
};

///////////////////////////////////////////////////////
//...распределение матриц и переразложение потенциалов;
	int i, j, n = (2*n_dim+1)*3, nn = n+12;
	double ** TT = NULL; set_matrix(TT, nn, n);
	sm->grdivf_forwrd(TT, n_dim);
	sm->toreal_forwrd(TT, n_dim);
	FILE  * TST = fopen("matrix.dat", "w");
	fprintf(TST, "TT[i][j] = {\n");
	for (i = 0; i < nn; i++) {
		fprintf(TST, "{ %7g", TT[i][0]);
		for (j = 1; j < n; j++) fprintf(TST, ", %7g", TT[i][j]);
		fprintf(TST, " }\n");
	}
	fprintf(TST, "}\n");
	fclose (TST);

	delete sm;
}
#endif
#ifdef C3D_CONVERTOR_prev
{
	//char * name = "c:\\Users\\Dima\\Programs\\Bcm_all\\Exe\\C3D_samples\\sample01\\Eb015pi.c3d";
	//char * name = "c:\\Users\\Dima\\Programs\\Bcm_all\\Exe\\C3D_samples\\2ride1.c3d";//2ride2.c3d,2ride3.c3d
	char * name = "c:\\Users\\Dima\\Programs\\Bcm_all\\Exe\\C3D_samples\\ride3.c3d";//ride2.c3d,ride3.c3d
	
	unsigned short num_markers, num_channels, first_field, last_field, start_record_num, frames_per_field, channel_num = 1, marker_num = 1; 
	unsigned char ** mlabels = NULL, ** alabels = NULL, * res_marker = NULL;
	float scale_factor, video_rate, gscale, * ascale = NULL;
	int	* zero_off = NULL, i = 0, j = 0;
	short * val_channel = NULL, ** val_marker = NULL, ** analog = NULL;
	float ** x = NULL, ** y = NULL, ** z = NULL;
	char  ** residual = NULL, ** num_cam = NULL;

/////////////////////////////////////
//...чтение разделов исходного файла;
	FILE * infile = fopen(name, "r+b");
	Read_C3D_Header(&num_markers, &num_channels, &first_field, &last_field, &scale_factor, &start_record_num, &frames_per_field, &video_rate, infile);
	Read_C3D_Parameters (mlabels, alabels, &gscale, ascale, zero_off, infile);

	val_channel = (short *)new_struct(frames_per_field*(last_field-first_field+1)*sizeof(short));
	if (num_channels) {
		Read_C3D_Channel(channel_num+0, num_markers, num_channels, first_field, last_field, start_record_num, frames_per_field, val_channel, infile);
		Read_C3D_Channel(channel_num+1, num_markers, num_channels, first_field, last_field, start_record_num, frames_per_field, val_channel, infile);
		Read_C3D_Channel(channel_num+2, num_markers, num_channels, first_field, last_field, start_record_num, frames_per_field, val_channel, infile);
	}	
	set_matrix(val_marker, last_field-first_field+1, 3);
	res_marker = (unsigned char *)new_struct((last_field-first_field+1)*sizeof(char));
	if (num_markers) {
		Read_C3D_Marker(marker_num+0, num_markers, num_channels, first_field, last_field, start_record_num, frames_per_field, val_marker, res_marker, infile);
		Read_C3D_Marker(marker_num+1, num_markers, num_channels, first_field, last_field, start_record_num, frames_per_field, val_marker, res_marker, infile);
		Read_C3D_Marker(marker_num+2, num_markers, num_channels, first_field, last_field, start_record_num, frames_per_field, val_marker, res_marker, infile);
	}
	set_matrix(x, num_markers, last_field-first_field+1);
	set_matrix(y, num_markers, last_field-first_field+1);
	set_matrix(z, num_markers, last_field-first_field+1);
	set_matrix(residual, num_markers, last_field-first_field+1);
	set_matrix(num_cam,  num_markers, last_field-first_field+1);
	set_matrix(analog, num_channels, (last_field-first_field+1)*frames_per_field);
	Read_C3D_Data_float(num_markers, num_channels, first_field, last_field, start_record_num, frames_per_field,	x, y, z, residual, num_cam, analog, infile);
	fclose(infile); 

	delete_struct(mlabels);
	delete_struct(alabels);
	delete_struct(zero_off);
	delete_struct(val_channel);
	delete_struct(val_marker);
	delete_struct(res_marker);
	delete_struct(x);
	delete_struct(y);
	delete_struct(z);
	delete_struct(residual);
	delete_struct(num_cam);
	delete_struct(analog);
}
#endif
#ifdef C3D_CONVERTOR
{
	//char * name = "c:\\Users\\Dima\\Programs\\Bcm_all\\Exe\\C3D_samples\\rides\\2ride1.c3d";//2ride2.c3d,2ride3.c3d
	char * name = "c:\\Users\\Dima\\Programs\\Bcm_all\\Exe\\C3D_samples\\rides\\ride6.c3d";//ride2.c3d,ride3.c3d
	
	unsigned short num_markers, num_channels, first_field, last_field, start_record_num, frames_per_field; 
	short ** analog = NULL;
	char  ** residual = NULL, ** num_cam = NULL, marker[2000];
	float ** x = NULL, ** y = NULL, ** z = NULL, scale_factor, video_rate;
	double time, P[3]; int k = 0, j;

/////////////////////////////////////////////////////////////////////
//...чтение траекторий из исходного файла и запись их в формате iges;
	FILE * infile = fopen(name, "r+b");
	Read_C3D_Header(&num_markers, &num_channels, &first_field, &last_field, &scale_factor, &start_record_num, &frames_per_field, &video_rate, infile);

	set_matrix(x, num_markers, last_field-first_field+1);
	set_matrix(y, num_markers, last_field-first_field+1);
	set_matrix(z, num_markers, last_field-first_field+1);
	set_matrix(residual, num_markers, last_field-first_field+1);
	set_matrix(num_cam,  num_markers, last_field-first_field+1);
	set_matrix(analog, num_channels, (last_field-first_field+1)*frames_per_field);
	Read_C3D_Data_float(num_markers, num_channels, first_field, last_field, start_record_num, frames_per_field,	x, y, z, residual, num_cam, analog, infile);
	fclose(infile); 

////////////////////////////////////////////////////////////////////////////////////
//...пишем все маркеры в CGrid со своими номерами и конвертируем все маркеры в iges;
	CGrid * marker_nd = CreateNodes();
	FILE	* TST = fopen("Ride6.dat", "w");

	fprintf(TST, "   hit            X              Y              Z              time\n");
	for (k = 0; k < num_markers; k++) if ( k != -1)
	for (j = 0, time = 0.; j <= last_field-first_field; j++, time += 0.003333333333333333333333333) {
		P[0] = x[k][j]*0.001;
		P[1] = y[k][j]*0.001;
		P[2] = z[k][j]*0.001;
		if (sqr(P[0])+sqr(P[1])+sqr(P[2]) > EE) {
			marker_nd->add_new_point(P[0], P[1], P[2], 0., 0., 0.); marker_nd->hit[marker_nd->N-1] = k;
			fprintf(TST, "%7i%15g%15g%15g%15g\n", k, marker_nd->X[j], marker_nd->Y[j], marker_nd->Z[j], time);
		}
	}
	marker_igs("Ride6.igs",  marker_nd);
	fclose(TST);

////////////////////////////////////////////
//...координаты маркеров в начальный момент;
	TST = fopen("marker_num_t90.dat", "w");

	fprintf(TST, "   hit            X              Y              Z\n");
	for (j = 90, k = 0; k < num_markers; k++) {
		P[0] = x[k][j]*0.001;
		P[1] = y[k][j]*0.001;
		P[2] = z[k][j]*0.001;
		if (sqr(P[0])+sqr(P[1])+sqr(P[2]) > EE) {
			fprintf(TST, "%7i%15g%15g%15g\n", k, P[0], P[1], P[2]);
		}
	}
	fclose(TST);

//////////////////////////////////////
//...пишем все маркеры по отдельности;
	//marker_nd->add_buffer(marker_nd->N);
	//for (k = 0; k < num_markers; k++) {
	//	for (j = 0; j <= last_field-first_field; j++) {
	//		P[0] = x[k][j]*0.001;
	//		P[1] = y[k][j]*0.001;
	//		P[2] = z[k][j]*0.001;
	//		if (sqr(P[0])+sqr(P[1])+sqr(P[2]) > EE)
	//			marker_nd->add_new_point(P[0], P[1], P[2], 0., 0., 0.);
	//	}
	//	sprintf  (marker, "marker_%i,igs", k);
	//	track_igs(marker,  marker_nd); marker_nd->add_buffer(marker_nd->N);
	//}
	delete_struct(x);
	delete_struct(y);
	delete_struct(z);
	delete_struct(residual);
	delete_struct(num_cam);
	delete_struct(analog);
	delete_struct(analog);
	delete marker_nd; 
}
#endif
#ifdef IGES_CONVERTOR
{
	//char * name = "c:\\SIMULIA\\Job\\Abaqus\\2015\\Grodnenskaya_2015\\models\\Geo";
	char * name = "c:\\SIMULIA\\Job\\Abaqus\\2015\\Salt_2015\\models\\Geo";
	double X = 0., Y = 0., Z = 0., P[6] = {X, Y, Z, 0., 0., 1.}, k = 0.;

//////////////////////////
//...инициализация задачи;
	CGrid * nd = CreateNodes();
	yes = 0;

///////////////////
//...чтение данных;
	sprintf(buf, "%s\\test.dat", name);
	FILE * TST = fopen(buf, "w");	sprintf(buf, "%s\\data_input.txt", name);
	unsigned long count, upper_limit;
	char * id_DATA = read_struct_ascii(buf);
	user_Count (id_DATA, count = 0, upper_limit, '\x0');

	while (count < upper_limit) {
		if (user_Read (buf, id_DATA, count, upper_limit)) X = user_strtod(buf);
		if (user_Read (buf, id_DATA, count, upper_limit)) Y = user_strtod(buf);

		P[0] = X; P[1] = Y; P[2] = Z;
		nd->add_new_point(P);
		fprintf(TST, "%g, %g, %g\n", P[0], P[1], P[2]);
	}
	fclose(TST);

//////////////////////////////////////////
//...конвертация траектории в формат IGES;
	sprintf(buf, "%s\\data_input.igs", name);	track_igs(buf, nd);
	delete nd;
}
#endif
#ifdef TEST_CCELLS
{
	char * name = "./Models_inp/Box3D_sph/Box3D_sph112.inp";

////////////////////////////////////////////
//...зачитываем геометрию из входного файла;
	CGrid stru;
	stru.nodes_in(name);

//////////////////////////////////////
//...порождаем геометрический элемент;
	CCells * ce = new CCells, * f0 = new CCells;
   //ce->get_nd_bar_directly(& stru, 1);
	//ce->get_sheet(2., 1.);
   //ce->get_ring_segment(0., M_PI*.75, 1., 2.);
   //ce->get_sph_segment(1., 0, M_PI*.75, M_PI*.5, M_PI*.75);
   //ce->get_cyl_segment(1., 0., M_PI*.75, 1., 3.);
   //ce->get_cone_segment(M_PI/12., 0., 8./3.*M_PI*.75, 0., 3.);
   //ce->get_torus_segment(3., 1., -M_PI*.75, M_PI*.75, 0., M_PI*.75);
	//ce->get_sheet_intrusion(2., 1., 0.3);
	//ce->get_sph_intrusion(1.3, 1.);
	ce->get_blend_cyl_segment(2., 1., 3.);
	//f0->get_sheet(2., 1.); double pp[3] = {3., 0., 0.};
	//f0->cells_iso(pp);
	//f0->get_ugolok_cell(2., 2., 1., 1., 0.3, 0.15, 60.);
	//ce->get_beam(f0, 2.);
	ce->segms_id();

	//double pp[] = {1., 2., 0.};
	//ce->cells_iso(pp, M_PI/6., M_PI/3.);

/////////////////////////////////////
//...печатаем геометрический элемент;
	//ce->bar_exc(1);
	ce->cells_out("CCells");

///////////////////////////////////////////////
//...строим поверхнострую сетку или квадратуру;
	CGrid *  nd = CreateNodes(GRID_QG_NODES);
	CGrid * bnd = CreateNodes();
	int N_elem = 20, N_max = 3;

	if (ce->mp) {
		ce->segms_QG(nd, N_elem, N_max);
		bnd->grid_add(nd);
	}
	else
	for (int N_arcs = ce->arcs_number(), i = 0; i < N_arcs; i++) {
		ce->ce[i]->segms_QG(nd, N_elem, N_max);
		bnd->grid_add(nd);
	}
	bnd->TestGrid("grid_X.bln", 0.001, 10., 20., 30., AXIS_X, OK_STATE);
	bnd->TestGrid("grid_Y.bln", 0.0003, 0., 0., 0., AXIS_Y);
	bnd->TestGrid("grid_Z.bln", 0.0003, 0., 0., 0., AXIS_Z);

	delete_cells(ce);
	delete  nd;
	delete bnd;
}
#endif
#ifdef TEST_SHAPES
{
	CShapeMixer<double> * sp = new CShapeMixer<double>;
	sp->add_shape(CreateShape<double>(MP3D_SPHERE_SHAPE));
	//sp->add_shape(CreateShape<double>(SK3D_EXPP_SHAPE));
	//sp->add_shape(CreateShape<double>(SK3D_EXPP_SHAPE, 1));
 
	double kk = 1.2, R0 = 1., eps0 = 5e-5, eps1 = 5e-9, A, B, C, L, f, fo,
			 pp[14], * p_cpy, * p_cpy1, * p_cpy2, * p_cpy3, * p_cpy4, mp[6] = {0., 0., 0., 0., 0., 0.};
	int N = 5, m = 1, dim = 1;

	sp->init1(N, m, dim);
	sp->init_potential();
	sp->set_shape(R0, kk);
	sp->set_local(mp);

/////////////////////////////////////////
//...визуализация поверхности мультиполя;
	double bound[5] = {-1.5, 1.5, -1.5, 1.5, 0.};
	//double bound[5] = {0., M_PI, -M_PI, M_PI, kk};
	sp->A[0][4] = 0.26788;
	sp->GetSurferFormat("shapes_out", bound, AXIS_Y);

//////////////////////////////////////////////////////////
//...проверка дифференциальных и интегральных соотношений;
	FILE * TST = fopen("multipoles_test", "w");
	p_cpy  = (double *)new_struct(sp->NN*sizeof(double));
	p_cpy1 = (double *)new_struct(sp->NN*sizeof(double));
	p_cpy2 = (double *)new_struct(sp->NN*sizeof(double));
	p_cpy3 = (double *)new_struct(sp->NN*sizeof(double));
	p_cpy4 = (double *)new_struct(sp->NN*sizeof(double));

	L = 0.1; 
	A = 1.2; 
	B = 1.5; 
	C = 1.6;
	for (int k = 0; k < 1/*4*/; k++)
	for (int i = 0; i < 1/*4*/; i++)
	for (int j = 0; j < 1/*4*/; j++) {
		fprintf(TST, "test_%i%i%i : ", k, i, j);
		pp[0]  = pp[7] = A + L*k;
		pp[1]  = pp[8] = B + L*i;
		pp[2]  = pp[9] = C + L*j;
		pp[3]  = 1.;
		pp[4]  = 2.;
		pp[5]  = 3.;
		pp[10] = (pp[3] *= (f = 1./sqrt(pp[3]*pp[3]+pp[4]*pp[4]+pp[5]*pp[5])));
		pp[11] = (pp[4] *=  f);
		pp[12] = (pp[5] *=  f);
		pp[13] =  pp[6] = 0.1;//...задание времени;
		fprintf(TST, "X = %g, Y = %g, Z = %g\n",  pp[0], pp[1], pp[2]);
		fprintf(TST, "normal = (%g, %g, %g)\n\n", pp[3], pp[4], pp[5]);
	
////////////////////////
//...проверка градиента;
//*		
		fprintf(TST, "градиент:\n");
		sp->parametrization_hess(pp);
		sp->deriv_N();
		sp->cpy(sp->p_cpy, p_cpy);

		pp[7] += pp[3]*eps1;
		pp[8] += pp[4]*eps1;
		pp[9] += pp[5]*eps1;
		sp->parametrization_hess(pp+7);
		pp[7] -= pp[3]*eps1;
		pp[8] -= pp[4]*eps1;
		pp[9] -= pp[5]*eps1;

		for (int l = 0; l < sp->NN; l++) {
			f = (sp->p_cpy[l]-p_cpy[l])/eps1;
			if (TST) fprintf(TST, "Df-deriv = %g  Df[%d] = %g\n", sp->deriv[l]-f, l, sp->deriv[l]);

  			if (fabs(sp->deriv[l]-f) > 100.*eps1)
			printf("Df-deriv = %g  l = %d\n", sp->deriv[l]-f, l);
		}
		fprintf(TST, "\n");/**/

/////////////////////////////////
//...проверка второй производной;
//*		
		fprintf(TST, "Dxx:\n");
		sp->parametrization_hess(pp);
		sp->admittance(p_cpy,  NULL, 0., 0.);
		sp->adm_xx(p_cpy, 1.);

		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy3, sp->p_cpy, 0., 1.); 
		pp[7] -= eps0;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy1, sp->p_cpy, 0., -1.); 
		sp->admittance(p_cpy1, p_cpy3, 1., 1.);
		sp->admittance(p_cpy1, NULL, 1./eps0, 0.);
		pp[7] += eps0*2.;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy2, sp->p_cpy, 0., 1.);
		sp->admittance(p_cpy2, p_cpy3, 1., -1.);
		sp->admittance(p_cpy2, NULL, 1./eps0, 0.);
		pp[7] -= eps0;

		sp->admittance(p_cpy2, p_cpy1, 1., -1.);
		sp->admittance(p_cpy2, NULL, 1./eps0, 0.);

		for (int l = 0; l < sp->NN; l++) {
			f = p_cpy[l]-p_cpy2[l];
			if (TST) fprintf(TST, "Dxx(f)-deriv = %g  Dxx(f)[%d] = %g\n", f, l, p_cpy[l]);

			if (fabs(f) > eps0)
			printf("Dxx(f) = %g  l = %d\n", f, l);
		}
		fprintf(TST, "\n");/**/

/////////////////////////////////
//...проверка второй производной;
//*		
		fprintf(TST, "Dyy:\n");
		sp->parametrization_hess(pp);
		sp->admittance(p_cpy,  NULL, 0., 0.);
		sp->adm_yy(p_cpy, 1.);

		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy3, sp->p_cpy, 0., 1.); 
		pp[8] -= eps0;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy1, sp->p_cpy, 0., -1.); 
		sp->admittance(p_cpy1, p_cpy3, 1., 1.);
		sp->admittance(p_cpy1, NULL, 1./eps0, 0.);
		pp[8] += eps0*2.;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy2, sp->p_cpy, 0., 1.);
		sp->admittance(p_cpy2, p_cpy3, 1., -1.);
		sp->admittance(p_cpy2, NULL, 1./eps0, 0.);
		pp[8] -= eps0;

		sp->admittance(p_cpy2, p_cpy1, 1., -1.);
		sp->admittance(p_cpy2, NULL, 1./eps0, 0.);

		for (int l = 0; l < sp->NN; l++) {
			f = p_cpy[l]-p_cpy2[l];
			if (TST) fprintf(TST, "Dyy(f)-deriv = %g  Dyy(f)[%d] = %g\n", f, l, p_cpy[l]);

			if (fabs(f) > eps0)
			printf("Dyy(f) = %g  l = %d\n", f, l);
		}
		fprintf(TST, "\n");/**/

/////////////////////////////////
//...проверка второй производной;
//*		
		fprintf(TST, "Dzz:\n");
		sp->parametrization_hess(pp);
		sp->admittance(p_cpy,  NULL, 0., 0.);
		sp->adm_zz(p_cpy, 1.);

		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy3, sp->p_cpy, 0., 1.); 
		pp[9] -= eps0;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy1, sp->p_cpy, 0., -1.); 
		sp->admittance(p_cpy1, p_cpy3, 1., 1.);
		sp->admittance(p_cpy1, NULL, 1./eps0, 0.);
		pp[9] += eps0*2.;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy2, sp->p_cpy, 0., 1.);
		sp->admittance(p_cpy2, p_cpy3, 1., -1.);
		sp->admittance(p_cpy2, NULL, 1./eps0, 0.);
		pp[9] -= eps0;

		sp->admittance(p_cpy2, p_cpy1, 1., -1.);
		sp->admittance(p_cpy2, NULL, 1./eps0, 0.);

		for (int l = 0; l < sp->NN; l++) {
			f = p_cpy[l]-p_cpy2[l];
			if (TST) fprintf(TST, "Dzz(f)-deriv = %g  Dzz(f)[%d] = %g\n", f, l, p_cpy[l]);

			if (fabs(f) > eps0)
			printf("Dzz(f) = %g  l = %d\n", f, l);
		}
		fprintf(TST, "\n");/**/

/////////////////////////////////
//...проверка второй производной;
//*		
		fprintf(TST, "Dxy:\n");
		sp->parametrization_hess(pp);
		sp->admittance(p_cpy,  NULL, 0., 0.);
		sp->adm_xy(p_cpy, 1.);

		sp->cpy_xy();//...смешанная производная; 
		sp->admittance(sp->deriv, NULL, 0., 0.);	
		sp->deriv_Z(sp->deriv); 
		sp->cpy_xy(); 

		pp[8] -= eps0;
		pp[7] -= eps0;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy1, sp->p_cpy, 0., -1.); 
		pp[7] += eps0*2.;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy1, sp->p_cpy, 1., 1.);
		sp->admittance(p_cpy1, NULL, .5/eps0, 0.);
		pp[7] -= eps0;
		pp[8] += eps0*2.;
		pp[7] -= eps0;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy2, sp->p_cpy, 0., -1.); 
		pp[7] += eps0*2.;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy2, sp->p_cpy, 1., 1.);
		sp->admittance(p_cpy2, NULL, .5/eps0, 0.);
		pp[7] -= eps0;
		pp[8] -= eps0;

		sp->admittance(p_cpy2, p_cpy1, 1., -1.);
		sp->admittance(p_cpy2, NULL, .5/eps0, 0.);

		for (int l = 0; l < sp->NN; l++) {
			f = p_cpy[l]-p_cpy2[l];
			if (TST) fprintf(TST, "Dxy(f)-deriv = %g  Dxy(f)[%d] = %g\n", f, l, p_cpy[l]);

			if (fabs(f) > eps0)
			printf("Dxy(f) = %g  l = %d\n", f, l);
		}
		fprintf(TST, "\n");/**/

/////////////////////////////////
//...проверка второй производной;
//*		
		fprintf(TST, "Dxz:\n");
		sp->parametrization_hess(pp);
		sp->admittance(p_cpy,  NULL, 0., 0.);
		sp->adm_xz(p_cpy, 1.);

		pp[9] -= eps0;
		pp[7] -= eps0;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy1, sp->p_cpy, 0., -1.); 
		pp[7] += eps0*2.;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy1, sp->p_cpy, 1., 1.);
		sp->admittance(p_cpy1, NULL, .5/eps0, 0.);
		pp[7] -= eps0;
		pp[9] += eps0*2.;
		pp[7] -= eps0;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy2, sp->p_cpy, 0., -1.); 
		pp[7] += eps0*2.;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy2, sp->p_cpy, 1., 1.);
		sp->admittance(p_cpy2, NULL, .5/eps0, 0.);
		pp[7] -= eps0;
		pp[9] -= eps0;

		sp->admittance(p_cpy2, p_cpy1, 1., -1.);
		sp->admittance(p_cpy2, NULL, .5/eps0, 0.);

		for (int l = 0; l < sp->NN; l++) {
			f = p_cpy[l]-p_cpy2[l];
			if (TST) fprintf(TST, "Dxz(f)-deriv = %g  Dxz(f)[%d] = %g\n", f, l, p_cpy[l]);

			if (fabs(f) > eps0)
			printf("Dxz(f) = %g  l = %d\n", f, l);
		}
		fprintf(TST, "\n");/**/

/////////////////////////////////
//...проверка второй производной;
//*		
		fprintf(TST, "Dyz:\n");
		sp->parametrization_hess(pp);
		sp->admittance(p_cpy,  NULL, 0., 0.);
		sp->adm_yz(p_cpy, 1.);

		sp->cpy_yz();//...смешанная производная; 
		sp->admittance(sp->deriv, NULL, 0., 0.);	
		sp->deriv_X(sp->deriv); 
		sp->cpy_yz(); 

		pp[9] -= eps0;
		pp[8] -= eps0;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy1, sp->p_cpy, 0., -1.); 
		pp[8] += eps0*2.;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy1, sp->p_cpy, 1., 1.);
		sp->admittance(p_cpy1, NULL, .5/eps0, 0.);
		pp[8] -= eps0;
		pp[9] += eps0*2.;
		pp[8] -= eps0;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy2, sp->p_cpy, 0., -1.); 
		pp[8] += eps0*2.;
		sp->parametrization_hess(pp+7);
		sp->admittance(p_cpy2, sp->p_cpy, 1., 1.);
		sp->admittance(p_cpy2, NULL, .5/eps0, 0.);
		pp[8] -= eps0;
		pp[9] -= eps0;

		sp->admittance(p_cpy2, p_cpy1, 1., -1.);
		sp->admittance(p_cpy2, NULL, .5/eps0, 0.);

		for (int l = 0; l < sp->NN; l++) {
			f = p_cpy[l]-p_cpy2[l];
			if (TST) fprintf(TST, "Dyz(f)-deriv = %g  Dyz(f)[%d] = %g\n", f, l, p_cpy[l]);

			if (fabs(f) > eps0)
			printf("Dyz(f) = %g  l = %d\n", f, l);
		}
		fprintf(TST, "\n");/**/	
	
	}
	if (TST) fclose(TST);

	delete_struct(p_cpy);
	delete_struct(p_cpy1);
	delete_struct(p_cpy2);
	delete_struct(p_cpy3);
	delete_struct(p_cpy4);
 
	delete_shapes(sp);
}
#endif
#ifdef TEST_DRAFT_ALL
{
	//const char * name = "../Exe/Box2d_homog/heat_clayer488.nas";
	//const char * name = "../Exe/Box2d_homog/sph_025_16.nas";
	//const char * name = "../Exe/Box2d_homog/ell_80_20_i_1980.nas";
	const char * name = "../Exe/Box2d_homog/ell_80_20q2.nas";

//////////////////////////
//...инициализация модели;
	CDraft<double> * sm = CreateDraftR(LAME2D_DRAFT);
	sm->set_mpls(PackInts(2, 2)); //...степень мультиполей;
	sm->set_quad(PackInts(8, 8)); //...степень квадратуры;
	sm->set_normaliz(0.92);			//...нормирующий множитель;
	sm->set_lagrange(1e4);			//...коэффициент Лагранжа; 
	sm->change_solv(PERIODIC_SOLVING);
	sm->solver.change_state(EXTERN_STATE);
	sm->solver.set_mode(REGUL_BOUNDARY/*PRINT_MODE*//*FULLY_MODE*/);
	yes = 0;

//////////////////////
//...параметры задачи;
	//double K1 = 1.7, //...оксид циркония (matrtix);
	//		 K2 = 30.,	 //...корунд (inclusion);
	//		 K3 = 3.;	 //...промежуточный слой;
	//sm->set_fasa_hmg(K1, K2, K3);
	double nj1 = 0.33, //...полимерная матрица; 
			 nj2 = 0.20, //...графитовое включение; 
			 nj3 = 0.30, //...межфазный слой; 
			 E1  = 18.,  //...GPa;
			 E2  = 380., //...GPa; 
			 E3  = 57.5; 
	sm->set_fasa_hmg(nj1, nj2, nj3, E1/(1.+nj1)*.5, E2/(1.+nj2)*.5, E3/(1.+nj3)*.5);

///////////////////////////////////////////////////////
//...чтение модели и граничных условий из файла данных;
	int id_reading = 0, m;
	double X0, Y0, ell_X = 0., ell_Y = 0., rot_Z = 0.;
	if (sm) {
		sprintf(buf, "Loading model from file '%s'", name);
		Message(" ");
		Message(buf);
		Message("Reading data file ...");

		sm->stru.nodes_in(name);
      sm->bar_condit_in(name);
		sm->LinkUniStruct();
		sm->SetBUniStruct(POLY_BLOCK);

		if (sm->id_prop && sm->pp_cond)//...reading parameters of inclusion;
		for (int j = 0; j < sm->id_prop[0]; j++)
		if (sm->id_prop[j*2+2] == BSOURCE_BND) {
			X0		= sm->pp_cond[j*6]; 
			Y0		= sm->pp_cond[j*6+1];
			ell_X = sm->pp_cond[j*6+2];
			ell_Y = sm->pp_cond[j*6+3];
			rot_Z = sm->pp_cond[j*6+4];
			id_reading = 1;
			break;
		}
		Message("Finish!");
	}
	double par[6];	sm->SetGeomBounding(par);
	if (! id_reading) {
		X0 = (par[0]+par[1])*.5;
		Y0 = (par[2]+par[3])*.5;
		ell_X = 0.80;
		ell_Y = 0.20;
		rot_Z = 0.;
	}
	if (ell_X != 0. && ell_Y != 0.) {
		CCells * ce = new(CCells);
		ce->cells_new(1, 2, (m = size_of_map(1, CYL_GENUS))+1);
		ce->mp[0] = (CMap)ID_MAP(1, CYL_GENUS);
		ce->mp[1] = X0;
		ce->mp[2] = Y0;
		ce->mp[4] = rot_Z/180.*M_PI;
		ce->mp[7] = ell_X;
		ce->mp[8] = ell_Y;
		ce->mp[m] = (CMap)NULL_CELL;
		sm->bar = new(CCells);
		sm->bar->bar_add(ce);
	}

////////////////////
//...решение задачи;
	if (sm->computing_kernel(MAPPING_COMPUT) != OK_STATE) {
		Message("Error in sample computing...");
		delete sm;
		goto err;
	}
#ifdef ___MPI_INIT___
	if (sm->solver.id_change == EXTERN_STATE) {
		CSlvParam params;
		params.msglev = 3;
		params.ittype = 2;
		params.sttype = 1;
		params.niter = 700;
		params.eps = 1.0e-9;

		params.tau1 = 1.0e-2;
		params.tau2 = 1.0e-3;
		params.theta = 0.10e0;

		char strbuff[256];
		sprintf (strbuff,"%s%i%s","BsSolver_",comm_mpi.GetMyid(),".dat");

		std::ofstream fout (strbuff);

		sm->shapes_init(NO_STATE); 
		BCM_draft<double> pBCM = {sm, MAPPING_COMPUT};
		//AbstractSolver		(& pBCM, 
		AbstractParSolver (& pBCM, 
								(void *)&comm_mpi,
								fout, params,
								Number_of_Blocks<double>, Blocks_Partitioning<double>, 
								Blocks_Sparsity<double>, Blocks_Row<double>, 
								Right_Handside<double>, Initial_Guess<double>, Store_Solution<double>);
		sm->shapes_init(OK_STATE); 
	}
#endif	

//////////////////////////////////////////////////////////////////
//...;
#ifdef ___MPI_INIT___
	if (comm_mpi.GetMyid() == 0) 
#endif
	{
//////////////////
//..visualization;
		res = system("mkdir ./bcm_results/test3_results");
		//res = system("del *.grd");
		int id_visual = 1;
		if (id_visual) {
			CGrid * nd = CreateNodes();
			sm->BlockActivate(NULL_STATE);

			int NX = 200, NY = 200;
			for (int i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (int j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

			int hit = ERR_STATE;
			for (int i = 0; i < nd->N;  i++)
			for (int j = 0; j < nd->N1; j++) {
				sm->Poly_struc_in2D (hit, nd->X[i], nd->Y[j]);
				sm->StructEllCorrect(hit, nd->X[i], nd->Y[j]);

				nd->hit[i+j*nd->N] = hit;
			}
			//sm->GetSurferFormat("./bcm_results/test3_results/rr", nd,        HEAT_VALUE, 0);
			//sm->GetSurferFormat("./bcm_results/test3_results/pp", nd, FLUX_COMPOS_VALUE, 0);
			sm->GetSurferFormat("./bcm_results/test3_results/bb", nd,       ERR_VALUE, 0);
			sm->GetSurferFormat("./bcm_results/test3_results/rx", nd,     DISPL_VALUE, 0);
			sm->GetSurferFormat("./bcm_results/test3_results/tx", nd,  STRESS_X_VALUE, 0);

			delete nd;
		}
	}
	delete sm;
}
#endif
#ifdef TEST_DRAFT_VISCO
{
	//char * name_ini = "./Models_inp/Box2D_sph/sph_009_84.inp";
	//char * name_ini = "./Models_inp/Box2D_sph/sph_009_172.inp";
	//char * name_ini = "./Models_inp/Box2D_sph/sph_009_184.inp";
	char * name_ini = "./Models_inp/Box2D_sph/sph_009_496.inp";

	//char * name_ini = "./Box2d_homog/sph_025_16.nas";

//////////////////////
//...параметры задачи;
	double E1 = 6.0,	//...ледяная матрица(GPa); 
			 E2 = 50.,	//...минеральная частица (песок, GPa); 
			 nju1 = 0.3,//...матрица;
			 nju2 = 0.3,//...включение; 
			 G1   = E1/(1.+nju1)*.5,
			 G2   = E2/(1.+nju2)*.5,
			 K1   = E1/(3.-6.*nju1),
			 K2   = E2/(3.-6.*nju2),
			 AA   = E1*0.0, //...нормальный  адгезионный модуль (GPa);
			 BB   = G1*0.0, //...касательный адгезионный модуль (GPa);
			 d0   = 0.,   //...доля адгезионной комплексности;
			 l1   = 0.06, //...касательный масштабный параметр;
			 l2   = 0.06, //...дополнительный масштабный параметр;
			 d1   = 0.0,  //...доля потерь (комплексность) в матрице;
			 d2   = 0.;   //...доля потерь (комплексность) во включении;

//////////////////////////
//...инициализация модели;
	CDraft<complex> * sm = CreateDraftC(VISCO2D_GRAD_DRAFT);
	sm->set_fasa_hmg(K1, K2, G1, G2, l1, l2, d1, d2, AA, BB, d0);
	sm->set_mpls(PackInts(1, 1)); //...степень мультиполей;
	sm->set_quad(PackInts(4, 2)); //...степень квадратуры;
	sm->set_normaliz(0.92);			  //...нормирующий множитель;
	sm->set_lagrange(1e4);			  //...коэффициент Лагранжа; 
	sm->change_solv(E_PERIODIC_SOLVING);
	sm->solver.change_state(/*EXTERN_STATE*/);
	sm->solver.set_mode(/*REGULARIZATION*//*PRINT_MODE*//*FULLY_MODE*/);
	yes = 0;

///////////////////////////////////////////////////////
//...чтение модели и граничных условий из файла данных;
	double X0, Y0, ell_X = 0., ell_Y = 0., rot_Z = 0.;
	int  id_reading = 0;
	if (sm) {
		sprintf(buf, "Loading model from file '%s'", name_ini);
		Message(" ");
		Message(buf);
		Message("Reading data file ...");

		sm->stru.nodes_in(name_ini);
      sm->bar_condit_in(name_ini);
		sm->LinkUniStruct();
		sm->SetBUniStruct(POLY_BLOCK);

		if (sm->id_prop && sm->pp_cond)//...reading parameters of inclusion;
		for (int j = 0; j < sm->id_prop[0]; j++)
		if (sm->id_prop[j*2+2] == BSOURCE_BND) {
			X0		= sm->pp_cond[j*6]; 
			Y0		= sm->pp_cond[j*6+1];
			ell_X = sm->pp_cond[j*6+2];
			ell_Y = sm->pp_cond[j*6+3];
			rot_Z = sm->pp_cond[j*6+4];
			id_reading = 1;
			break;
		}
		if (ell_X != 0. && ell_Y != 0.) {
			CCells * ce = new(CCells); int l;
			ce->cells_new(1, 2, (l = size_of_map(1, CYL_GENUS))+1);
			ce->mp[0] = (CMap)ID_MAP(1, CYL_GENUS);
			ce->mp[1] = X0;
			ce->mp[2] = Y0;
			ce->mp[4] = rot_Z/180.*M_PI;
			ce->mp[7] = ell_X;
			ce->mp[8] = ell_Y;
			ce->mp[l] = (CMap)NULL_CELL;
			sm->bar = new(CCells);
			sm->bar->bar_add(ce);
		}
		Message("Finish!");
	}

////////////////////
//...решение задачи;
	if (sm->computing_kernel(MAPPING_COMPUT) != OK_STATE) {
		Message("Error in sample computing...");
		delete sm;
		goto err;
	}

//////////////////
//..visualization;
	CGrid * nd = CreateNodes();
	{
		double par[6], E0, nu, mu, C0, lm, ff_vol; sm->SetGeomBounding(par);
		complex K[12]; memset(K, 0, 12*sizeof(complex));
		sm->GetRigidy(K);

		C0 = to_double((K[0]-2.*K[2]*K[5]/(K[5]+K[3]))/(K[3]-2.*K[5]*K[5]/(K[5]+K[3])));
		lm = to_double((K[2]-C0*K[5])/(K[5]+K[3]));
		E0 = to_double((C0-lm)*(C0+2.*lm)/(C0+lm));
		nu = to_double(lm/(C0+lm));
		mu = to_double(K[7]/(K[10]*2.));
		ff_vol = M_PI*ell_X*ell_Y/((par[1]-par[0])*(par[3]-par[2]));

		FILE  * TST = fopen("box2D_ell_homog.dat", "a");
		fprintf(TST, "ff_vol = %g  E0 = %g  mu = %g  nu = %g (%g, %g, %g, %g, %g, %g, %g)\n", 						 
						  ff_vol, E0, mu, nu, ell_X, ell_Y, rot_Z, E1, E2, nju1, nju2);
		fclose (TST);

		int id_visual = 1;
		if (id_visual) {//..visualization;
			nd->zero_grid(); 

			sm->BlockActivate(NULL_STATE);

			int NX = 100, NY = 100;
			for (int i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (int j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

			int hit = ERR_STATE;
			for (int i = 0; i < nd->N;  i++)
			for (int j = 0; j < nd->N1; j++) {
				sm->Poly_struc_in2D(hit, nd->X[i], nd->Y[j]);
				sm->StructEllCorrect(hit, nd->X[i], nd->Y[j]);
				nd->hit[i+j*nd->N] = hit;
			}
			system("del *.grd");

			sm->GetSurferFormat("bb", nd,       ERR_VALUE, 0);
			sm->GetSurferFormat("rx", nd,     DISPL_VALUE, 0);
			sm->GetSurferFormat("ry", nd,     DISPL_VALUE, 1);
			sm->GetSurferFormat("tx", nd,  STRESS_X_VALUE, 0);
		}
	}
	delete sm;
	delete nd;
}
#endif
#ifdef TEST_DRAFT_HYDRO
{
	//const char * name = "./Parametric/Unit3d_008.nas";
	//const char * name = "./Models_inp/Box3D_sph/Box3D_sph112.inp";

	//const char * name = "./Models_nas/Bench/hydro/bench_02_450.nas";
	//const char * name = "./Models_nas/Bench/hydro/zet_02_600.nas";
	
	//const char * name = "./Seepage/Flow_R30_octa_M44.inp";
	const char * name = "./Seepage/Flow_R30_full_M288.inp";
	//const char * name = "./Seepage/Flow_R30_full_M432.inp";
	//const char * name = "./Seepage/Filtr_R65_full_M96.inp";
	//const char * name = "./Seepage/Filtr_R65_full_M432.inp";

	double par[6], k0 = 3., L = 0.5, rad = 0.3, layer = 0.0, eps_in = 1e-2;
	int i, j, k, m, num; 

//////////////////////////
//...инициализация модели;
#define real_T dd_real
	CDraft<real_T> * sm = CreateDraftD(HYDRO3D_DRAFT, 8);		
	sm->set_mpls(PackInts(3, 3)); //...степень мультиполей;
	sm->set_quad(PackInts(4, 4)); //...степень квадратуры;
	sm->set_normaliz(1.*L*sqrt(3.)/(.5*rad));	//...нормирующий множитель;
	sm->set_geometry(rad);			//...радиус сферического включения; 
	sm->set_lagrange(1e5);			//...коэффициент Лагранжа; 
	sm->set_fasa_hmg(k0);			//...коэффициент Бринкмана; 
	sm->change_solv(PERIODIC_SOLVING);
	sm->solver.change_state(/*EXTERN_STATE*/);
	sm->solver.set_mode(/*PRINT_MODE*/);
	yes = 0;

//////////////////////////////////////////////////////////////////////////////////////////
//...чтение модели и граничных условий из файла данных или задание геометрии аналитически;
	int id_analyt = 1;
	if (sm && ! id_analyt) {
		Message(" ");
		sprintf(buf, "Loading model from file '%s'", name);
		Message(buf);
		Message("Reading data file ...");

		sm->stru.nodes_in(name);
      sm->bar_condit_in(name);
		sm->LinkUniStruct();
		sm->SetBUniStruct(POLY_BLOCK);
		sm->SetGeomBounding(par);

		Message("Finish!");
	}
	else 
	if (id_analyt) {//...задание геометрии аналитически;
		if (rad < 0.5)
		sm->GetSphBoxStruct(2.*L, 2.*L, 2.*L, rad, layer, OK_STATE); else
		sm->GetPenetrateSphere(rad, L); 
		sm->set_geometry(rad, layer);
		if (layer == 0.) sm->SetBUniStruct( CLAYER_BLOCK, ERR_GENUS);
		else				  sm->SetBUniStruct(1, POLY_BLOCK, ERR_GENUS);
		par[0] = -L; par[2] = -L; par[4] = -L;
		par[1] =  L; par[3] =  L; par[5] =  L;
	}

//////////////////////////////////////////////////
//...устанавливаем граничные поверхности в модели;
	if (! id_analyt && 0) {
		double eps = 1e-6;
		sm->BlockActivate();
		sm->add_sph_surface(-rad, -L,  L, L);
		sm->add_sph_surface(-rad,  L,  L, L);
		sm->add_sph_surface(-rad,  L, -L, L);
		sm->add_sph_surface(-rad, -L, -L, L);
		for (k = 0; k < sm->N; k++) 
		LOOP_FACET(sm->B[k].bar, i, m) 
		if (sm->B[k].link[i+1] <= ERR_STATE && SRF_STATE < sm->B[k].link[i+1] && sm->bar && sm->bar->graph) {
			int N_arc, arc, prev = sm->B[k].bar->ce[i]->graph[(N_arc = sm->B[k].bar->ce[i]->graph[1])+1], m1, m2;
			for (j = 1, num = ERR_STATE; j <= N_arc; j++, prev = arc) if (num == ERR_STATE) {
				arc = sm->B[k].bar->ce[i]->graph[j+1];
				m1  = get_num(sm->B[k].bar->ce[i]->ce[arc]->graph, 0),
				m2  = get_num(sm->B[k].bar->ce[i]->ce[arc]->graph, 1);
				if (! sm->B[k].bar->ce[i]->ce[prev]->topo_id(m1)) swap(m1, m2);

				if (sm->B[k].bar->ce[i]->ce[m1]->mp[1] < L-eps && sm->B[k].bar->ce[i]->ce[m1]->mp[1] > -L+eps &&
					 sm->B[k].bar->ce[i]->ce[m1]->mp[2] < L-eps && sm->B[k].bar->ce[i]->ce[m1]->mp[2] > -L+eps &&
					 sm->B[k].bar->ce[i]->ce[m1]->mp[3] < L-eps && sm->B[k].bar->ce[i]->ce[m1]->mp[3] > eps) {
					if (sm->B[k].bar->ce[i]->ce[m1]->mp[1] < -eps && sm->B[k].bar->ce[i]->ce[m1]->mp[2] >  eps) num = 0; else
					if (sm->B[k].bar->ce[i]->ce[m1]->mp[1] >  eps && sm->B[k].bar->ce[i]->ce[m1]->mp[2] >  eps) num = 1; else
					if (sm->B[k].bar->ce[i]->ce[m1]->mp[1] >  eps && sm->B[k].bar->ce[i]->ce[m1]->mp[2] < -eps) num = 2; else
					if (sm->B[k].bar->ce[i]->ce[m1]->mp[1] < -eps && sm->B[k].bar->ce[i]->ce[m1]->mp[2] < -eps) num = 3;
				}
			}
			if (num != ERR_STATE) sm->B[k].link[i+1] = SRF_STATE-num;
		}
	}

////////////////////////////////////////////////////////////////////////////////////
//...задание граничных значений в модели (периодичность забивает граничные значения);
	int id_action = 0;
	if (id_action) {
		double po[6] = { 0., 0., 0., 0., 0., 0.};
		sm->BlockActivate();
		for (k = 0; k < sm->N; k++) 
		LOOP_FACET(sm->B[k].bar, num, m) {
			sm->B[k].bar->SetFacetXParam(num, par[0], po, ADHESION_BND);
			sm->B[k].bar->SetFacetXParam(num, par[1], po, ADHESION_BND);

			sm->B[k].bar->SetFacetYParam(num, par[2], po, ADHESION_BND);
			sm->B[k].bar->SetFacetYParam(num, par[3], po, ADHESION_BND);

			sm->B[k].bar->SetFacetZParam(num, par[4], po, SPECIAL_BND);
			sm->B[k].bar->SetFacetZParam(num, par[5], po, SPECIAL_BND);
		}
	}
	res = system("mkdir./bcm_results/hydro3d_homog");

////////////////////////////
//...solving of the problem;
	if (sm->computing_kernel(PERIOD_COMPUT) != OK_STATE) {
		Message("Error in sample computing...");
		if (sm) delete sm;
		goto err;
	}

////////////////////////////////////////////////////////////////
//..вычисляем осредненные характеристики (тензор проницаемости);
		double nn, nn_cyl, nn_l, ff_vol, AX = 1., AY = 1., AZ = 1.;
		real_T K[4]; memset(K, 0, 4*sizeof(real_T));
		sm->GetRigidy(K, -1,  BASIC_COMPUT); 	

		ff_vol = to_double(K[3])/(AX*AY*AZ);
		if (AX*.5 > rad)
		ff_vol = 1.-4./3.*M_PI*rad/AX*rad/AY*rad/AZ; else
		ff_vol = 1.-2.*M_PI*(3.*rad/AY*rad/AZ*.5-.125-4./3.*rad/AX*rad/AY*rad/AZ);
		
		nn = to_double(K[2])/(AX*AY*AZ);
		nn_cyl = sm->TakeCylinder(ff_vol);
		nn_l	 = sm->TakeLayer	 (ff_vol);

		FILE * TST = fopen("./bcm_results/hydro3d_homog/hydro3d_homog.dat", "a");
		if (TST) fprintf(TST, "ff_vol = %g  nn = %g  nn_cyl = %g  nn_l = %g  (AX = %g  AY = %g  k0 = %g)\n", ff_vol, nn, nn_cyl, nn_l, AX, AY, k0);
		if (TST) fclose (TST);

//////////////////
//..visualization;
	{
		int id_visual = 1;
		if (id_visual) {
			//res = system("del *.grd");
			CGrid * nd = CreateNodes();
			int NX = 200, NY = 200, axis;

			sm->BlockActivate();

#ifdef ___LONGITUDINAL_SECTIOM___
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->add_new_point_Z((par[5]+par[4])*.5);
			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

			for (i = 0; i < nd->N;  i++)
			for (j = 0; j < nd->N1; j++) {
				int hit = -1;
				sm->Poly_struc_in3D (hit, nd->X[i], nd->Y[j], nd->Z[0], eps_in);
				nd->hit[i+j*nd->N] = hit;
			}
			axis = AXIS_Z;
#else
			if (1) {
				for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
				for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);

				nd->add_new_point_Z((par[3]+par[2])*.5);
				nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

				for (i = 0; i < nd->N;  i++)
				for (j = 0; j < nd->N1; j++) {
					int hit = -1;
					sm->Poly_struc_in3D (hit, nd->Y[j], nd->Z[0], nd->X[i], eps_in);
					nd->hit[i+j*nd->N] = hit;
				}
				axis = AXIS_Y;
			}
			else {
				for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
				for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);

				nd->add_new_point_Z((par[1]+par[0])*.5);
				nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

				for (i = 0; i < nd->N;  i++)
				for (j = 0; j < nd->N1; j++) {
					int hit = -1;
					sm->Poly_struc_in3D (hit, nd->Z[0], nd->X[i], nd->Y[j], eps_in);
					nd->hit[i+j*nd->N] = hit;
				}
				axis = AXIS_X;
			}
#endif
//////////////////////////////////////
//...коррекция сферического включения;
			for (i = 0; i < nd->N;  i++)
			for (j = 0; j < nd->N1; j++) {
				if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad)) nd->hit[i+j*nd->N] = -1; else
				if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad+layer)) nd->hit[i+j*nd->N] = 1/*1*/; 
				else nd->hit[i+j*nd->N] = 0/*0*/;
/*				if (sqr(nd->X[i]+L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]-L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
				if (sqr(nd->X[i]-L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]-L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
				if (sqr(nd->X[i]-L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]-L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
				if (sqr(nd->X[i]+L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]-L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
				if (sqr(nd->X[i]+L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]+L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
				if (sqr(nd->X[i]-L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]+L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
				if (sqr(nd->X[i]-L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]+L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
				if (sqr(nd->X[i]+L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]+L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
	*/		}
			//sm->GetSurferFormat("./bcm_results/hydro3d_homog/bb", nd,	     ERR_VALUE, 0, axis); 
			sm->GetSurferFormat("./bcm_results/hydro3d_homog/pp", nd,	PRESSURE_VALUE, 0, axis);
			sm->GetSurferFormat("./bcm_results/hydro3d_homog/vv", nd, VELOCITY_VALUE, 0, axis);
			//sm->GetSurferFormat("./bcm_results/hydro3d_homog/nn", nd, NORMAL_R_VALUE, 0, axis);
			//sm->GetSurferFormat("./bcm_results/hydro3d_homog/nz", nd, NORMAL_Z_VALUE, 0, axis);

			nd->zero_grid();
			
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->add_new_point_Z((par[5]+par[4])*.5);
			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

			for (i = 0; i < nd->N;  i++)
			for (j = 0; j < nd->N1; j++) {
				int hit = -1;
				sm->Poly_struc_in3D (hit, nd->X[i], nd->Y[j], nd->Z[0], eps_in);
				nd->hit[i+j*nd->N] = hit;
			}
			axis = AXIS_Z;

////////////////////////////////////////////////
//...повторная коррекция сферического включения;
			for (i = 0; i < nd->N;  i++)
			for (j = 0; j < nd->N1; j++) {
				if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad)) nd->hit[i+j*nd->N] = -1; else
				if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad+layer)) nd->hit[i+j*nd->N] = 1/*1*/; 
				else nd->hit[i+j*nd->N] = 0/*0*/;
				//if (sqr(nd->X[i]+L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]-L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
				//if (sqr(nd->X[i]-L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]-L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
				//if (sqr(nd->X[i]-L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]-L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
				//if (sqr(nd->X[i]+L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]-L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
				//if (sqr(nd->X[i]+L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]+L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
				//if (sqr(nd->X[i]-L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]+L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
				//if (sqr(nd->X[i]-L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]+L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
				//if (sqr(nd->X[i]+L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]+L) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
			}
			//sm->GetSurferFormat("./bcm_results/hydro3d_homog/bb_I", nd,	    ERR_VALUE, 0, axis);
			sm->GetSurferFormat("./bcm_results/hydro3d_homog/pp_I", nd, PRESSURE_VALUE, 0, axis);
			sm->GetSurferFormat("./bcm_results/hydro3d_homog/vv_I", nd, VELOCITY_VALUE, 0, axis);

			delete nd;
		}
	}
	delete sm;
#undef real_T
}
#endif
#ifdef TEST_DRAFT_VIBRO
{
//	char * name = "Models_nas/Cylinder/cyl_cyl_40.nas";
//	char * name = "Models_nas/Acoustic/ono_box_56.nas";
//	char * name = "Models_nas/Acoustic/ono_box_140.nas";
//	char * name = "Models_nas/Acoustic/ono_box_172.nas";
//	char * name = "Models_nas/Acoustic/ono_box_320.nas";
//	char * name = "Models_nas/Acoustic/ono_box_412.nas";

//	char * name = "Models_nas/Acoustic/ono_half_14.nas";
//	char * name = "Models_nas/Acoustic/ono_half_35.nas";
//	char * name = "Models_nas/Acoustic/ono_half_43.nas";
//	char * name = "Models_nas/Acoustic/ono_half_80.nas";
	char * name = "Models_nas/Acoustic/ono_half_103.nas";
//	char * name = "Models_nas/Acoustic/ono_half_243.nas";
//	char * name = "Models_nas/Acoustic/ono_half_349.nas";

//	char * name = "Models_nas/Acoustic/ono0half_4.nas";
//	char * name = "Models_nas/Acoustic/ono0half_16.nas";
//	char * name = "Models_nas/Acoustic/ono0half_20.nas";
//	char * name = "Models_nas/Acoustic/ono0half_42.nas";
//	char * name = "Models_nas/Acoustic/ono0half_120.nas";

	int  i, j, k, l, N0, NN[] = {3, 1, 1, 1}, id_phase = OK_STATE;
	double  par[6], LL[] = {1.2, 1.3, 2.5};//...//...указываются возрастающие значения точек;

///////////////////////////`
//...parameters of problem;
	double Hz  = 200.,   //...frequency;
			 Ro0 = 1.225,  //...air density (\EA\E3/\EC^3); 
			 C0  = 340.,   //...air velocity (\EC/\F1\E5\EA);
			 Ro1 = 9.8e3,  //...steel density (\EA\E3/\EC^3);
			 nj1 = 0.30,   //...steel Poisson; 
			 G1  = 2.04e10/(1.+nj1)*.5; //...steel modulus (\EA\C3/\EC^2);

/////////////////////////////////////////////////////////
//...инициализация образца и настройка параметров задачи;
	CDraft<double> * sm = CreateDraftR(ACOU3D_DRAFT, 8);		
	if (sm->type() == ACOU3D_DRAFT) sm->set_fasa_hmg(Hz, Ro0, C0);
	else 									  sm->set_fasa_hmg(Hz, Ro0, C0, Ro1, nj1, G1);
	sm->set_mpls(PackInts(3, 1)); //...степень мультиполей;
	sm->set_quad(PackInts(4, 4)); //...степень квадратуры;
	sm->set_normaliz(.92);			//...нормирующий множитель;
	sm->set_lagrange(1e5);			//...множитель Лагранжа для функционала энергии;
	sm->change_solv(/*PERIODIC_SOLVING*/SQUARE_SOLVING);
	sm->solver.change_state(/*EXTERN_STATE*/);
	sm->solver.set_mode(/*PRINT_MODE*/NO_PHASE);

	sm->set_param(2, 100.);

////////////////////////////
//...преобразование образца;
	CGrid * nd = CreateNodes();

	N0 = sm->GetOnoBoxStruct(1.2, 1.0, 0.5, 0.5, 0.08, NN, LL, name, OK_STATE, id_phase);
	//sm->B[0].bar->cells_out("bar");

	for (k = 0; k < sm->N; k++) {
		if (sm->B[k].link[1] < 0) sm->B[k].type = POLY_BLOCK; else //ELLI_BLOCK; else //SPECIAL_BND_BLOCK; else //
										  sm->B[k].type = POLY_BLOCK;//ELLI_BLOCK;//
		if (sm->B[k].link[2] < 0) sm->B[k].type = ELLI_BLOCK;//POLY_BLOCK;//SPECIAL_BND_BLOCK;//
	}
	par[0] = 0.0; par[2] = 0.0; par[4] = 0.;
	par[1] = 0.6; par[3] = 0.5; par[5] = LL[NN[0]-1];

//////////////////////////////////////////
//...коррекция граничных значений вручную;
	if (1) {
		double pp[6] = { 0., 0., 0., 0., 0., 0.};
		for (k = 0; k < sm->N; k++)
		for (int num = 0; num < sm->B[k].bar->graph[0]; num++) 
		if  (sm->B[k].bar->ce[num]->cells_dim() == 2 && sm->B[k].bar->ce[num]->mp && sm->B[k].bar->ce[num]->graph && 
			  sm->B[k].bar->ce[num]->mp[l = size_of_map (sm->B[k].bar->ce[num]->mp)] == FACET_CELL && 
			  sm->B[k].bar->ce[num]->mp[l+1] > 0. && sm->B[k].bar->ce[num]->graph[1] > 2) {
			if (sm->B[k].link[sm->NUM_PHASE] == -2) {
				sm->B[k].bar->SetFacetXParam(num, par[0], pp, FSKEWS_BND);
				sm->B[k].bar->SetFacetXParam(num, par[1], pp, FSKEWS_BND);

				sm->B[k].bar->SetFacetYParam(num, par[2], pp, FSKEWS_BND);
				sm->B[k].bar->SetFacetYParam(num, par[3], pp, FSKEWS_BND);
			}
		}
	}

//////////////////////////
//...распечатка геометрии;
	for (k = 0; k < sm->N;  k++) {
	sm->B[k].bar->cells_out("bar");
	sm->B[k].bar->grid_skeleton(nd);
	}
	nd->grid_out("beam_bars25_blocks.bln", 0., 0., 0., AXIS_Z);
	nd->zero_grid();

////////////////////////////
//...solving of the problem;
	if (sm->computing_kernel(BASIC_COMPUT) != OK_STATE) {
		Message("Error in sample computing...");
		if (sm) delete sm;
		goto err;
	}
#ifdef ___MPI_INIT___
	if (sm->solver.id_change == EXTERN_STATE) {
		CSlvParam params;
		params.ordtype = 1;
		params.tau1 = 1.0e-2;
		params.tau2 = 1.0e-4;
		params.theta = 0.10e0;
		params.niter = 200;
		params.eps = 1.0e-12;

		params.memory = 10.0e0;
		params.msglev = 3;

		params.ittype = 2;
		params.sttype = 1;

		std::ofstream fout ("BsSolver.dat");

		sm->shapes_init(NO_STATE); 
		BCM_draft<double> pBCM = {sm, MAPPING_COMPUT};
		//AbstractSolver		(& pBCM, 
		AbstractParSolver (& pBCM, 
								(void *)&comm_mpi,
								fout, params,
								Number_of_Blocks<complex>, Blocks_Partitioning<complex>, 
								Blocks_Sparsity<complex>, Blocks_Row<complex>, 
								Right_Handside<complex>, Initial_Guess<complex>, Store_Solution<complex>);
		sm->shapes_init(OK_STATE); 
	}
#endif
//	sm->block_descrap("Descrapency.sta");

//////////////////
//..visualization;
#ifdef ___MPI_INIT___
	if (comm_mpi.GetMyid() == 0) 
#endif
	{
		int id_visual = 1, id_symm = 1;
		if (id_visual) {
			int NX = 100, NY = 100, axis;
			nd->zero_grid();

#ifdef ___LONGITUDINAL_SECTIOM___ 
			if (id_symm) {
				((par[1] -= par[0]) *= 2.) += par[0]; 
				((par[3] -= par[2]) *= 2.) += par[2]; 
			}
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->add_new_point_Z((par[5]+par[4])*.5);
			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
			if (id_symm) {
				for (((par[1] -= par[0]) /= 2.) += par[0], i = NX; i <= 2*NX; i++) nd->X[i] = 2.*(par[1]+par[0])-nd->X[i];
				for (((par[3] -= par[2]) /= 2.) += par[2], j = NY; j <= 2*NY; j++) nd->Y[j] = 2.*(par[3]+par[2])-nd->Y[j];
			}
			sm->hit_beam_struct(nd, N0, NN, LL, axis = AXIS_Z);
#else
			if (1) {
				if (id_symm) 
					((par[1] -= par[0]) *= 2.) += par[0]; 
				for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
				for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);

				nd->add_new_point_Z(par[3]);
				nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

				if (id_symm) 
					for (((par[1] -= par[0]) /= 2.) += par[0], j = NY+1; j <= 2*NY; j++) nd->Y[j] = 2.*(par[1]+par[0])-nd->Y[j];
				sm->hit_beam_struct(nd, N0, NN, LL, axis = AXIS_Y);
			}
			else {
				if (id_symm) 
					((par[3] -= par[2]) *= 2.) += par[2]; 
				for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
				for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);

				nd->add_new_point_Z((par[1]+par[0])*.5);
				nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

				if (id_symm)
					for (((par[3] -= par[2]) /= 2.) += par[2], i = NX+1; i <= 2*NX; i++) nd->X[i] = 2.*(par[3]+par[2])-nd->X[i];
				sm->hit_beam_struct(nd, N0, NN, LL, axis = AXIS_X);
			}
#endif
			system("del *.grd");
			sm->GetSurferFormat("bb",  nd,	 ERR_VALUE, 0, axis, id_symm ? SPECIAL_STATE : NULL_STATE);
			sm->GetSurferFormat("pp",  nd,	 SPL_VALUE, 0, axis, id_symm ? SPECIAL_STATE : NULL_STATE);
//			sm->GetSurferFormat("pz",  nd,  PRESS_VALUE, 0, axis, id_symm ? SPECIAL_STATE : NULL_STATE);
//			sm->GetSurferFormat("vz",  nd, FLUX_Z_VALUE, 0, axis, id_symm ? SPECIAL_STATE : NULL_STATE);
//			sm->GetSurferFormat("ppp", nd,    SPL_ANALYT_ABSORB_VALUE, 0, axis, id_symm ? SPECIAL_STATE : NULL_STATE);
//			sm->GetSurferFormat("ppz", nd,  PRESS_ANALYT_ABSORB_VALUE, 0, axis, id_symm ? SPECIAL_STATE : NULL_STATE);
//			sm->GetSurferFormat("vvz", nd, FLUX_Z_ANALYT_ABSORB_VALUE, 0, axis, id_symm ? SPECIAL_STATE : NULL_STATE);
		}
		int id_action = 1;
		if (id_action) {
			int NX = 40, NY = 40;

			nd->zero_grid();
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->add_new_point_Z(LL[0]);
			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

			nd->Z[0] -= 0.001;
			sm->hit_beam_struct(nd, N0, NN, LL, AXIS_Z);
			nd->Z[0] += 0.001;

			FILE * TST = fopen("resi_L1.dat", "w");
			double out_F[3], sum[3], eps = 1e-12;
			for (i = 0; i < nd->N;  i++)
			for (j = 0; j < nd->N1; j++) {
				sm->GetFuncAllValues (nd->X[i], nd->Y[j], nd->Z[0], sum,   nd->hit[i+j*nd->N],	 PRESSURE_VALUE, 0);
				sm->GetFuncAllValues (nd->X[i], nd->Y[j], nd->Z[0], out_F, nd->hit[i+j*nd->N]+N0, PRESSURE_VALUE, 0);
				fprintf(TST, " %i  %g  %g  (norm = %g)", i, 
					filtr_(out_F[0]-sum[0], eps), filtr_(out_F[1]-sum[1], eps), 
					sqrt(sqr(sum[0])+sqr(sum[1])));

				sm->GetFuncAllValues (nd->X[i], nd->Y[j], nd->Z[0], sum,   nd->hit[i+j*nd->N],	 FLUX_Z_VALUE, 0);
				sm->GetFuncAllValues (nd->X[i], nd->Y[j], nd->Z[0], out_F, nd->hit[i+j*nd->N]+N0, FLUX_Z_VALUE, 0);
				fprintf(TST, "    %g  %g  (norm = %g)\n", 
					filtr_(out_F[0]-sum[0], eps), filtr_(out_F[1]-sum[1], eps), 
					sqrt(sqr(sum[0])+sqr(sum[1])));
			}
			fclose(TST);

			nd->zero_grid();
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->add_new_point_Z(LL[1]);
			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

			nd->Z[0] -= 0.001;
			sm->hit_beam_struct(nd, N0, NN, LL, AXIS_Z);
			nd->Z[0] += 0.001;

			TST = fopen("resi_L2.dat", "w");
			for (i = 0; i < nd->N;  i++)
			for (j = 0; j < nd->N1; j++) {
				sm->GetFuncAllValues (nd->X[i], nd->Y[j], nd->Z[0], sum,   nd->hit[i+j*nd->N],	 PRESSURE_VALUE, 0);
				sm->GetFuncAllValues (nd->X[i], nd->Y[j], nd->Z[0], out_F, nd->hit[i+j*nd->N]+N0, PRESSURE_VALUE, 0);
				fprintf(TST, " %i  %g  %g  (norm = %g)", i, 
					filtr_(out_F[0]-sum[0], eps), filtr_(out_F[1]-sum[1], eps), 
					sqrt(sqr(sum[0])+sqr(sum[1])));

				sm->GetFuncAllValues (nd->X[i], nd->Y[j], nd->Z[0], sum,   nd->hit[i+j*nd->N],	 FLUX_Z_VALUE, 0);
				sm->GetFuncAllValues (nd->X[i], nd->Y[j], nd->Z[0], out_F, nd->hit[i+j*nd->N]+N0, FLUX_Z_VALUE, 0);
				fprintf(TST, "    %g  %g  (norm = %g)\n", 
					filtr_(out_F[0]-sum[0], eps), filtr_(out_F[1]-sum[1], eps), 
					sqrt(sqr(sum[0])+sqr(sum[1])));
			}
			fclose(TST);
		}
	}
	delete sm;
	delete nd;
}
#endif
#ifdef HEAT2D_ANALYT_HOMOGENIZATION
{
	int	 id_visual = 0,  NX = 100, NY = 100, N0 = 11, N_elem = 16, N_max = 4, i, j, axis = AXIS_Y;
	double A = 1., B = 1., R1 = 0.3/2, R2 = 0.4/2, K1 = 20., K2 = 0.01, K3 = 1., C = 1., alpha = 0.;

//////////////////////////////////
//...reading model from data-file;
   sprintf(buf, "Reading data...");
   Message(" ");
   Message(buf);

	unsigned long count, upper_limit;
	char        * id_DATA = read_struct_ascii("heat2d_initial.dat");
	if         (! id_DATA) {
		sprintf(buf, "Data not found..");
		Message(" ");
		Message(buf);
		sprintf(buf, "Creating data file \"heat2d_initial.dat\"...");
		Message(buf);
		Message(" ");

		FILE  * TST = fopen("heat2d_initial.dat", "w");
		fprintf(TST, "N = %i\nN_elem = %i\nN_max = %i\n\n", N0, N_elem, N_max);
		fprintf(TST, "id_visual = %i\nNX = %i\nNY = %i\naxis = %i\nalpha = %g\n\n", id_visual, NX, NY, axis, alpha);
		fprintf(TST, "A = %g\nB = %g\nC = %g\nR1 = %g\nR2 = %g\nK1 = %g\nK2 = %g\nK3 = %g\n", A, B, C, R1, R2, K1, K2, K3);
		fclose (TST);

		printf("N  = %i\nN_elem = %i\nN_max = %i\n\n", N0, N_elem, N_max);
		printf("id_visual = %i\nNX = %i\nNY = %i\naxis  = %i\nalpha = %g\n\n", id_visual, NX, NY, axis, alpha);
		printf("A = %g\nB = %g\nC = %g\nR1 = %g\nR2 = %g\nK1 = %g\nK2 = %g\nK3 = %g\n", A, B, C, R1, R2, K1, K2, K3);

		goto test;
	}
	user_Count    (id_DATA, 0, upper_limit, '\x0');
	if (user_Count(id_DATA, count = 0, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) N0 = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) N_elem = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) N_max = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) id_visual = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) NX = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) NY = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) axis = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) alpha = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) A = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) B = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) C = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) R1 = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) R2 = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) K1 = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) K2 = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) K3 = user_strtod(buf);

///////////////////////////////////////
//...creating model from initiual data;
test:
	CDraft<double> * sm = CreateDraftR(HEAT2D_DRAFT);
	sm->set_fasa_hmg(R1, R2, K3, K1, K2);
	sm->set_mpls(PackInts(N0, N0));			//...space degree of multipoles;
	sm->set_quad(PackInts(N_elem, N_max)); //...N_elem, N_max -- parameters of quadrature;
	sm->set_normaliz(0.92);						//...normalization coefficient;
	sm->change_solv(SPECIAL_SOLVING);
	sm->solver.change_state(/*EXTERN_STATE*/);
	sm->solver.set_mode(/*PRINT_MODE*//* | FULLY_MODE*/);
	//yes = 0;

// for (int k = 2; k <= 50; k++) {
//	R1 = R2*(k-1.)/k;
	if (sm) {
      sprintf(buf, "Loading model...");
      Message(" ");
      Message(buf);

		sm->stru.add_new_point(-A*.5, B*.5, 0., 0., 0., 1.); sm->stru.hit[0] = 1;
		sm->stru.add_new_point(-A*.5,-B*.5, 0., 0., 0., 1.); sm->stru.hit[1] = 2;
		sm->stru.add_new_point( A*.5,-B*.5, 0., 0., 0., 1.); sm->stru.hit[2] = 3;
		sm->stru.add_new_point( A*.5, B*.5, 0., 0., 0., 1.); sm->stru.hit[3] = 4;
		sm->stru.geom = (int *)new_struct(10*sizeof(int));
		sm->stru.geom[0] = 1;
		sm->stru.geom[1] = GL_QUADS;
		sm->stru.geom[2] = 7;
		sm->stru.geom[3] = -1;
		sm->stru.geom[4] = -1;
		sm->stru.geom[5] = -1;
		sm->stru.geom[6] = 0;
		sm->stru.geom[7] = 1;
		sm->stru.geom[8] = 2;
		sm->stru.geom[9] = 3;
		sm->stru.geom_ptr = (int *)new_struct(3*sizeof(int));
		sm->stru.geom_ptr[0] = 1;
		sm->stru.geom_ptr[1] = 10;
		sm->stru.cond = (int *)new_struct(2*sizeof(int));
		sm->stru.cond_ptr = (int *)new_struct(2*sizeof(int));
		sm->stru.cond_ptr[0] = 1;

		sm->LinkUniStruct();
		sm->SetBUniStruct(CLAYER_BLOCK);
		Message("Finish!");
	}

///////////////////////////
//...solving of the probem;
	if (sm->computing_kernel(PERIOD_COMPUT) != OK_STATE) {
		Message("Error in sample computing...");
		delete sm;
		goto err;
	}

//////////////////
//..visualization;
#ifdef ___MPI_INIT___
	if (comm_mpi.GetMyid() == 0) 
#endif
	{
		double par[6];	sm->SetGeomBounding(par);
		double K[6] = {0.,0.,0.,0.,0., min(A, min(B, C))*.5}, KH, kk, kk_low, kk_max, ff_vol, ff_l;

		sm->set_param(sm->NUM_QUAD, PackInts(N_elem, 2*N_max));

		sm->GetRigidy(K, -1, BASIC_COMPUT);
		sm->GetRigidy(K, -1, COVERING_COMPUT);

		ff_vol = K[3]/(K[2]+K[3]+K[4]);
		ff_l	 = K[4]/(K[2]+K[3]+K[4]);
		kk		 = K[0]/(K[2]+K[3]+K[4]);
		kk_low = (K[2]+K[3]+K[4])/(K[2]/K3+K[3]/K1+K[4]/K2);
		kk_max = (K[2]*K3+K[3]*K1+K[4]*K2)/(K[2]+K[3]+K[4]);

		KH = sm->TakeEshelby(ff_vol, ff_l);

		FILE * TST = fopen("heat2d_homog.dat", "a");
		if (TST) fprintf(TST, "kk = %g  KH = %g  1-KH/kk = %g  ff_vol = %g  kk_max = %g  K1 = %g  K2 = %g  K3 = %g  R1 = %g  R2 = %g\n", 
									  kk, KH, 1.-KH/kk, ff_vol, kk_max, K1, K2, K3, R1, R2);
		if (TST) fclose (TST);

		if (id_visual) {//..visualization;
			CGrid * nd = CreateNodes();
			sm->BlockActivate(NULL_STATE);

			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
			system("del *.grd");

			sm->GetSurferFormat("rr", nd,			 HEAT_VALUE, 0);
			sm->GetSurferFormat("pp", nd, FLUX_COMPOS_VALUE, 0);

			delete nd;
		}
	}
// }
	delete sm;
}
#endif
#ifdef HEAT3D_ANALYT_HOMOGENIZATION
{
	double par[6], rad = 0.3, h_rad = 0., A = 1., B = 1., C = 1.,  ll = 0.1, section = 0., section_I = 0., section_II = 0., 
		 K1 = 20., K2 = 0.01, K3 = 1.;
	int id_visual = 0, N_rad = 1, NX = 100, NY = 100, N0 = 15, N_elem = 8, N_max = 4, id_bcond = 0, id_solver = 0, id_type = 0, 
		 axis = AXIS_Y, axis_I = AXIS_Z, axis_II = AXIS_X, i, j, l;

//////////////////////////////////
//...reading model from data-file;
   sprintf(buf, "Reading data...");
   Message(" ");
   Message(buf);

	unsigned long count, upper_limit;
	char        * id_DATA = read_struct_ascii("heat3d_initial.dat");
	if         (! id_DATA) {
		sprintf(buf, "Data not found..");
		Message(" ");
		Message(buf);
		sprintf(buf, "Creating data file \"heat3d_initial.dat\"...");
		Message(buf);
		Message(" ");

		FILE  * TST = fopen("heat3d_initial.dat", "w");
		fprintf(TST, "N = %i\nN_elem = %i\nN_max = %i\n\n", N0, N_elem, N_max);
		fprintf(TST, "id_bcond = %i  id_solver = %i  id_type = %i\n\n", id_bcond, id_solver, id_type);
		fprintf(TST, "id_visual = %i\nNX = %i\nNY = %i\naxis = %i  axis_I = %i  axis_II = %i\nsection = %g  section_I = %g  section_II = %g\n\n", 
			id_visual, NX, NY, axis, axis_I, axis_II, section, section_I, section_II);
		fprintf(TST, "A = %g\nB = %g\nC = %g\nrad = %g  layer = %g  h_rad = %g  N_rad = %i\n\n", A, B, C, rad, ll, h_rad, N_rad);
		fprintf(TST, "K1 = %g\nK2 = %g\nK3 = %g\n", K1, K2, K3);
		fclose (TST);

		printf("N = %i\nN_elem = %i\nN_max = %i\n\n", N0, N_elem, N_max);
		printf("id_bcond = %i  id_solver = %i  id_type = %i\n\n", id_bcond, id_solver, id_type);
		printf("id_visual = %i\nNX = %i\nNY = %i\naxis = %i  axis_I = %i  axis_II = %i\nsection = %g  section_I = %g  section_II = %g\n\n", 
			id_visual, NX, NY, axis, axis_I, axis_II, section, section_I, section_II);
		printf("A = %g\nB = %g\nC = %g\nrad = %g  layer = %g  h_rad = %g  N_rad = %i\n\n", A, B, C, rad, ll, h_rad, N_rad);
		printf("K1 = %g\nK2 = %g\nK3 = %g\n", K1, K2, K3);

		goto test;
	}
	user_Count    (id_DATA, 0, upper_limit, '\x0');
	if (user_Count(id_DATA, count = 0, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) N0 = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) N_elem = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) N_max = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) id_bcond = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) id_solver = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) id_type = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) id_visual = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) NX = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) NY = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) axis = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) axis_I = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) axis_II = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) section = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) section_I = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) section_II = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) A = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) B = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) C = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) rad = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) ll = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) h_rad = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) N_rad = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) K2 = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) K3 = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) K1 = user_strtod(buf);

///////////////////////////////////////
//...creating model from initiual data;
test:
	CDraft<double> * sm = CreateDraftR(HEAT3D_DRAFT, 7);
	sm->set_mpls(PackInts(N0, N0));			//...space degree of multipoles;
	sm->set_quad(PackInts(N_elem, N_max)); //...N_elem, N_max -- parameters of quadrature;
	sm->set_normaliz(0.92);						//...normalization coefficient;
	sm->change_solv(PERIODIC_SOLVING/*SPECIAL_SOLVING*/);
	sm->solver.change_state(/*EXTERN_STATE*/);
	sm->solver.set_mode(/*PRINT_MODE*//*FULLY_MODE*/);
	//yes = 0;

////////////////////////////////////////////////////////
//...перебираем все радиусы, отключая предельные случаи;
	for (l = 0; l < N_rad; l++, rad += h_rad) { 
		sprintf(buf, "rad = %g", rad);
		Message(" ");
		Message(buf);

////////////////////////////////////////////////////////////////////////////////
//...пересчет параметров ячейки для обеспечения одинаковой концентрации шунгита;
		if (id_type == 1) A = B = C = pow(300.*M_PI,  1./3.)*(rad+10.)*.5;                                                                    //
		if (id_type == 2) A = B = C = pow(300.*M_PI,  1./3.)*pow(rad*sqr(rad)+((rad+ll)*sqr(rad+ll)-rad*sqr(rad))*(K3-K1)/(K2-K1), 1./3.)*.5; //                                          //
		if (id_type == 3) {
			A = B = C = pow(200.*M_PI/3.,  1./3.)*rad;
			if (rad > 100) ll = 1.54*12.5*pow(100./(1.54*12.5), 2.*(3.-2.568)/3.); 
			else 				ll = 1.54*12.5*pow( rad/(1.54*12.5), 2.*(3.-2.568)/3.);
		}
		if (rad > 0. && rad <= 0.5*A) {

///////////////////////////////////////////
//...задаем геометрию и исходные параметры;
			double fL = A, fL2 = fL*fL;
			A /= fL; rad /= fL;
			B /= fL;	ll  /= fL;
			C /= fL;
			if (id_bcond) sm->GetSphBoxStruct(A, B, C, rad, ll);
			else {
				sm->GetSphBoxStruct(A, B, C);
				sm->SetBUniStruct(CLAYER_BLOCK, ERR_GENUS);
			}
			par[0] = -A*.5; par[2] = -B*.5; par[4] = -C*.5;
			par[1] =  A*.5; par[3] =  B*.5; par[5] =  C*.5;
			sm->set_fasa_hmg (rad, rad+ll, K1, K2, K3);


///////////////////////////  
//...solving of the probem;
			if (sm->computing_kernel(PERIOD_COMPUT) != OK_STATE) {
				Message("Error in sample computing...");
				delete sm;
				goto err;
			}

//////////////////////////////////////////
//..вычисляем эффективные модули композита;
			double K[7] = {0.,0.,0.,0.,0.,0., min(A, min(B, C))*.5}, KH, kk, kk_low, kk_max, ff_vol, ll_vol;
			sm->GetRigidy(K, -1, BASIC_COMPUT);
			sm->GetRigidy(K, -1, COVERING_COMPUT);

			ff_vol =  K[4]/(K[3]+K[4]+K[5]);
			ll_vol =  K[5]/(K[3]+K[4]+K[5]);
			kk		 =  K[2]/(K[3]+K[4]+K[5]);
			kk_low = (K[3]+K[4]+K[5])/(K[3]/K1+K[4]/K2+K[5]/K3);
			kk_max = (K[3]*K1+K[4]*K2+K[5]*K3)/(K[3]+K[4]+K[5]);

////////////////////////////////////////
//...четырехфазная модель, метод Эшелби;
			KH = sm->TakeEshelby(ff_vol, ll_vol);

			const char  * buf = id_type ? (id_type == 1 ? "heat3d_homog_kf1.dat" : (id_type == 2 ? "heat3d_homog_kf2.dat" : "heat3d_homog_kf3.dat")) : "heat3D_homog_kf0.dat";
			const char  * bf1 = id_type ? (id_type == 1 ? "heat3d_homg1_kf1.dat" : (id_type == 2 ? "heat3d_homg1_kf2.dat" : "heat3d_homg1_kf3.dat")) : "heat3D_homg1_kf0.dat";
			const char  * bf2 = id_type ? (id_type == 1 ? "heat3d_homg2_kf1.dat" : (id_type == 2 ? "heat3d_homg2_kf2.dat" : "heat3d_homg2_kf3.dat")) : "heat3D_homg2_kf0.dat";
			FILE  * TST = fopen(id_bcond == 1 ? bf1 : (id_bcond == 2 ? bf2 : buf), "a");
			fprintf(TST, "rad = %g  A = %g  kk = %g  KH = %g  1-KH/kk = %g  kk_max = %g  kk_low = %g  ff_vol = %g  ll_vol = %g  (%g, %g, %g) (N = %i)\n", 
						rad*fL, A*fL, kk, KH, 1.-KH/kk, kk_max, kk_low, ff_vol, ll_vol, K2, K3, K1, N0);
			fclose (TST);

//////////////////
//..visualization;
			if (id_visual) { //..visualization;
				CGrid * nd = CreateNodes();
				if (axis == AXIS_Z) {
					for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
					for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

					nd->add_new_point_Z(par[4]+(par[5]-par[4])*(1.+section)*.5);
					nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
				}
				if (axis == AXIS_Y) {
					for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
					for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);

					nd->add_new_point_Z(par[2]+(par[3]-par[2])*(1.+section)*.5);
					nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
				}
				if (axis == AXIS_X) {
					for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
					for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);

					nd->add_new_point_Z(par[0]+(par[1]-par[0])*(1.+section)*.5);
					nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
				}
				for (i = 0; i < nd->N;  i++)
				for (j = 0; j < nd->N1; j++)
				if (rad == 0. || ! id_bcond) nd->hit[i+j*nd->N] = 0;	else
				if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad))    nd->hit[i+j*nd->N] = 0; else  
				if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad+ll)) nd->hit[i+j*nd->N] = 2; else	nd->hit[i+j*nd->N] = 1;	

				system("del *.grd");
				sm->GetSurferFormat("rr", nd,				  HEAT_VALUE,							 0, axis);
				sm->GetSurferFormat("pp", nd, id_bcond ? FLUX_VALUE : FLUX_COMPOS_VALUE, 0, axis);

/////////////////////////////////////////
//...дополнительные сечения (если нужно);
				if (id_visual > 1) { 
					nd->zero_grid();
					if (axis_I == AXIS_Z) {
						for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
						for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

						nd->add_new_point_Z(par[4]+(par[5]-par[4])*(1.+section_I)*.5);
						nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
					}
					if (axis_I == AXIS_Y) {
						for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
						for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);

						nd->add_new_point_Z(par[2]+(par[3]-par[2])*(1.+section_I)*.5);
						nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
					}
					if (axis_I == AXIS_X) {
						for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
						for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);

						nd->add_new_point_Z(par[0]+(par[1]-par[0])*(1.+section_I)*.5);
						nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
					}
					for (i = 0; i < nd->N;  i++)
					for (j = 0; j < nd->N1; j++)
					if (rad == 0. || ! id_bcond) nd->hit[i+j*nd->N] = 0;	else
					if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad))    nd->hit[i+j*nd->N] = 0; else  
					if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad+ll)) nd->hit[i+j*nd->N] = 2; else	nd->hit[i+j*nd->N] = 1;	

					sm->GetSurferFormat("rr_I", nd,				  HEAT_VALUE,							0, axis_I);
					sm->GetSurferFormat("pp_I", nd, id_bcond ? FLUX_VALUE : FLUX_COMPOS_VALUE, 0, axis_I);

					if (id_visual > 2) { 
						nd->zero_grid();
						if (axis_II == AXIS_Z) {
							for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
							for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

							nd->add_new_point_Z(par[4]+(par[5]-par[4])*(1.+section_II)*.5);
							nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
						}
						if (axis_II == AXIS_Y) {
							for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
							for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);

							nd->add_new_point_Z(par[2]+(par[3]-par[2])*(1.+section_II)*.5);
							nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
						}
						if (axis_II == AXIS_X) {
							for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
							for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);

							nd->add_new_point_Z(par[0]+(par[1]-par[0])*(1.+section_II)*.5);
							nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
						}
						for (i = 0; i < nd->N;  i++)
						for (j = 0; j < nd->N1; j++)
						if (rad == 0. || ! id_bcond) nd->hit[i+j*nd->N] = 0;	else
						if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad))    nd->hit[i+j*nd->N] = 0; else  
						if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad+ll)) nd->hit[i+j*nd->N] = 2; else	nd->hit[i+j*nd->N] = 1;	

						sm->GetSurferFormat("rr_II", nd,				  HEAT_VALUE,							0, axis_II);
						sm->GetSurferFormat("pp_II", nd, id_bcond ? FLUX_VALUE : FLUX_COMPOS_VALUE, 0, axis_II);
					}
				}
				delete nd;
			}
			A *= fL; rad *= fL;
			B *= fL;	ll  *= fL;
			C *= fL;
		}
	}
	delete sm;
}
#endif
#ifdef LAME3D_ANALYT_HOMOGENIZATION
{
	double par[6], rad = 1., h_rad = 0., A = 5., B = 5., C = 5., ll = 0.5, section = 0., section_I = 0., section_II = 0.,
						nj1 = 0.3, nj2 = 0.3, nj3 = 0.3, E1  = 1.0, E2  = 2.0, E3  = 3.0;
	int id_visual = 0, N_rad = 1, NX = 100, NY = 100, N0 = 7, N_elem = 8, N_max = 4, id_bcond = 0, id_solver = 0, id_type = 0, 
				axis = AXIS_Y, axis_I = AXIS_Z, axis_II = AXIS_X, i, j, l;

//////////////////////////////////
//...reading model from data-file;`
   sprintf(buf, "Reading data...");
   Message(" ");
   Message(buf);

	unsigned long count, upper_limit;
	char        * id_DATA = read_struct_ascii("lame3d_initial.dat");
	if         (! id_DATA) {
		sprintf(buf, "Data not found..");
		Message(" ");
		Message(buf);
		sprintf(buf, "Creating data file \"lame3d_initial.dat\"...");
		Message(buf);
		Message(" ");

		FILE  * TST = fopen("lame3d_initial.dat", "w");
		fprintf(TST, "N = %i\nN_elem = %i\nN_max = %i\n\n", N0, N_elem, N_max);
		fprintf(TST, "id_bcond = %i  id_solver = %i  id_type = %i\n\n", id_bcond, id_solver, id_type);
		fprintf(TST, "id_visual = %i\nNX = %i\nNY = %i\naxis = %i  axis_I = %i  axis_II = %i\nsection = %g  section_I = %g  section_II = %g\n\n", 
			id_visual, NX, NY, axis, axis_I, axis_II, section, section_I, section_II);
		fprintf(TST, "A = %g\nB = %g\nC = %g\nrad = %g  layer = %g  h_rad = %g  N_rad = %i\n\n", A, B, C, rad, ll, h_rad, N_rad);
		fprintf(TST, "E1 = %g  nu1 = %g\nE2 = %g  nu2 = %g\nE3 = %g  nu3 = %g\n", E2, nj2, E3, nj3, E1, nj1);
		fclose (TST);

		printf("N = %i\nN_elem = %i\nN_max = %i\n\n", N0, N_elem, N_max);
		printf("id_bcond = %i  id_solver = %i  id_type = %i\n\n", id_bcond, id_solver, id_type);
		printf("id_visual = %i\nNX = %i\nNY = %i\naxis = %i  axis_I = %i  axis_II = %i\nsection = %g  section_I = %g  section_II = %g\n\n", 
			id_visual, NX, NY, axis, axis_I, axis_II, section, section_I, section_II);
		printf("A = %g\nB = %g\nC = %g\nrad = %g  layer = %g  h_rad = %g  N_rad = %i\n\n", A, B, C, rad, ll, h_rad, N_rad);
		printf("E1 = %g  nu1 = %g\nE2 = %g  nu2 = %g\nE3 = %g  nu3 = %g\n", E2, nj2, E3, nj3, E1, nj1);
		goto test;
	}
	user_Count    (id_DATA, 0, upper_limit, '\x0');
	if (user_Count(id_DATA, count = 0, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) N0 = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) N_elem = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) N_max = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) id_bcond = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) id_solver = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) id_type = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) id_visual = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) NX = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) NY = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) axis = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) axis_I = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) axis_II = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) section = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) section_I = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) section_II = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) A = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) B = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) C = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) rad = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) ll = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) h_rad = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) N_rad = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) E2 = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) nj2 = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) E3 = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) nj3 = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) E1 = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) nj1 = user_strtod(buf);

///////////////////////////////////////
//...creating model from initiual data;
test:
	CDraft<double> * sm = CreateDraftR(LAME3D_DRAFT, 7);
	sm->set_mpls(PackInts(N0, N0));			//...степень мультиполей;
	sm->set_quad(PackInts(N_elem, N_max)); //...степень квадратуры;
	sm->set_normaliz(0.92);						//...нормирующий множитель;
	sm->set_lagrange(1.);						//...коэффициент Лагранжа; 
	sm->change_solv(SPECIAL_SOLVING);
	sm->solver.change_state(/*EXTERN_STATE*/);
	sm->solver.set_mode(/*REDUCED_PRINT*//*PRINT_MODE*//*FULLY_MODE*/);
	yes = 0;

////////////////////////////////////////////////////////
//...перебираем все радиусы, отключая предельные случаи;
	FILE  * TST = fopen("lame3D_homog.dat", "w");
	fclose (TST);
	for (l = 0; l < N_rad; l++, rad += h_rad) { 
		sprintf(buf, "rad = %g", rad);
		Message(" ");
		Message(buf);

////////////////////////////////////////////////////////////////////////////////
//...пересчет параметров ячейки для обеспечения одинаковой концентрации шунгита;
		if (id_type == 1) A = B = C = pow(300.*M_PI,  1./3.)*(rad+10.)*.5;                                                                    
		if (id_type == 2) A = B = C = pow(300.*M_PI,  1./3.)*pow(rad*sqr(rad)+((rad+ll)*sqr(rad+ll)-rad*sqr(rad))*(E3-E1)/(E2-E1), 1./3.)*.5;                                           
		if (id_type == 3) {
			A = B = C = pow(200.*M_PI/3.,  1./3.)*rad;
			if (rad > 100) ll = 1.54*12.5*pow(100./(1.54*12.5), 2.*(3.-2.568)/3.); 
			else 				ll = 1.54*12.5*pow( rad/(1.54*12.5), 2.*(3.-2.568)/3.);
		}
		if (rad > 0. && rad <= 0.5*A) { 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//...нормируем геометрию и задаем параметры материалов (в случае ___2BODY_ESHELBY___ для межфазного слоя задаем параметры матрицы!!!);
			double fL = A;	A /= fL; B /= fL; C /= fL; rad /= fL; ll /= fL;
			sm->set_fasa_hmg(nj1, nj2, E1/(fL*(1.+nj1))*.5, E2/(fL*(1.+nj2))*.5, nj3, E3/(fL*(1.+nj3))*.5/*, nj1, E1/(fL*(1.+nj1))*.5*/);
			sm->set_geometry(rad, ll);

//////////////////////
//...задаем геометрию;
			if (id_bcond) sm->GetSphBoxStruct(A, B, C, rad, ll);
			else {
				sm->GetSphBoxStruct(A, B, C);
				sm->SetBUniStruct(CLAYER_BLOCK, ERR_GENUS);
			}
			par[0] = -A*.5; par[2] = -B*.5; par[4] = -C*.5;
			par[1] =  A*.5; par[3] =  B*.5; par[5] =  C*.5;

///////////////////////////  
//...solving of the probem;
			if (sm->computing_kernel(PERIOD_COMPUT) != OK_STATE) {
				Message("Error in sample computing...");
				delete sm;
				goto err;
			}

//////////////////////////////////////////
//..вычисляем эффективные модули композита;
			double K[28], E0, nu, K0, m0, mu, lm, C0, KH, EH, mH, nH, ff_vol, ll_vol; memset(K, 0, 28*sizeof(double)); K[27] = A*.5;
			sm->GetRigidy(K, -1, BASIC_COMPUT);
			sm->GetRigidy(K, -1, COVERING_COMPUT);

			ff_vol = K[25]/(K[24]+K[25]+K[26]);
			ll_vol = K[26]/(K[24]+K[25]+K[26]); 
			
			C0 = (K[5]-2.*K[0]*K[6]/(K[6]+K[11]))/(K[11]-2.*K[6]*K[6]/(K[6]+K[11]))*fL;
			lm = (K[0]-C0*K[6])/(K[6]+K[11])*fL;
			nu = lm/(C0+lm);
			E0 = C0*(1.-2.*nu)*(1.+nu)/(1.-nu);
			K0 = E0/(3.*(1.-2.*nu));
			m0 = E0/(2.*(1.+nu));
			mu = K[15]/K[21]*.5*fL;

////////////////////////////////////////
//...четырехфазная модель, метод Эшелби;
			KH = sm->TakeEshelby_volm(ff_vol, ll_vol)*fL;
			//KH = sm->TakeEshelby_volm_two (ff_vol)*fL;
			//mH = sm->TakeEshelby_shear_two(ff_vol+ll_vol)*fL;
			mH = sm->TakeEshelby_shear(ff_vol, ll_vol)*fL;
			EH = 9.*KH*mH/(3.*KH+mH);
			nH = (1.5*KH-mH)/(3.*KH+mH);

			//FILE  * TST = fopen("lame3D_homog.dat", "a");
			//fprintf(TST, "ff_vol = %g  ll_vol = %g  E0 = %g  nu = %g  mu = %g  (%g, %g, %g, %g, %g, %g) (N = %i)\n", 
			//					 ff_vol, ll_vol, E0, nu, mu, E2, E3, E1, nj2, nj3, nj1, N0);

			const char  * buf = id_type ? (id_type == 1 ? "lame3d_homog_kf1.dat" : (id_type == 2 ? "lame3d_homog_kf2.dat" : "lame3d_homog_kf3.dat")) : "lame3D_homog_kf0.dat";
			const char  * bf1 = id_type ? (id_type == 1 ? "lame3d_homg1_kf1.dat" : (id_type == 2 ? "lame3d_homg1_kf2.dat" : "lame3d_homg1_kf3.dat")) : "lame3D_homg1_kf0.dat";
			const char  * bf2 = id_type ? (id_type == 1 ? "lame3d_homg2_kf1.dat" : (id_type == 2 ? "lame3d_homg2_kf2.dat" : "lame3d_homg2_kf3.dat")) : "lame3D_homg2_kf0.dat";
			//FILE  * TST = fopen(id_bcond == 1 ? bf1 : (id_bcond == 2 ? bf2 : buf), "a");
			//fprintf(TST, "rad = %g  A = %g  E0 = %g  nu = %g  K0 = %g  m0 = %g  mu = %g  EH = %g  KH = %g  (%g, %g, %g, %g, %g, %g) (N = %i)\n", 
			//			rad*fL, A*fL, E0, nu, K0, m0, mu, EH, KH, E2, E3, E1, nj2, nj3, nj1, N0);
			TST = fopen("lame3D_homog.dat", "a");
			fprintf(TST, "%g  %g  %g  %g  %g  %g  %g  %g  %g  (%g, %g, %g, %g, %g, %g) (%i)\n", 
						4./3.*M_PI*rad*sqr(rad)*100., rad*fL, ll/rad, K0, mu, E0, KH, mH, EH, m0, ff_vol, ll_vol, nj2, nj3, nj1, N0);
			fclose (TST);

//////////////////
//..visualization;
			if (id_visual) {
				CGrid * nd = CreateNodes();
				if (axis == AXIS_Z) {
					for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
					for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

					nd->add_new_point_Z(par[4]+(par[5]-par[4])*(1.+section)*.5);
					nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
				}
				if (axis == AXIS_Y) {
					for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
					for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);

					nd->add_new_point_Z(par[2]+(par[3]-par[2])*(1.+section)*.5);
					nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
				}
				if (axis == AXIS_X) {
					for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
					for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);

					nd->add_new_point_Z(par[0]+(par[1]-par[0])*(1.+section)*.5);
					nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
				}
				for (i = 0; i < nd->N;  i++)
				for (j = 0; j < nd->N1; j++)
				if (rad == 0. || ! id_bcond) nd->hit[i+j*nd->N] = 0;	else
				if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad))    nd->hit[i+j*nd->N] = 0; else  
				if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad+ll)) nd->hit[i+j*nd->N] = 2; else	nd->hit[i+j*nd->N] = 1;	

				system("del *.grd");
				sm->GetSurferFormat("rz", nd,		DISPL_VALUE, 0, axis);
				sm->GetSurferFormat("rx", nd,		DISPL_VALUE, 1, axis);
				sm->GetSurferFormat("tz", nd, STRESS_Z_VALUE, 0, axis);
				sm->GetSurferFormat("tx", nd, STRESS_X_VALUE, 1, axis);

/////////////////////////////////////////
//...дополнительные сечения (если нужно);
				if (id_visual > 1) { 
					nd->zero_grid();
					if (axis_I == AXIS_Z) {
						for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
						for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

						nd->add_new_point_Z(par[4]+(par[5]-par[4])*(1.+section_I)*.5);
						nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
					}
					if (axis_I == AXIS_Y) {
						for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
						for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);

						nd->add_new_point_Z(par[2]+(par[3]-par[2])*(1.+section_I)*.5);
						nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
					}
					if (axis_I == AXIS_X) {
						for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
						for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);

						nd->add_new_point_Z(par[0]+(par[1]-par[0])*(1.+section_I)*.5);
						nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
					}
					for (i = 0; i < nd->N;  i++)
					for (j = 0; j < nd->N1; j++)
					if (rad == 0. || ! id_bcond) nd->hit[i+j*nd->N] = 0;	else
					if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad))    nd->hit[i+j*nd->N] = 0; else  
					if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad+ll)) nd->hit[i+j*nd->N] = 2; else	nd->hit[i+j*nd->N] = 1;	

					sm->GetSurferFormat("rz_I", nd,	  DISPL_VALUE, 0, axis_I);
					sm->GetSurferFormat("rx_I", nd,	  DISPL_VALUE, 1, axis_I);
					sm->GetSurferFormat("tz_I", nd, STRESS_Z_VALUE, 0, axis_I);
					sm->GetSurferFormat("tx_I", nd, STRESS_X_VALUE, 1, axis_I);

					if (id_visual > 2) { 
						nd->zero_grid();
						if (axis_II == AXIS_Z) {
							for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
							for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

							nd->add_new_point_Z(par[4]+(par[5]-par[4])*(1.+section_II)*.5);
							nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
						}
						if (axis_II == AXIS_Y) {
							for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
							for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);

							nd->add_new_point_Z(par[2]+(par[3]-par[2])*(1.+section_II)*.5);
							nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
						}
						if (axis_II == AXIS_X) {
							for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
							for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);

							nd->add_new_point_Z(par[0]+(par[1]-par[0])*(1.+section_II)*.5);
							nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
						}
						for (i = 0; i < nd->N;  i++)
						for (j = 0; j < nd->N1; j++)
						if (rad == 0. || ! id_bcond) nd->hit[i+j*nd->N] = 0;	else
						if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad))    nd->hit[i+j*nd->N] = 0; else  
						if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad+ll)) nd->hit[i+j*nd->N] = 2; else	nd->hit[i+j*nd->N] = 1;	

						sm->GetSurferFormat("rz_II", nd,		DISPL_VALUE, 0, axis_II);
						sm->GetSurferFormat("rx_II", nd,		DISPL_VALUE, 1, axis_II);
						sm->GetSurferFormat("tz_II", nd, STRESS_Z_VALUE, 0, axis_II);
						sm->GetSurferFormat("tx_II", nd, STRESS_X_VALUE, 1, axis_II);
					}
				}
				delete nd;
			}
			A *= fL; B *= fL;	C *= fL;	rad *= fL;	ll *= fL;	
		}				 
	}
	delete sm;
}
#endif
#ifdef HYDRO3D_ANALYT_HOMOGENIZATION
{
	double par[6], rad = 0.5, h_rad = 0., L = 0.5, alpha = 0., section = 0., section_I = 0., section_II = 0.;
	int id_visual = 0, axis = AXIS_Y, axis_I = AXIS_Z, axis_II = AXIS_X, NX = 100, NY = 100, N_elem = 4, N_max = 2, 
		 structure = 0, N_rad = 1, N0 = 7, i, j, k, l, m, num;
	char name[2000]; name[0] = 0;

//////////////////////////////////
//...reading model from data-file;`
   sprintf(buf, "Reading data...");
   Message(" ");
   Message(buf);

	unsigned long count, upper_limit;
	char        * id_DATA = read_struct_ascii("hydro3D_initial.dat");
	if         (! id_DATA) {
		sprintf(buf, "Data not found...");
		Message(" ");
		Message(buf); 
		sprintf(buf, "Creating data file \"hydro3d_initial.dat\"...");
		Message(buf);
		Message(" ");

		FILE  * TST = fopen("hydro3d_initial.dat", "w");
		fprintf(TST, "N = %i\nN_elem = %i\nN_max = %i\n\n", N0, N_elem, N_max);
		fprintf(TST, "id_visual = %i\nNX = %i\nNY = %i\naxis = %i  axis_I = %i  axis_II = %i\nsection = %g  section_I = %g  section_II = %g\n\n", 
			id_visual, NX, NY, axis, axis_I, axis_II, section, section_I, section_II);
		fprintf(TST, "structure = %i\nname = %s\n\n", structure, name);
		fprintf(TST, "rad = %g  h_rad = %g  N_rad = %i\nalpha = %g\n\n", rad, h_rad, N_rad, alpha);
		fclose (TST);

		printf("N = %i\nN_elem = %i\nN_max = %i\n\n", N0, N_elem, N_max);
		printf("id_visual = %i\nNX = %i\nNY = %i\naxis = %i  axis_I = %i  axis_II = %i\nsection = %g  section_I = %g  section_II = %g\n\n", 
			id_visual, NX, NY, axis, axis_I, axis_II, section, section_I, section_II);
		printf("structure = %i\nname = %s\n\n", structure, name);
		printf("rad = %g  h_rad = %g  N_rad = %i\nalpha = %g\n\n", rad, h_rad, N_rad, alpha);

		goto test;
	}
	user_Count    (id_DATA, 0, upper_limit, '\x0');
	if (user_Count(id_DATA, count = 0, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) N0 = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) N_elem = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) N_max = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) id_visual = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) NX = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) NY = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) axis = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) axis_I = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) axis_II = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) section = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) section_I = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) section_II = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) structure = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && structure &&  
		user_Read (buf, id_DATA, count, upper_limit, NULL_STATE)) ::strcpy(name, buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) rad = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) h_rad = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) N_rad = atoi(buf);
	
	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) alpha = user_strtod(buf);

//////////////////////////////////////
//...creating model from initial data;
test:
#define real_T double
	CDraft<real_T> * sm = CreateDraftR(HYDRO3D_DRAFT, 8);		
	sm->set_fasa_hmg(alpha);					//...коэффициент Бринкмана; 
	sm->set_mpls(PackInts(N0, N0));			//...степень мультиполей;
	sm->set_quad(PackInts(N_elem, N_max)); //...степень квадратуры;
	sm->set_normaliz(L*sqrt(3.)/(.5*rad));	//...нормирующий множитель; 
	sm->set_lagrange(1e5);						//...коэффициент Лагранжа; 
	sm->change_solv(structure ? SQUARE_SOLVING : SPECIAL_SOLVING);
	sm->solver.set_mode(/*PRINT_MODE*/);
	yes = 0;

///////////////////////////////////////////////////////
//...чтение модели и граничных условий из файла данных;
	if (sm && structure && structure != 3) {
		Message(" ");
		sprintf(buf, "Loading model from file '%s'", name);
		Message(buf);
		Message("Reading data file ...");

		sm->stru.nodes_in(name);
      sm->bar_condit_in(name);
		sm->LinkUniStruct();
		sm->SetBUniStruct();
		sm->SetGeomBounding(par); 
		if (structure == 1) sm->solver.change_state(EXTERN_STATE); 
		N_rad = 1;
		Message("Finish!");

///////////////////////////////////////////////////////////////////////////////////////////
//...задание граничных значений в модели (скорость поперек потока и давление вдоль потока);
		double po[6] = { 0., 0., 0., 0., 0., 0.};
		sm->BlockActivate();
		for (k = 0; k < sm->N; k++) 
		LOOP_FACET(sm->B[k].bar, num, m) {
			sm->B[k].bar->SetFacetXParam(num, par[0], po, FSKEWS_BND);
			sm->B[k].bar->SetFacetXParam(num, par[1], po, FSKEWS_BND);

			sm->B[k].bar->SetFacetYParam(num, par[2], po, FSKEWS_BND);
			sm->B[k].bar->SetFacetYParam(num, par[3], po, FSKEWS_BND);
			
			sm->B[k].bar->SetFacetZParam(num, par[4], po, SPECIAL_BND);
			sm->B[k].bar->SetFacetZParam(num, par[5], po, SPECIAL_BND);
		}
	}

////////////////////////////////////////////////////////
//...перебираем все радиусы, отключая предельные случаи;
	res = system("mkdir ./bcm_results/hydro3d_homog"); char buff1[200], buff2[200], str[40];
//	res = system("del *.grd");
	for (l = 0; l < N_rad; l++, rad += h_rad) { 
		sprintf(buf, "rad = %g", rad);
		Message(" ");
		Message(buf);
		if (rad > 0. && rad < M_SQRT_2 || structure) {
			if (! structure || structure == 3) { //...задание геометрии аналитически;
				if (rad < 0.5)
				sm->GetSphBoxStruct(2.*L, 2.*L, 2.*L, rad, 0., OK_STATE); else
				sm->GetPenetrateSphere(rad, L);
				sm->SetBUniStruct(CLAYER_BLOCK, ERR_GENUS);
				sm->set_geometry(rad);
				par[0] = -L; par[2] = -L; par[4] = -L;
				par[1] =  L; par[3] =  L; par[5] =  L;
				if (1) { //...задание краевых условий на боковых гранях;
					double po[6] = { 0., 0., 0., 0., 0., 0.};
					LOOP_FACET(sm->B[0].bar, num, m) {
						sm->B[0].bar->SetFacetXParam(num, par[0], po, FSKEWS_BND);
						sm->B[0].bar->SetFacetXParam(num, par[1], po, FSKEWS_BND);

						sm->B[0].bar->SetFacetYParam(num, par[2], po, FSKEWS_BND);
						sm->B[0].bar->SetFacetYParam(num, par[3], po, FSKEWS_BND);
						
						sm->B[0].bar->SetFacetZParam(num, par[4], po, SPECIAL_BND);
						sm->B[0].bar->SetFacetZParam(num, par[5], po, SPECIAL_BND);
					}
				}
			}

///////////////////////////
//...solving of the probem;
			if (sm->computing_kernel(structure ? BASIC_COMPUT : PERIOD_COMPUT) != OK_STATE)
				Message("Error in sample computing...");

////////////////////////////////////////////////////////////////
//..вычисляем усредненные характеристики (тензор проницаемости);
			double nn, nn_cyl, nn_cyl_alpha, nn_l, nn_l_alpha, ff_vol;
			real_T K[4]; memset(K, 0, 4*sizeof(real_T));
			sm->GetRigidy(K, -1,  BASIC_COMPUT); 	

			if (rad < 0.5)
			ff_vol = 1.-4./3.*M_PI*rad*rad*rad; else
			ff_vol = 1.-2.*M_PI*(1.5*rad*rad-4./3.*rad*rad*rad-0.125);
			nn = to_double(K[2]/K[3])*ff_vol;

			nn_cyl = sqr(ff_vol)/(8.*M_PI);
			nn_l	= sqr(ff_vol)*ff_vol/12.; 

			nn_cyl_alpha = sm->TakeCylinder(ff_vol);
			nn_l_alpha	 = sm->TakeLayer	 (ff_vol);

			FILE * TST = fopen("./bcm_results/hydro3d_homog/hydro3d_homog.dat", "a");
			if (TST) fprintf(TST, "ff_vol = %g  vol = %g  nn = %g  nn_cyl = %g/%g  nn_l = %g/%g  (rad = %g  alpha = %g  N_mpls = %i)\n", 
										  ff_vol, to_double(K[3]), nn, nn_cyl_alpha, nn_cyl, nn_l_alpha, nn_l, rad, alpha, N0);
			if (TST) fclose (TST);

//////////////////
//..visualization;
			sprintf(str, "%g", rad); sprintf(buff1, "./bcm_results/hydro3d_homog/pp_%s", str); sprintf(buff2, "./bcm_results/hydro3d_homog/vv_%s", str);
			if (id_visual) { //..visualization;
				CGrid * nd = CreateNodes();
				if (axis == AXIS_Z) {
					for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
					for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);
					nd->add_new_point_Z(par[4]+(par[5]-par[4])*(1.+section)*.5);
				}
				if (axis == AXIS_Y) {
					for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
					for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);
					nd->add_new_point_Z(par[2]+(par[3]-par[2])*(1.+section)*.5);
				}
				if (axis == AXIS_X) {
					for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
					for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);
					nd->add_new_point_Z(par[0]+(par[1]-par[0])*(1.+section)*.5);
				}
				nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
				if (structure && structure != 3)
				for (i = 0; i < nd->N;  i++)
				for (j = 0; j < nd->N1; j++) {
					int hit = -1;
					if (axis == AXIS_Z) sm->Poly_struc_in3D(hit, nd->X[i], nd->Y[j], nd->Z[0]); else
					if (axis == AXIS_Y) sm->Poly_struc_in3D(hit, nd->Y[j], nd->Z[0], nd->X[i]); else
					if (axis == AXIS_X) sm->Poly_struc_in3D(hit, nd->Z[0], nd->X[i], nd->Y[j]);
					//if (structure > 1) { //...коррекция канала между сферическими частицами;
					//	if (sqr(nd->X[i]+L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]-L) < sqr(rad)) hit = -1;
					//	if (sqr(nd->X[i]-L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]-L) < sqr(rad)) hit = -1;
					//	if (sqr(nd->X[i]-L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]-L) < sqr(rad)) hit = -1;
					//	if (sqr(nd->X[i]+L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]-L) < sqr(rad)) hit = -1;
					//	if (sqr(nd->X[i]+L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]+L) < sqr(rad)) hit = -1;
					//	if (sqr(nd->X[i]-L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]+L) < sqr(rad)) hit = -1;
					//	if (sqr(nd->X[i]-L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]+L) < sqr(rad)) hit = -1;
					//	if (sqr(nd->X[i]+L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]+L) < sqr(rad)) hit = -1;
					//}
					nd->hit[i+j*nd->N] = hit;
				}
				else
				for (i = 0; i < nd->N;  i++)
				for (j = 0; j < nd->N1; j++)
					if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad)) nd->hit[i+j*nd->N] = -1;

				//system("del *.grd");
				//sm->GetSurferFormat("./bcm_results/hydro3d_homog/bb", nd,	     ERR_VALUE, 0, axis);
				//sm->GetSurferFormat("./bcm_results/hydro3d_homog/pp", nd,	PRESSURE_VALUE, 0, axis);
				//sm->GetSurferFormat("./bcm_results/hydro3d_homog/vv", nd, VELOCITY_VALUE, 0, axis);

				sm->GetSurferFormat(buff1, nd,	PRESSURE_VALUE, 0, axis);
				sm->GetSurferFormat(buff2, nd, VELOCITY_VALUE, 0, axis);

				//sm->GetDataFormat("./bcm_results/hydro3d_homog/pp", nd, PRESSURE_VALUE, 0, axis);
				//sm->GetDataFormat("./bcm_results/hydro3d_homog/vv", nd, VELOCITY_VALUE, 0, axis);
				//if (axis == AXIS_Z && ! structure) {
				//	for (i = 0; i < nd->N;  i++)
				//	for (j = 0; j < nd->N1; j++) 
				//		if (sqr(nd->X[i])+sqr(nd->Y[j]) > sqr(rad)) nd->hit[i+j*nd->N] = -1; else nd->hit[i+j*nd->N] = 0;
				//	sm->GetSurferFormat("./bcm_results/hydro3d_homog/vv_analyt", nd, ANALYT_VALUE, 0, axis);
				//}

/////////////////////////////////////////
//...дополнительные сечения (если нужно);
				if (id_visual > 1) { 
					nd->zero_grid();
					if (axis_I == AXIS_Z) {
						for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
						for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);
						nd->add_new_point_Z(par[4]+(par[5]-par[4])*(1.+section_I)*.5);
					}
					if (axis_I == AXIS_Y) {
						for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
						for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);
						nd->add_new_point_Z(par[2]+(par[3]-par[2])*(1.+section_I)*.5);
					}
					if (axis_I == AXIS_X) {
						for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
						for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);
						nd->add_new_point_Z(par[0]+(par[1]-par[0])*(1.+section_I)*.5);
					}
					nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
					if (structure && structure != 3)
					for (i = 0; i < nd->N;  i++)
					for (j = 0; j < nd->N1; j++) {
						int hit = -1;
						if (axis_I == AXIS_Z) sm->Poly_struc_in3D(hit, nd->X[i], nd->Y[j], nd->Z[0]); else
						if (axis_I == AXIS_Y) sm->Poly_struc_in3D(hit, nd->Y[j], nd->Z[0], nd->X[i]); else
						if (axis_I == AXIS_X) sm->Poly_struc_in3D(hit, nd->Z[0], nd->X[i], nd->Y[j]);
						//if (structure > 1) { //...коррекция канала между сферическими частицами;
						//	if (sqr(nd->X[i]+L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]-L) < sqr(rad)) hit = -1;
						//	if (sqr(nd->X[i]-L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]-L) < sqr(rad)) hit = -1;
						//	if (sqr(nd->X[i]-L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]-L) < sqr(rad)) hit = -1;
						//	if (sqr(nd->X[i]+L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]-L) < sqr(rad)) hit = -1;
						//	if (sqr(nd->X[i]+L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]+L) < sqr(rad)) hit = -1;
						//	if (sqr(nd->X[i]-L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]+L) < sqr(rad)) hit = -1;
						//	if (sqr(nd->X[i]-L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]+L) < sqr(rad)) hit = -1;
						//	if (sqr(nd->X[i]+L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]+L) < sqr(rad)) hit = -1;
						//}
						nd->hit[i+j*nd->N] = hit;
					}
					else
					for (i = 0; i < nd->N;  i++)
					for (j = 0; j < nd->N1; j++)
						if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad)) nd->hit[i+j*nd->N] = -1;

					//sm->GetSurferFormat("./bcm_results/hydro3d_homog/bb_I", nd,	    ERR_VALUE, 0, axis_I);
					sm->GetSurferFormat("./bcm_results/hydro3d_homog/pp_I", nd, PRESSURE_VALUE, 0, axis_I);
					sm->GetSurferFormat("./bcm_results/hydro3d_homog/vv_I", nd, VELOCITY_VALUE, 0, axis_I);

					//sm->GetDataFormat("./bcm_results/hydro3d_homog/pp_I", nd, PRESSURE_VALUE, 0, axis_I);
					//sm->GetDataFormat("./bcm_results/hydro3d_homog/vv_I", nd, VELOCITY_VALUE, 0, axis_I);
					//if (axis_I == AXIS_Z && ! structure) {
					//	for (i = 0; i < nd->N;  i++)
					//	for (j = 0; j < nd->N1; j++) 
					//		if (sqr(nd->X[i])+sqr(nd->Y[j]) > sqr(rad)) nd->hit[i+j*nd->N] = -1; else nd->hit[i+j*nd->N] = 0;
					//	sm->GetSurferFormat("./bcm_results/hydro3d_homog/vv_analyt", nd, ANALYT_VALUE, 0, axis_I);
					//}

					if (id_visual > 2) { 
						nd->zero_grid();
						if (axis_II == AXIS_Z) {
							for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
							for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);
							nd->add_new_point_Z(par[4]+(par[5]-par[4])*(1.+section_II)*.5);
						}
						if (axis_II == AXIS_Y) {
							for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
							for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);
							nd->add_new_point_Z(par[2]+(par[3]-par[2])*(1.+section_II)*.5);
						}
						if (axis_II == AXIS_X) {
							for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
							for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);
							nd->add_new_point_Z(par[0]+(par[1]-par[0])*(1.+section_II)*.5);
						}
						nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
						if (structure && structure != 3)
						for (i = 0; i < nd->N;  i++)
						for (j = 0; j < nd->N1; j++) {
							int hit = -1;
							if (axis_II == AXIS_Z) sm->Poly_struc_in3D(hit, nd->X[i], nd->Y[j], nd->Z[0]); else
							if (axis_II == AXIS_Y) sm->Poly_struc_in3D(hit, nd->Y[j], nd->Z[0], nd->X[i]); else
							if (axis_II == AXIS_X) sm->Poly_struc_in3D(hit, nd->Z[0], nd->X[i], nd->Y[j]);
							//if (id_structure > 1) { //...коррекция канала между сферическими частицами;
							//	if (sqr(nd->X[i]+L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]-L) < sqr(rad)) hit = -1;
							//	if (sqr(nd->X[i]-L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]-L) < sqr(rad)) hit = -1;
							//	if (sqr(nd->X[i]-L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]-L) < sqr(rad)) hit = -1;
							//	if (sqr(nd->X[i]+L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]-L) < sqr(rad)) hit = -1;
							//	if (sqr(nd->X[i]+L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]+L) < sqr(rad)) hit = -1;
							//	if (sqr(nd->X[i]-L)+sqr(nd->Y[j]-L)+sqr(nd->Z[0]+L) < sqr(rad)) hit = -1;
							//	if (sqr(nd->X[i]-L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]+L) < sqr(rad)) hit = -1;
							//	if (sqr(nd->X[i]+L)+sqr(nd->Y[j]+L)+sqr(nd->Z[0]+L) < sqr(rad)) hit = -1;
							//}
							nd->hit[i+j*nd->N] = hit;
						}
						else
						for (i = 0; i < nd->N;  i++)
						for (j = 0; j < nd->N1; j++)
							if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad)) nd->hit[i+j*nd->N] = -1;

						//sm->GetSurferFormat("./bcm_results/hydro3d_homog/bb_II", nd,	     ERR_VALUE, 0, axis_II);
						sm->GetSurferFormat("./bcm_results/hydro3d_homog/pp_II", nd, PRESSURE_VALUE, 0, axis_II);
						sm->GetSurferFormat("./bcm_results/hydro3d_homog/vv_II", nd, VELOCITY_VALUE, 0, axis_II);

						//sm->GetDataFormat("./bcm_results/hydro3d_homog/pp_II", nd, PRESSURE_VALUE, 0, axis_II);
						//sm->GetDataFormat("./bcm_results/hydro3d_homog/vv_II", nd, VELOCITY_VALUE, 0, axis_II);
						//if (axis_II == AXIS_Z && ! structure) {
						//	for (i = 0; i < nd->N;  i++)
						//	for (j = 0; j < nd->N1; j++) 
						//		if (sqr(nd->X[i])+sqr(nd->Y[j]) > sqr(rad)) nd->hit[i+j*nd->N] = -1; else nd->hit[i+j*nd->N] = 0;
						//	sm->GetSurferFormat("./bcm_results/hydro3d_homog/vv_analyt", nd, ANALYT_VALUE, 0, axis_II);
						//}
					}
				}
				delete nd;
			}
		}
	}
	delete sm;
#undef real_T
}
#endif
#ifdef TEST_DRAFT_HEAT2D_INTERMEDIATE_PHASE
{
	char * name = "./Parametric/Unit2d_1.nas", * buff;
	//char * name = "./Box2d_homog/heat_clayer488.nas", * buff;
	//char * name = "./Box2d_homog/heat_cyl_layer1148.nas", * buff;
	//char * name = "./Box2d_homog/heat_ell_layer1174.nas", * buff;
	//char * name = "./Box2d_homog/sph_025_16.nas", * buff;
	int  i, j, l;
	double X0, Y0, ell_X = 0., ell_Y = 0., rot_Z, ff = 0.2, rr = sqrt(ff/M_PI);

/////////////////////////
//...model iitialization;
	CDraft<double> * sm = CreateDraftR(HEAT2D_DRAFT);
	sm->set_mpls(PackInts(7, 7));	//...space degree of multipoles;
	sm->set_quad(PackInts(4, 4));	//...N_elem, N_max -- parameters of quadrature;
	sm->set_normaliz(0.92);			//...normalization coefficient;
	sm->set_lagrange(1e-4);			//...Lagrange coefficient for energy;
	sm->change_solv(SPECIAL_SOLVING);
	sm->solver.change_state(/*EXTERN_STATE*/);
	sm->solver.set_mode(/*PRINT_MODE | FULLY_MODE | MASKS_MODE | ACCUMULATION*/);
	//yes = 0;

//////////////////////////////////
//...reading model from data-file;
	CGrid * nd = CreateNodes();
	if (nd && sm) {
      sprintf(buf, "Loading model from file '%s'", name);
      Message(" ");
      Message(buf);
      Message("Reading data file ...");

		sm->stru.nodes_in(name);
		sm->bar_condit_in(name);
		sm->LinkUniStruct();
		sm->SetBUniStruct(CLAYER_BLOCK);

/////////////////////////////
//...parameters of inclusion;
		if (sm->id_prop && sm->pp_cond)
		for (j = 0; j < sm->id_prop[0]; j++)
		if (sm->id_prop[j*2+2] == BSOURCE_BND) {
			X0		= sm->pp_cond[j*6]; 
			Y0		= sm->pp_cond[j*6+1];
			ell_X = sm->pp_cond[j*6+2];
			ell_Y = sm->pp_cond[j*6+3];
			rot_Z = sm->pp_cond[j*6+4];
			break;
		}
		if (ell_X != 0. && ell_Y != 0.) {
			CCells * ce = new(CCells);
			ce->cells_new(1, 2, (l = size_of_map(1, CYL_GENUS))+1);
			ce->mp[0] = (CMap)ID_MAP(1, CYL_GENUS);
			ce->mp[1] = X0;
			ce->mp[2] = Y0;
			ce->mp[4] = rot_Z/180.*M_PI;
			ce->mp[7] = ell_X;
			ce->mp[8] = ell_Y;
			ce->mp[l] = (CMap)NULL_CELL;
			sm->bar = new(CCells);
			sm->bar->bar_add(ce);
		}
		Message("Finish!");
	}

//////////////////////////
//...homogenization cycle;
	FILE  * TST = fopen(buff = "heat2D_homog.dat", "w"); 
	fclose (TST);
	for (int var = 0; var < 1; var++) {
		double K1 = 1.,		//...heat conduction (matrix);
				 K2 = 20.,		//...heat conduction (inclusion);
				 K3 = 0.01,		//...heat conduction (intermediate);
				 //K1 = 1.113,	//...heat conduction (matrix);
				 //K2 = 2.954,	//...heat conduction (inclusion);
				 //K3 = 0.111,	//...heat conduction (intermediate);
				 //R1 = rr = sqrt(var*.01/M_PI),	//...inclusion geometry;
				 R1 = 0.3,								//...inclusion geometry;
				 R2 = 0.4+var*.01;					//...intermediate geometry; 
		sm->set_fasa_hmg(R1, R2, K1, K2, K3);

///////////////////////////
//...solving of the probem;
		if (sm->computing_kernel(PERIOD_COMPUT/*BASIC_COMPUT*/) != OK_STATE) {
			Message("Error in sample computing...");
			delete sm;
			delete nd;

			goto err;
		}
#ifdef ___MPI_INIT___
	if (sm->solver.id_change == EXTERN_STATE) {
			CSlvParam params;
			params.msglev = 3;
			params.ittype = 2;
			params.sttype = 1;
			params.niter = 700;
			params.eps = 1.0e-9;

			params.tau1 = 1.0e-2;
			params.tau2 = 1.0e-3;
			params.theta = 0.10e0;

			char strbuff[256];
			sprintf (strbuff,"%s%i%s","BsSolver_",comm_mpi.GetMyid(),".dat");

			std::ofstream fout (strbuff);

			sm->shapes_init(NO_STATE); 
			BCM_draft<double> pBCM = {sm, PERIOD_COMPUT};
			//AbstractSolver		(& pBCM, 
			AbstractParSolver (& pBCM, 
									(void *)&comm_mpi,
									fout, params,
									Number_of_Blocks<double>, Blocks_Partitioning<double>, 
									Blocks_Sparsity<double>, Blocks_Row<double>, 
									Right_Handside<double>, Initial_Guess<double>, Store_Solution<double>);
			sm->shapes_init(OK_STATE); 
		}
#endif

///////////////////
//..homogenization;
#ifdef ___MPI_INIT___
		if (comm_mpi.GetMyid() == 0) 
#endif
		{
			double par[6];	sm->SetGeomBounding(par);
			double K[6] = {0.,0.,0.,0.,0.,(par[1]-par[0])*.5}, KH, kk, kk_low, kk_max, ff, ff_l;

			sm->GetRigidy(K, -1, BASIC_COMPUT);
			sm->GetRigidy(K, -1, COVERING_COMPUT);

			//K[3] = M_PI*R1*R1;      
			//if (K[5] < R2)
			//K[4] = R2*R2*(M_PI-4.*acos(K[5]/R2))+4.*K[5]*sqrt(R2*R2-K[5]*K[5])-K[3]; else
			//K[4] = M_PI*R2*R2-K[3];
			//K[2] = 1.-K[3]-K[4];  

			ff		 =  K[3]/(K[2]+K[3]+K[4]); //...объёмная доля включений;
			ff_l	 =  K[4]/(K[2]+K[3]+K[4]); //...объёмная доля межфазного слоя;
			kk		 =  K[0]/(K[2]+K[3]+K[4]);
			kk_low = (K[2]+K[3]+K[4])/(K[2]/K1+K[3]/K2+K[4]/K3);
			kk_max = (K[2]*K1+K[3]*K2+K[4]*K3)/(K[2]+K[3]+K[4]);

			KH = sm->TakeEshelby(ff, ff_l);

			TST = fopen(buff, "a"); //if (R2 > 0.5 || R1 < 0.) kk = -111.;
			fprintf(TST, "KD = %g  Kl = %g  ff = %g  ff_vol = %g  kk = %g  KH = %g  kk_low = %g  kk_max = %g (%g  %g)\n", K2, K3, ff, ff+ff_l, kk, KH, kk_low, kk_max, R1, R2);
			fclose (TST);

//////////////////
//..visualization;
			int id_visual = 1;
			if (id_visual) {
				nd->zero_grid();

				sm->BlockActivate(NULL_STATE);

				int NX = 100, NY = 100;
				for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
				for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

				nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

				system("del *.grd");
				//sm->GetSurferFormat("bb", nd,         ERR_VALUE, 0);
				sm->GetSurferFormat("rr", nd,        HEAT_VALUE, 0);
				sm->GetSurferFormat("pp", nd, FLUX_COMPOS_VALUE, 0);
			}
		}
	}
	delete sm;
	delete nd;
}
#endif
#ifdef TEST_DRAFT_LAME2D_INTERMEDIATE_PHASE
{
	char * name = "./Box2d_homog/heat_clayer488.nas";
	//char * name = "./Box2d_homog/heat_cyl_layer1148.nas";
	//char * name = "./Box2d_homog/heat_ell_layer1174.nas";
	//char * name = "./Box2d_homog/sph_025_16.nas";
	//char * name = "./Parametric/Unit2d_16.nas";
	int  i, j, l;
	double X0, Y0, ell_X = 0., ell_Y = 0., rot_Z;

//////////////////////////////////
//...reading model from data-file;
	CDraft<double> * sm = CreateDraftR(LAME2D_DRAFT);
	sm->set_mpls(PackInts(5, 5));//...space degree of multipoles;
	sm->set_quad(PackInts(4, 2)); //...N_elem, N_max -- parameters of quadrature;
	sm->set_normaliz(0.92);			//...normalization coefficient;
	sm->set_lagrange(1e5);			//...Lagrange coefficient for energy;
	sm->change_solv(/*PERIODIC_SOLVING*/);
	sm->solver.change_state(/*EXTERN_STATE*/);
	sm->solver.set_mode(/*REGULARIZATION*//*PRINT_MODE*//*FULLY_MODE*/);
	yes = 0;

///////////////////////////
//...parameters of problem;
	double nju1 = 0.300,  //...ледяная матрица; 
			 nju2 = 0.100,  //...минеральная частица (песок); 
			 nju3 = 0.499,  //...вода; 
			 G1   = 6.0/(1.+nju1)*.5,	//...ледяная матрица (GPa);
			 G2   = 50./(1.+nju2)*.5,	//...включение (песок, GPa); 
			 G3   = 1e-0/*5*//(1.+nju3)*.5; //...межазный слой (вода, GPa); 
	sm->set_fasa_hmg(nju1, nju2, nju3, G1, G2, G3);

//////////////////////////////////
//...reading model from data-file;
	CGrid * nd = CreateNodes();
	if (nd && sm) {
      sprintf(buf, "Loading model from file '%s'", name);
      Message(" ");
      Message(buf);
      Message("Reading data file ...");

		sm->stru.nodes_in(name);
		sm->bar_condit_in(name);
		sm->LinkUniStruct();
		sm->SetBUniStruct(POLY_BLOCK);

/////////////////////////////////////
//...reading parameters of inclusion;
		if (sm->id_prop && sm->pp_cond)
		for (j = 0; j < sm->id_prop[0]; j++)
		if (sm->id_prop[j*2+2] == BSOURCE_BND) {
			X0		= sm->pp_cond[j*6]; 
			Y0		= sm->pp_cond[j*6+1];
			ell_X = sm->pp_cond[j*6+2];
			ell_Y = sm->pp_cond[j*6+3];
			rot_Z = sm->pp_cond[j*6+4];
			break;
		}
		if (ell_X != 0. && ell_Y != 0. && 0) {
			CCells * ce = new(CCells);
			ce->cells_new(1, 2, (l = size_of_map(1, CYL_GENUS))+1);
			ce->mp[0] = (CMap)ID_MAP(1, CYL_GENUS);
			ce->mp[1] = X0;
			ce->mp[2] = Y0;
			ce->mp[4] = rot_Z/180.*M_PI;
			ce->mp[7] = ell_X;
			ce->mp[8] = ell_Y;
			ce->mp[l] = (CMap)NULL_CELL;
			sm->bar = new(CCells);
			sm->bar->bar_add(ce);
		}
		Message("Finish!");
	}

///////////////////////////
//...solving of the probem;
		if (sm->computing_kernel(MAPPING_COMPUT) != OK_STATE) {
			Message("Error in sample computing...");
			//delete sm;
			//delete nd;

			//goto err;
		}
#ifdef ___MPI_INIT___
	if (sm->solver.id_change == EXTERN_STATE) {
			CSlvParam params;
			params.msglev = 3;
			params.ittype = 2;
			params.sttype = 1;
			params.niter = 700;
			params.eps = 1.0e-9;

			params.tau1 = 1.0e-2;
			params.tau2 = 1.0e-3;
			params.theta = 0.10e0;

			char strbuff[256];
			sprintf (strbuff,"%s%i%s","BsSolver_",comm_mpi.GetMyid(),".dat");

			std::ofstream fout (strbuff);

			sm->shapes_init(NO_STATE); 
			BCM_draft<double> pBCM = {sm, MAPPING_COMPUT};
			//AbstractSolver		(& pBCM, 
			AbstractParSolver (& pBCM, 
									(void *)&comm_mpi,
									fout, params,
									Number_of_Blocks<double>, Blocks_Partitioning<double>, 
									Blocks_Sparsity<double>, Blocks_Row<double>, 
									Right_Handside<double>, Initial_Guess<double>, Store_Solution<double>);
			sm->shapes_init(OK_STATE); 
		}
#endif

//////////////////
//..visualization;
	double lambda = 0., RoC = 0., low_lambda = 0.;
#ifdef ___MPI_INIT___
	if (comm_mpi.GetMyid() == 0) 
#endif
	{
		double par[6];	sm->SetGeomBounding(par);
/*		double K[8];
		sm->GetRigidy(K, SPECIAL2COUNTING);

		f_vol	 = K[7]/((par[1]-par[0])*(par[3]-par[2])*(par[5]-par[4]));
		RoC	 = K[5]+(K[6]-K[5])*f_vol;
		lambda = K[2]/((par[1]-par[0])*(par[3]-par[2])*(par[5]-par[4]));
		low_lambda = 1./(1./K[3]+(1./K[4]-1./K[3])*f_vol);

		TST = NULL; OPEN_DEVICE(TST, "homog_15_3D.dat", "a");
		fprintf(TST, "%g    %g    %g    %g     %g\n", kappa, f_vol, lambda, low_lambda, RoC);
		fclose (TST);
/**/
		int id_visual = ! sm->solver.mode(TESTI_MODE) || 1;
		if (id_visual && 1) {//..visualization;
			nd->zero_grid();

			sm->BlockActivate(NULL_STATE);

			int NX = 100, NY = 100;
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

			for (i = 0; i < nd->N;  i++)
			for (j = 0; j < nd->N1; j++) {
				int hit = -1;
				sm->Poly_struc_in2D (hit, nd->X[i], nd->Y[j]);
				sm->StructEllCorrect(hit, nd->X[i], nd->Y[j]);
				nd->hit[i+j*nd->N] = hit;
			}
			if (! sm->solver.mode(TESTI_MODE)) 
			system("del *.grd");

			sm->GetSurferFormat("bb", nd,       ERR_VALUE, 0);
			sm->GetSurferFormat("rx", nd,     DISPL_VALUE, 0);
			sm->GetSurferFormat("ry", nd,     DISPL_VALUE, 1);
			sm->GetSurferFormat("tx", nd,  STRESS_X_VALUE, 0);
		}
	}
	delete sm;
	delete nd;
}
#endif
#ifdef TEST_DRAFT_LAME3D_INTERMEDIATE_PHASE
{
	double AX = 1., AY = 1., AZ = 1., rad = 0.0895, ll = 0.08;
	int i, j;

//////////////////////////
//...model initialization;
	CDraft<double> * sm = CreateDraftR(LAME3D_DRAFT/*COHES3D_DRAFT*/, 8);
	sm->set_mpls(PackInts(13, 9));//...space degree of multipoles;
	sm->set_quad(PackInts(8, 4)); //...N_elem, N_max -- parameters of quadrature;
	sm->set_normaliz(0.92);			//...normalization coefficient;
	sm->change_solv(SPECIAL_SOLVING);
	sm->solver.change_state(/*EXTERN_STATE*/);
	sm->solver.set_mode(/*PRINT_MODE*//*FULLY_MODE*/);
	yes = 0;

//////////////////////
//...параметры задачи;
	double nj1 = 0.33, //...полимерная матрица; 
			 nj2 = 0.20, //...графитовое включение; 
			 nj3 = 0.30, //...межфазный слой; 
			 E1  = 18.,  //...GPa;
			 E2  = 380., //...GPa; 
			 E3  = 57.5, c0, c1, par[6]; 
	sm->set_fasa_hmg(rad, rad+ll, nj2, nj3, nj1, E2/(1.+nj2)*.5, E3/(1.+nj3)*.5, E1/(1.+nj1)*.5);

///////////////////////////////
//...цикл по параметрам задачи;
	int n_var;
	res = system("mkdir var1_results");
	for (rad = 0., c0 = 0., c1 = 0.4, n_var = 10; n_var <= 10; n_var++) {
		E2 = E1 +10.*n_var;
		sm->set_fasa_hmg(rad, rad+ll, nj2, nj3, nj1, E2/(1.+nj2)*.5, E3/(1.+nj3)*.5, E1/(1.+nj1)*.5);

		//rad = pow(.75/M_PI*(c0 = j*.1), 1./3.); ll = rad-pow(.75/M_PI*c0*c1, 1./3.); 
		//AX = AY = AZ = (rad = 0.037)/pow(.75/M_PI*(c0 = 0.00272), 1./3.); ll = 3.*rad;
		rad = pow(.75/M_PI*(c0 = 0.003), 1./3.); ll = 4.*rad;
		sm->set_geometry(rad, ll);

///////////////////////
//...геометрия области;
		sm->GetSphBoxStruct(AX, AY, AZ, rad, ll);
		par[0] = -AX*.5; par[2] = -AY*.5; par[4] = -AZ*.5;
		par[1] =  AX*.5; par[3] =  AY*.5; par[5] =  AZ*.5;

///////////////////////////
//...solving of the probem;
		if (sm->computing_kernel(PERIOD_COMPUT) != OK_STATE) {
			Message("Error in sample computing...");
			delete sm;
			goto err;
		}

///////////////////////////////////////////////////////////////////////
//..вычисляем осредненные характеристики (модуль Юнга и модуль сдвига);
		double K[28], E0, K0, nu, mu, C0, lm, ff_vol, ll_vol; memset(K, 0, 28*sizeof(double)); K[27] = AX*.5;
		sm->GetRigidy(K, -1, BASIC_COMPUT);
		sm->GetRigidy(K, -1, COVERING_COMPUT);

		ff_vol = K[25]/(K[24]+K[25]+K[26]);
		ll_vol = K[26]/(K[24]+K[25]+K[26]);

		C0 = (K[5]-2.*K[0]*K[6]/(K[6]+K[11]))/(K[11]-2.*K[6]*K[6]/(K[6]+K[11]));
		lm = (K[0]-C0*K[6])/(K[6]+K[11]);
		nu = lm/(C0+lm);
		E0 = (C0-lm)*(C0+2.*lm)/(C0+lm);
		K0 = E0/(3.*(1.-2.*nu));
		mu = K[15]/K[21]*.5;

		FILE  * TST = fopen("var1_results/lame3d_homog.dat", "a");
		fprintf(TST, "ff_vol+ll_vol = %g  K0 = %g  E0 = %g  mu = %g  nu = %g (%g, %g, %g, %g, %g, %g, %g)\n", 						 
						  ff_vol+ll_vol, K0, E0, mu, nu, rad, E2, E3, E1, nj2, nj3, nj1);
		fclose (TST);

//////////////////////////////////////////////////////////////
//..тестируем поверхностные значения на границе фаз материала;
	int id_testin = 0;
	if (id_testin) {
		extern int forced_phase;
		CGrid * nd = CreateNodes();
		int NX = 40, NY = 40;
		for (i = 0; i <= 2*NX; i++) 
		for (j = 0; j <= 2*NY; j++) {
			double Co = cos((M_PI*i)/NX*.5+M_PI*.25),
					 Si = sin((M_PI*i)/NX*.5+M_PI*.25),
					 C2 = cos((M_PI*j)/NY+M_PI*.25),
					 S2 = sin((M_PI*j)/NY+M_PI*.25), fff = rad;
			nd->add_new_point(fff*Si*C2, fff*Si*S2, fff*Co, Si*C2, Si*S2, Co);
		}
		double out_F[3], sum[3], eps = 1e-12, 
				 uu_resi_R1 = 0., uu_resi_R2 = 0., pn_resi_R1 = 0., pn_resi_R2 = 0., dd; forced_phase = -1;
		FILE * TST = fopen("uu_resi_R1.dat", "w");
		for (i = 1; i < nd->N; i++) {
			sm->GetFuncAllValues (nd->X[i], nd->Y[i], nd->Z[i], sum,   0, DISPL_VALUE); forced_phase =  0;
			sm->GetFuncAllValues (nd->X[i], nd->Y[i], nd->Z[i], out_F, 0, DISPL_VALUE); forced_phase = -1;
			fprintf(TST, " %i  %g  %g  %g  (norm = %g)\n", i, 
				filtr_(out_F[0]-sum[0], eps), filtr_(out_F[1]-sum[1], eps), 
				filtr_(out_F[2]-sum[2], eps), sqrt(sqr(sum[0])+sqr(sum[1])+sqr(sum[2])));
			if (uu_resi_R1 < (dd = sqrt(sqr(out_F[0]-sum[0])+sqr(out_F[1]-sum[1])+sqr(out_F[2]-sum[2])))) uu_resi_R1 = dd;
		}
		fclose(TST);

		TST = fopen("pn_resi_R1.dat", "w");
		for (i = 0; i < nd->N; i++) {
			sm->GetFuncAllValues (nd->X[i], nd->Y[i], nd->Z[i], sum,   0, STRESS_R_VALUE); forced_phase =  0;
			sm->GetFuncAllValues (nd->X[i], nd->Y[i], nd->Z[i], out_F, 0, STRESS_R_VALUE); forced_phase = -1;
			fprintf(TST, " %i  %g  %g  %g  (norm = %g)\n", i, 
				filtr_(out_F[0]-sum[0], eps), filtr_(out_F[1]-sum[1], eps), 
				filtr_(out_F[2]-sum[2], eps), sqrt(sqr(sum[0])+sqr(sum[1])+sqr(sum[2])));
			if (pn_resi_R1 < (dd = sqrt(sqr(out_F[0]-sum[0])+sqr(out_F[1]-sum[1])+sqr(out_F[2]-sum[2])))) pn_resi_R1 = dd;
		}
		fclose(TST);
		nd->zero_grid();
		for (i = 0; i <= 2*NX; i++) 
		for (j = 0; j <= 2*NY; j++) {
			double Co = cos((M_PI*i)/NX*.5),
					 Si = sin((M_PI*i)/NX*.5),
					 C2 = cos((M_PI*j)/NY),
					 S2 = sin((M_PI*j)/NY), fff = rad+ll;
			nd->add_new_point(fff*Si*C2, fff*Si*S2, fff*Co, Si*C2, Si*S2, Co);
		}
		TST = fopen("uu_resi_R2.dat", "w");
		forced_phase = -1;
		for (i = 0; i < nd->N; i++) {
			sm->GetFuncAllValues (nd->X[i], nd->Y[i], nd->Z[i], sum,   0, DISPL_VALUE); forced_phase =  1;
			sm->GetFuncAllValues (nd->X[i], nd->Y[i], nd->Z[i], out_F, 0, DISPL_VALUE); forced_phase = -1;
			fprintf(TST, " %i  %g  %g  %g  (norm = %g)\n", i, 
				filtr_(out_F[0]-sum[0], eps), filtr_(out_F[1]-sum[1], eps), 
				filtr_(out_F[2]-sum[2], eps), sqrt(sqr(sum[0])+sqr(sum[1])+sqr(sum[2])));
			if (uu_resi_R2 < (dd = sqrt(sqr(out_F[0]-sum[0])+sqr(out_F[1]-sum[1])+sqr(out_F[2]-sum[2])))) uu_resi_R2 = dd;
		}
		fclose(TST);

		TST = fopen("pn_resi_R2.dat", "w");
		for (i = 0; i < nd->N; i++) {
			sm->GetFuncAllValues (nd->X[i], nd->Y[i], nd->Z[i], sum,   0, STRESS_R_VALUE); forced_phase =  1;
			sm->GetFuncAllValues (nd->X[i], nd->Y[i], nd->Z[i], out_F, 0, STRESS_R_VALUE); forced_phase = -1;
			fprintf(TST, " %i  %g  %g  %g  (norm = %g)\n", i, 
				filtr_(out_F[0]-sum[0], eps), filtr_(out_F[1]-sum[1], eps), 
				filtr_(out_F[2]-sum[2], eps), sqrt(sqr(sum[0])+sqr(sum[1])+sqr(sum[2])));
			if (pn_resi_R2 < (dd = sqrt(sqr(out_F[0]-sum[0])+sqr(out_F[1]-sum[1])+sqr(out_F[2]-sum[2])))) pn_resi_R2 = dd;
		}
		fclose(TST);
		delete nd;
		forced_phase = -777;
		TST = fopen("all_resi.dat", "w");
		fprintf(TST, " uu_resi_R1 =  %g  pn_resi_R1 =  %g\n uu_resi_R2 =  %g  pn_resi_R2 =  %g\n", \
							uu_resi_R1, pn_resi_R1, uu_resi_R2, pn_resi_R2); 
		fclose(TST);
	}

//////////////////
//..visualization;
	int id_visual = 1;
	if (id_visual) {
		CGrid * nd = CreateNodes();
		int NX = 200, NY = 200, axis = AXIS_Y, alpha = 0;

		if (axis == AXIS_Z) {
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->add_new_point_Z(par[4]+(par[5]-par[4])*(1.+alpha)*.5);
			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
		}
		if (axis == AXIS_Y) {
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);

			nd->add_new_point_Z(par[2]+(par[3]-par[2])*(1.+alpha)*.5);
			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
		}
		if (axis == AXIS_X) {
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);

			nd->add_new_point_Z(par[0]+(par[1]-par[0])*(1.+alpha)*.5);
			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
		}
		for (i = 0; i < nd->N;  i++)
		for (j = 0; j < nd->N1; j++) {
			if (rad == 0.) nd->hit[i+j*nd->N] = 0; else
			if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad))    nd->hit[i+j*nd->N] = 0; else  
			if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad+ll)) nd->hit[i+j*nd->N] = 2; else	nd->hit[i+j*nd->N] = 1;	
		}
		//system("del *.grd");
		sm->GetSurferFormat("var1_results/rz", nd,		DISPL_VALUE, 0, axis);
		sm->GetSurferFormat("var1_results/tz", nd, STRESS_Z_VALUE, 0, axis);

		delete nd;
	   }
	}
	delete sm;

}
#endif
#ifdef TEST_DRAFT_HYDRO3D_INTERMEDIATE_PHASE
{
	double par[6], k0 = 0., rad = 0.3, AX = 1., AY = 1., AZ = 1., fm = 1., ff_vol = 0.99;
	int i, j, k, m, num;

////////////////////////////
//...преобразование образца;
	CDraft<double> * sm = CreateDraftR(HYDRO3D_DRAFT, 8);
	sm->set_fasa_hmg(k0);			//...Brinkman's coefficient; 
	sm->set_mpls(PackInts(3, 3)); //...space degree of multipoles;
	sm->set_quad(PackInts(4, 2)); //...N_elem, N_max -- parameters of quadrature;
	sm->change_solv(SPECIAL_SOLVING);
	sm->solver.change_state(/*EXTERN_STATE*/);
	sm->solver.set_mode(PRINT_MODE/* | FULLY_MODE*/);
	yes = 0;

	for (int iii = 10; iii < 11; iii += 1) {
		rad = iii*.01;

		//AX = (AY = sqrt((ff = iii*.01)*fm))/fm;

		if (rad <= AX*.5)
		sm->GetSphBoxStruct(AX, AX, AX, rad, 0., OK_STATE); else
		sm->GetPenetrateSphere(rad,  AX*.5);
		sm->SetBUniStruct(CLAYER_BLOCK, ERR_GENUS);
		sm->set_geometry (rad);
	   par[0] = -AX*.5; par[2] = -AY*.5; par[4] = -AZ*.5;
		par[1] =  AX*.5; par[3] =  AY*.5; par[5] =  AZ*.5;

		//sm->GetCylSphStruct(ff_vol, rad, OK_STATE);
		//sm->SetBUniStruct(CLAYER_BLOCK);
		//par[0] = -sm->B[sm->N-1].mp[7]; par[2] = par[0]; par[4] = par[0];
		//par[1] =  sm->B[sm->N-1].mp[7]; par[3] = par[1]; par[5] = par[1];
		//par[0] = -sm->B[sm->N-1].mp[7]*M_SQRT_2/sm->get_param(sm->NUM_MPLS+1); par[2] = par[0]; par[4] = par[0];
		//par[1] =  sm->B[sm->N-1].mp[7]*M_SQRT_2/sm->get_param(sm->NUM_MPLS+1); par[3] = par[1]; par[5] = par[1];

/////////////////////////////////////////
//...задание граничных значений в модели;
		int id_action = 0;
		if (id_action) {
			double pp[6] = { 0., 0., 0., 0., 0., 0.},
					 po[6] = { 1., 0., 0., 0., 0., 0.};

			for (k = 0; k < sm->N; k++) 
			LOOP_FACET(sm->B[k].bar, num, m) {
				sm->B[k].bar->SetFacetXParam(num, par[0], pp, ADHESION_BND);
				sm->B[k].bar->SetFacetXParam(num, par[1], pp, ADHESION_BND);

				sm->B[k].bar->SetFacetYParam(num, par[2], pp, ADHESION_BND);
				sm->B[k].bar->SetFacetYParam(num, par[3], pp, ADHESION_BND);

				sm->B[k].bar->SetFacetZParam(num, par[4], po, PRESSURE_BND);
				sm->B[k].bar->SetFacetZParam(num, par[5], pp, PRESSURE_BND);
			}
		}

///////////////////////////
//...solving of the probem;
		if (sm->computing_kernel(PERIOD_COMPUT/*BASIC_COMPUT*//*SPECIAL_COMPUT*/) != OK_STATE) {
			Message("Error in sample computing...");
			delete sm;
			goto err;
		}

////////////////////////////////////////////////////////////////
//..вычисляем осредненные характеристики (тензор проницаемости);
		double K[4], nn, nn_cyl, nn_l; memset(K, 0, 4*sizeof(double));
		sm->GetRigidy(K, -1,  BASIC_COMPUT); 	

		//ff_vol = K[3]/(AX*AY*AZ);
		//if (AX*.5 > rad)
		//ff_vol = 1.-4./3.*M_PI*rad/AX*rad/AY*rad/AZ; else
		//ff_vol = 1.-2.*M_PI*(3.*rad/AY*rad/AZ*.5-.125-4./3.*rad/AX*rad/AY*rad/AZ);
		//nn = G0*K[2]/(AX*AY*AZ);

		nn = K[2]/K[3];
		ff_vol = 4./3.*M_PI*(par[1]*sqr(par[1])-rad*sqr(rad));

		//memset(K, 0, 4*sizeof(double)); sm->GetRigidy(K, -1,  VOLUME_COUNTING); 	
		//nn = G0*K[2]/K[3];

 		nn_cyl = sqr(ff_vol)/(8.*M_PI);
		nn_l = sqr(ff_vol)*ff_vol/12.;

		FILE  * TST = fopen("hydro3D_homog.dat", "a");
		fprintf(TST, "ff_vol = %g  nn = %g  nn_cyl = %g  nn_l = %g  (AX = %g  AY = %g  k0 = %g)\n", ff_vol, nn, nn_cyl, nn_l, AX, AY, k0);
		fclose (TST);

//////////////////////////////////////////
//..тестируем граничные значения на сфере;
		int id_testin = 0;
		if (id_testin) {
			CGrid * nd = CreateNodes();
			int NX = 40, NY = 40;
			for (i = 0; i <= 2*NX; i++) 
			for (j = 0; j <= 2*NY; j++) {
				double Co = cos((M_PI*i)/NX*.5+M_PI*.25),
						 Si = sin((M_PI*i)/NX*.5+M_PI*.25),
						 C2 = cos((M_PI*j)/NY+M_PI*.25),
						 S2 = sin((M_PI*j)/NY+M_PI*.25);
				nd->add_new_point(rad*Si*C2, rad*Si*S2, rad*Co, Si*C2, Si*S2, Co);
			}
			double out_F[3], eps = 1e-12, vv_resi_R0 = 0., dd;
			FILE * TST = fopen("vv_resi_R0.dat", "w");
			for (i = 1; i < nd->N; i++) {
				sm->GetFuncAllValues (nd->X[i], nd->Y[i], nd->Z[i], out_F, 0, VELOCITY_VALUE);
				fprintf(TST, " %i  %g  %g  %g  (norm = %g)\n", i, 
					filtr_(out_F[0], eps), filtr_(out_F[1], eps), 
					filtr_(out_F[2], eps), sqrt(sqr(out_F[0])+sqr(out_F[1])+sqr(out_F[2])));
				if (vv_resi_R0 < (dd = sqrt(sqr(out_F[0])+sqr(out_F[1])+sqr(out_F[2])))) vv_resi_R0 = dd;
			}
			fclose(TST);
			delete nd;
			TST = fopen("all_resi.dat", "w");
			fprintf(TST, " vv_resi_R0 =  %g", vv_resi_R0); 
			fclose(TST);
		}

//////////////////
//..visualization;
		int id_visual = 1;
		if (id_visual) {
			CGrid * nd = CreateNodes();
			int NX = 100, NY = 100, axis = AXIS_Y; double alpha = 0;

			if (axis == AXIS_Z) {
				for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
				for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

				nd->add_new_point_Z(par[4]+(par[5]-par[4])*(1.+alpha)*.5);
				nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
			}
			if (axis == AXIS_Y) {
				for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
				for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);

				nd->add_new_point_Z(par[2]+(par[3]-par[2])*(1.+alpha)*.5);
				nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
			}
			if (axis == AXIS_X) {
				for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
				for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);

				nd->add_new_point_Z(par[0]+(par[1]-par[0])*(1.+alpha)*.5);
				nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
			}
			//for (i = 0; i < nd->N;  i++)
			//for (j = 0; j < nd->N1; j++) 
			//if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad) ||
			//	 sqr(nd->X[i]-1.)+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad) ||
			//	 sqr(nd->X[i]-1.)+sqr(nd->Y[j]-1.)+sqr(nd->Z[0]) < sqr(rad) ||
			//	 sqr(nd->X[i])+sqr(nd->Y[j]-1.)+sqr(nd->Z[0]) < sqr(rad) ||
			//	 sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]-1.) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
			for (i = 0; i < nd->N;  i++)
			for (j = 0; j < nd->N1; j++) 
				if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad) /*||
					 sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) > sqr(par[0])*/) nd->hit[i+j*nd->N] = -1;

			system("del *.grd");
			//sm->GetSurferFormat("bb", nd,		  ERR_VALUE, 0, axis);
			sm->GetSurferFormat("pp", nd,	PRESSURE_VALUE, 0, axis);
			sm->GetSurferFormat("vv", nd, VELOCITY_VALUE, 0, axis);

//////////////////////////////
//...дополнительная плоскость;
			for (i = 0; i <= 2*NX; i++) nd->X[i] = (.5*i/NX*(par[1]-par[0])+par[0]);
			for (j = 0; j <= 2*NY; j++) nd->Y[j] = (.5*j/NY*(par[3]-par[2])+par[2]);
			nd->Z[0] = (par[4]+(par[5]-par[4])*(1.+alpha)*.5);
			for (i = 0; i < nd->N;  i++)
			for (j = 0; j < nd->N1; j++) 
				if (sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad) ||
				 sqr(nd->X[i]-1.)+sqr(nd->Y[j])+sqr(nd->Z[0]) < sqr(rad) ||
				 sqr(nd->X[i]-1.)+sqr(nd->Y[j]-1.)+sqr(nd->Z[0]) < sqr(rad) ||
				 sqr(nd->X[i])+sqr(nd->Y[j]-1.)+sqr(nd->Z[0]) < sqr(rad) ||
				 sqr(nd->X[i])+sqr(nd->Y[j])+sqr(nd->Z[0]-1.) < sqr(rad)) nd->hit[i+j*nd->N] = -1;
				else																		 nd->hit[i+j*nd->N] =  0;
			//sm->GetSurferFormat("pp_dop", nd, PRESSURE_VALUE, 0, AXIS_Z);
			//sm->GetSurferFormat("vv_dop", nd, VELOCITY_VALUE, 0, AXIS_Z);

			delete nd;
		}
	}
	delete sm;
}
#endif
#ifdef TEST_DRAFT_HEAT2D_FROM_FEMAP
{
	//const char * name = "../Exe/Box2d_homog/sph_025_16.nas";
	//const char * name = "../Exe/Box2d_homog/ell_80_20q4.nas";
	//const char * name = "../Exe/Box2d_homog/ell_20_80_i.nas";
	const char * name = "../Exe/Box2d_homog/ell_80_20_i_1980.nas";
	//const char * name = "../Exe/Box2d_homog/heat_clayer488.nas";
	//const char * name = "../Exe/Parametric/Unit2d_16.nas";
	double par[6], X0, Y0, ell_X, ell_Y, rot_Z, id_reading = 0;
	int j, k, l, m, num, res;

//////////////////////
//...параметры модели;
	CDraft<double> * sm = CreateDraftR(HEAT2D_DRAFT, 8);
	sm->set_fasa_hmg(1., 2.);		  //...модуль теплопроводности; 
	sm->set_mpls(PackInts(4, 4));   //...space degree of multipoles;
	sm->set_quad(PackInts(8, 8));   //...N_elem, N_max -- parameters of quadrature;
	sm->set_normaliz(0.92);			  //...normalization coefficient;
	sm->set_lagrange(1e5);			  //...Lagrange coefficient; 
	sm->change_solv(PERIODIC_SOLVING);
	sm->solver.change_state(EXTERN_STATE);
	sm->solver.set_mode(REGUL_BOUNDARY/* | PRINT_MODE | NODES_PRINT | FULLY_MODE*/);
	yes = 0;

///////////////////////////////////////////////////////
//...чтение модели и граничных условий из файла данных;
	if (sm) {
		Message(" ");
		sprintf(buf, "Loading model from file '%s'", name);
		Message(buf);
		Message("Reading data file ...");

		sm->stru.nodes_in(name);
      sm->bar_condit_in(name);
		sm->LinkUniStruct();
		sm->SetBUniStruct(POLY_BLOCK);
		sm->SetGeomBounding(par);

		if (sm->id_prop && sm->pp_cond)//...reading parameters of inclusion;
		for (j = 0; j < sm->id_prop[0]; j++)
		if (sm->id_prop[j*2+2] == BSOURCE_BND) {
			X0		= sm->pp_cond[j*6]; 
			Y0		= sm->pp_cond[j*6+1];
			ell_X = sm->pp_cond[j*6+2];
			ell_Y = sm->pp_cond[j*6+3];
			rot_Z = sm->pp_cond[j*6+4];
			id_reading = 1;
			break;
		}
		Message("Finish!");
	}
	if (id_reading && ell_X != 0. && ell_Y != 0.) {
		CCells * ce = new(CCells);
		ce->cells_new(1, 2, (l = size_of_map(1, CYL_GENUS))+1);
		ce->mp[0] = (CMap)ID_MAP(1, CYL_GENUS);
		ce->mp[1] = X0;
		ce->mp[2] = Y0;
		ce->mp[4] = rot_Z/180.*M_PI;
		ce->mp[7] = ell_X;
		ce->mp[8] = ell_Y;
		ce->mp[l] = (CMap)NULL_CELL;
		sm->bar = new(CCells);
		sm->bar->bar_add(ce);
	}

/////////////////////////////////////////
//...задание граничных значений в модели;
	int id_action = 0;
	if (id_action) {
		double pp[6] = { 1., 0., 0., 0., 0., 0.},
				 po[6] = { 0., 0., 0., 0., 0., 0.};
		sm->BlockActivate();
		for (k = 0; k < sm->N; k++) 
		LOOP_FACET(sm->B[k].bar, num, m) {
			sm->B[k].bar->SetFacetXParam(num, par[0], po, RIGID_BND);
			sm->B[k].bar->SetFacetXParam(num, par[1], po, RIGID_BND);

			sm->B[k].bar->SetFacetYParam(num, par[2], po, RIGID_BND);
			sm->B[k].bar->SetFacetYParam(num, par[3], po, RIGID_BND);

			sm->B[k].bar->SetFacetZParam(num, par[4], pp, FORCEN_BND);
			sm->B[k].bar->SetFacetZParam(num, par[5], po, DISPLN_BND);
		}
	}

////////////////////////////
//...solving of the problem;
	res = system("mkdir ./bcm_results/heat2d_homog");
	if (sm->computing_kernel(MAPPING_COMPUT) != OK_STATE) {
		Message("Error in sample computing...");
		delete sm;
		goto err;
	}
#ifdef ___MPI_INIT___
	if (sm->solver.id_change == EXTERN_STATE) {
			CSlvParam params;
			params.msglev = 3;
			params.ittype = 2;
			params.sttype = 1;
			params.niter = 700;
			params.eps = 1.0e-9;

			params.tau1 = 1.0e-2;
			params.tau2 = 1.0e-3;
			params.theta = 0.10e0;

			char strbuff[256];
			sprintf (strbuff,"%s%i%s","BsSolver_",comm_mpi.GetMyid(),".dat");

			std::ofstream fout (strbuff);

			sm->shapes_init(NO_STATE); 
			BCM_draft<double> pBCM = {sm, MAPPING_COMPUT};
			AbstractParSolver (& pBCM, 
									(void *)&comm_mpi,
									fout, params,
									Number_of_Blocks<double>, Blocks_Partitioning<double>, 
									Blocks_Sparsity<double>, Blocks_Row<double>, 
									Right_Handside<double>, Initial_Guess<double>, Store_Solution<double>);
			sm->shapes_init(OK_STATE); 
		}
#endif

//////////////////
//..visualization;
#ifdef ___MPI_INIT___
	if (comm_mpi.GetMyid() == 0) 
#endif
	{
		int id_visual = 1;
		if (id_visual) {//..visualization;
			CGrid * nd = CreateNodes();
			int NX = 300, NY = 300;

			sm->BlockActivate(NULL_STATE);

			for (int i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (int j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

			int hit = ERR_STATE;
			for (int i = 0; i < nd->N;  i++)
			for (int j = 0; j < nd->N1; j++) {
				sm->Poly_struc_in2D(hit, nd->X[i], nd->Y[j]);
				sm->StructEllCorrect(hit, nd->X[i], nd->Y[j]);
				nd->hit[i+j*nd->N] = hit;
			}
			sm->GetSurferFormat("./bcm_results/heat2d_homog/bb", nd,	 ERR_VALUE);
			sm->GetSurferFormat("./bcm_results/heat2d_homog/rr", nd,	HEAT_VALUE);
			sm->GetSurferFormat("./bcm_results/heat2d_homog/pp", nd, FLUX_VALUE);
			delete nd;
		}
	}
	delete sm;
}
#endif
#ifdef TEST_DRAFT_HEAT3D_FROM_FEMAP
{
	const char * name = "../Exe/Box3d_homog/sph_025_octa.nas";
	//const char * name = "../Exe/Box3d_homog/sph_025_full.nas";
	//const char * name = "../Exe/Box3d_homog/sph_025th1.nas";
	//const char * name = "../Exe/Box3d_homog/nano_35x25x246_octa.nas";
	//const char * name = "../Exe/Parametric/Unit3d_001.nas";
	double par[6];
	int i, j, k, m, num;

//////////////////////
//...параметры модели;
	CDraft<double> * sm = CreateDraftR(HEAT3D_DRAFT, 8);
	sm->set_fasa_hmg(1., 2.);		  //...модуль теплопроводности; 
	sm->set_mpls(PackInts(1, 1));   //...space degree of multipoles;
	sm->set_quad(PackInts(8, 4));   //...N_elem, N_max -- parameters of quadrature;
	sm->set_normaliz(0.92);			  //...normalization coefficient;
	sm->set_lagrange(1e3);			  //...Lagrange coefficient; 
	sm->change_solv(PERIODIC_SOLVING);
	sm->solver.change_state(/*EXTERN_STATE*/);
	sm->solver.set_mode(REGUL_BOUNDARY/*PRINT_MODE*//*FULLY_MODE*/);
	//yes = 0;

///////////////////////////////////////////////////////
//...чтение модели и граничных условий из файла данных;
	if (sm) {
		Message(" ");
		sprintf(buf, "Loading model from file '%s'", name);
		Message(buf);
		Message("Reading data file ...");

		sm->stru.nodes_in(name);
      sm->bar_condit_in(name);
		sm->LinkUniStruct();
		sm->SetBUniStruct(POLY_BLOCK);
		sm->SetGeomBounding(par);

		Message("Finish!");
	}

/////////////////////////////////////////
//...задание граничных значений в модели;
	int id_action = 0;
	if (id_action) {
		double pp[6] = { 1., 0., 0., 0., 0., 0.},
				 po[6] = { 0., 0., 0., 0., 0., 0.};
		sm->BlockActivate();
		for (k = 0; k < sm->N; k++) 
		LOOP_FACET(sm->B[k].bar, num, m) {
			sm->B[k].bar->SetFacetXParam(num, par[0], po, RIGID_BND);
			sm->B[k].bar->SetFacetXParam(num, par[1], po, RIGID_BND);

			sm->B[k].bar->SetFacetYParam(num, par[2], po, RIGID_BND);
			sm->B[k].bar->SetFacetYParam(num, par[3], po, RIGID_BND);

			sm->B[k].bar->SetFacetZParam(num, par[4], pp, FORCEN_BND);
			sm->B[k].bar->SetFacetZParam(num, par[5], po, DISPLN_BND);
		}
	}

////////////////////////////
//...solving of the problem;
	if (sm->computing_kernel(MAPPING_COMPUT) != OK_STATE) {
		Message("Error in sample computing...");
		delete sm;
		goto err;
	}
#ifdef ___MPI_INIT___
	if (sm->solver.id_change == EXTERN_STATE) {
			CSlvParam params;
			params.msglev = 3;
			params.ittype = 2;
			params.sttype = 1;
			params.niter = 700;
			params.eps = 1.0e-9;

			params.tau1 = 1.0e-2;
			params.tau2 = 1.0e-3;
			params.theta = 0.10e0;

			char strbuff[256];
			sprintf (strbuff,"%s%i%s","BsSolver_",comm_mpi.GetMyid(),".dat");

			std::ofstream fout (strbuff);

			sm->shapes_init(NO_STATE); 
			BCM_draft<double> pBCM = {sm, MAPPING_COMPUT};
			AbstractParSolver (& pBCM, 
									(void *)&comm_mpi,
									fout, params,
									Number_of_Blocks<double>, Blocks_Partitioning<double>, 
									Blocks_Sparsity<double>, Blocks_Row<double>, 
									Right_Handside<double>, Initial_Guess<double>, Store_Solution<double>);
			sm->shapes_init(OK_STATE); 
		}
#endif

//////////////////
//..visualization;
#ifdef ___MPI_INIT___
	if (comm_mpi.GetMyid() == 0) 
#endif
	{
		int id_visual = 1;
		if (id_visual) {
			CGrid * nd = CreateNodes();
			int NX = 100, NY = 100, axis;

			sm->BlockActivate();

#ifdef ___LONGITUDINAL_SECTIOM___
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->add_new_point_Z((par[5]+par[4])*.5);
			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

			for (i = 0; i < nd->N;  i++)
			for (j = 0; j < nd->N1; j++) {
				int hit = -1;
				sm->Poly_struc_in3D (hit, nd->X[i], nd->Y[j], nd->Z[0]);
				nd->hit[i+j*nd->N] = hit;
			}
			axis = AXIS_Z;
#else
			if (1) {
				for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
				for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);

				nd->add_new_point_Z((par[3]+par[2])*.5);
				nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

				for (i = 0; i < nd->N;  i++)
				for (j = 0; j < nd->N1; j++) {
					int hit = -1;
					sm->Poly_struc_in3D (hit, nd->Y[j], nd->Z[0], nd->X[i]);
					nd->hit[i+j*nd->N] = hit;
				}
				axis = AXIS_Y;
			}
			else {
				for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
				for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);

				nd->add_new_point_Z((par[1]+par[0])*.5);
				nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

				for (i = 0; i < nd->N;  i++)
				for (j = 0; j < nd->N1; j++) {
					int hit = -1;
					sm->Poly_struc_in3D (hit, nd->Z[0], nd->X[i], nd->Y[j]);
					nd->hit[i+j*nd->N] = hit;
				}
				axis = AXIS_X;
			}
#endif
			system("del *.grd");
			sm->GetSurferFormat("bb", nd,	 ERR_VALUE, 0, axis);
			sm->GetSurferFormat("rr", nd,	HEAT_VALUE, 0, axis);
			sm->GetSurferFormat("pp", nd, FLUX_VALUE, 0, axis);
			delete nd;
		}
	}
	delete sm;
}
#endif
#ifdef TEST_DRAFT_LAME2D_FROM_FEMAP
{
	//const char * name = "../Exe/Box2d_homog/sph_025_16.nas";
	//const char * name = "../Exe/Box2d_homog/ell_80_20q4.nas";
	//const char * name = "../Exe/Box2d_homog/ell_20_80_i.nas";
	const char * name = "../Exe/Box2d_homog/ell_80_20_i_1980.nas";
	//const char * name = "../Exe/Box2d_homog/heat_clayer488.nas";
	//const char * name = "../Exe/Parametric/Unit2d_16.nas";
	double par[6], X0, Y0, ell_X, ell_Y, rot_Z, id_reading = 0;
	int j, l;

//////////////////////////
//...инициализация модели;
	CDraft<double> * sm = CreateDraftR(LAME2D_DRAFT);
	sm->set_mpls(PackInts(4, 4));  //...space degree of multipoles;
	sm->set_quad(PackInts(8, 8));	  //...N_elem, N_max -- parameters of quadrature;
	sm->set_normaliz(0.92);			  //...normalization coefficient;
	sm->set_lagrange(1e5);			  //...Lagrange coefficient; 
	sm->change_solv(E_PERIODIC_SOLVING);
	sm->solver.change_state(EXTERN_STATE);
	sm->solver.set_mode(REGUL_BOUNDARY/* | PRINT_MODE | NODES_PRINT*//* | FULLY_MODE*/);
	yes = 0;

//////////////////////
//...параметры задачи;
	double nju1 = 0.300, //...ледяная матрица; 
			 nju2 = 0.100, //...минеральная частица (песок); 
			 nju3 = 0.499, //...вода; 
			 E1   = 6.0,	//...ледяная матрица (GPa);
			 E2   = 50.,	//...включение (песок, GPa); 
			 E3   = 1e-05, //...межазный слой (вода, GPa); 
			 G1   = E1/(1.+nju1)*.5,
			 G2   = E2/(1.+nju2)*.5,
			 G3   = E3/(1.+nju3)*.5;
	sm->set_fasa_hmg(nju1, nju2, nju3, G1, G2, G3);

///////////////////////////////////////////////////////
//...чтение модели и граничных условий из файла данных;
	if (sm) {
		sprintf(buf, "Loading model from file '%s'", name);
		Message(" ");
		Message(buf);
		Message("Reading data file ...");

		sm->stru.nodes_in(name);
      sm->bar_condit_in(name);
		sm->LinkUniStruct();
		sm->SetBUniStruct(POLY_BLOCK);
		sm->SetGeomBounding(par);

		if (sm->id_prop && sm->pp_cond)//...reading parameters of inclusion;
		for (j = 0; j < sm->id_prop[0]; j++)
		if (sm->id_prop[j*2+2] == BSOURCE_BND) {
			X0		= sm->pp_cond[j*6]; 
			Y0		= sm->pp_cond[j*6+1];
			ell_X = sm->pp_cond[j*6+2];
			ell_Y = sm->pp_cond[j*6+3];
			rot_Z = sm->pp_cond[j*6+4];
			id_reading = 1;
			break;
		}
		Message("Finish!");
	}
	if (id_reading && ell_X != 0. && ell_Y != 0.) {
		CCells * ce = new(CCells);
		ce->cells_new(1, 2, (l = size_of_map(1, CYL_GENUS))+1);
		ce->mp[0] = (CMap)ID_MAP(1, CYL_GENUS);
		ce->mp[1] = X0;
		ce->mp[2] = Y0;
		ce->mp[4] = rot_Z/180.*M_PI;
		ce->mp[7] = ell_X;
		ce->mp[8] = ell_Y;
		ce->mp[l] = (CMap)NULL_CELL;
		sm->bar = new(CCells);
		sm->bar->bar_add(ce);
	}

////////////////////////////
//...solving of the problem;
	res = system("mkdir ./bcm_results/lame2d_homog");
	if (sm->computing_kernel(MAPPING_COMPUT) != OK_STATE) {
		Message("Error in sample computing...");
		delete sm;
		goto err;
	}
#ifdef ___MPI_INIT___
	if (sm->solver.id_change == EXTERN_STATE) {
			CSlvParam params;
			params.msglev = 3;
			params.ittype = 2;
			params.sttype = 1;
			params.niter = 1000;
			params.eps = 1.0e-12;

			params.tau1 = 1.0e-2;
			params.tau2 = 1.0e-3;
			params.theta = 0.10e0;

			char strbuff[256];
			sprintf (strbuff,"%s%i%s","BsSolver_",comm_mpi.GetMyid(),".dat");

			std::ofstream fout (strbuff);

			sm->shapes_init(NO_STATE); 
			BCM_draft<double> pBCM = {sm, MAPPING_COMPUT};
			AbstractParSolver (& pBCM, 
									(void *)&comm_mpi,
									fout, params,
									Number_of_Blocks<double>, Blocks_Partitioning<double>, 
									Blocks_Sparsity<double>, Blocks_Row<double>, 
									Right_Handside<double>, Initial_Guess<double>, Store_Solution<double>);
			sm->shapes_init(OK_STATE); 
		}
#endif

//////////////////
//..visualization;
#ifdef ___MPI_INIT___
	if (comm_mpi.GetMyid() == 0) 
#endif
	{
		double K[15], E0, E_min, E_max, nu, m0, mu, lm, C0, ff_vol, ll_vol; memset(K, 0, 15*sizeof(double));
		sm->GetRigidy(K);

		ff_vol = K[13]/(K[12]+K[13]+K[14]);
		ll_vol = K[14]/(K[12]+K[13]+K[14]); 

		C0 = (K[0]-2.*K[2]*K[5]/(K[3]+K[5]))/(K[3]-2.*K[5]*K[5]/(K[3]+K[5]));
		lm = (K[2]-C0*K[5])/(K[3]+K[5]);
		nu = lm/(C0+lm);
		E0 = C0*(1.-2.*nu)*(1.+nu)/(1.-nu);
		m0 = E0/(2.*(1.+nu));
		mu = K[7]/K[10]*.5;
		E_min = (K[12]+K[13]+K[14])/(K[12]/E1+K[13]/E2+K[14]/E3);
		E_max = (K[12]*E1+K[13]*E2+K[14]*E3)/(K[12]+K[13]+K[14]);

		FILE *  TST = fopen("./bcm_results/lame2d_homog/lame2d_homog.dat", "a");
		fprintf(TST, "ff_vol = %g, ll_vol = %g, E0 = %g, E_min = %g, E_max = %g, m0 = %g, mu = %g, nu = %g, (E1 = %g, E2 = %g, E3 = %g, nju1 = %g, nju2 = %g, nju3 = %g)\n", 
						  ff_vol, ll_vol, E0, E_min, E_max, m0, mu, nu, E1, E2, E3, nju1, nju2, nju3);
		fclose (TST);

		int id_visual = 1;
		if (id_visual) {//..visualization;
			CGrid * nd = CreateNodes();
			int NX = 300, NY = 300;

			sm->BlockActivate(NULL_STATE);

			for (int i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (int j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

			int hit = ERR_STATE;
			for (int i = 0; i < nd->N;  i++)
			for (int j = 0; j < nd->N1; j++) {
				sm->Poly_struc_in2D(hit, nd->X[i], nd->Y[j]);
				sm->StructEllCorrect(hit, nd->X[i], nd->Y[j]);
				nd->hit[i+j*nd->N] = hit;
			}
			sm->GetSurferFormat("./bcm_results/lame2d_homog/bb", nd,       ERR_VALUE, 0);
			sm->GetSurferFormat("./bcm_results/lame2d_homog/rx", nd,     DISPL_VALUE, 0);
			sm->GetSurferFormat("./bcm_results/lame2d_homog/tx", nd,  STRESS_X_VALUE, 0);
			delete nd;
		}
	}
	delete sm;
}
#endif
#ifdef TEST_DRAFT_LAME3D_FROM_FEMAP
{
	const char * name = "../Exe/Box3d_homog/nano_35x25x246_octa.nas";
	int i, j, k, m, num;

///////////////////////////////////
//...чтение модели из файла данных;
	CDraft<double> * sm = CreateDraftR(LAME3D_DRAFT, 7);
	sm->set_mpls(PackInts(1, 1));   //...space degree of multipoles;
	sm->set_quad(PackInts(2, 2));   //...N_elem, N_max -- parameters of quadrature;
	sm->set_normaliz(0.92);			  //...normalization coefficient;
	sm->set_lagrange(1e5);			  //...Lagrange coefficient; 
	sm->change_solv(/*ENERGY_SOLVING*/);
	sm->solver.change_state(/*EXTERN_STATE*/);
	sm->solver.set_mode(/*PRINT_MODE*//*FULLY_MODE*/);
	//yes = 0;

///////////////////////////////////////////////////////
//...чтение модели и граничных условий из файла данных;
	if (sm) {
		sprintf(buf, "Loading model from file '%s'", name);
		Message(" ");
		Message(buf);
		Message("Reading data file ...");

		sm->stru.nodes_in(name);
		sm->LinkUniStruct();
		sm->SetBUniStruct(POLY_BLOCK);

		Message("Finish!");
	}
	double par[6];	sm->SetGeomBounding(par);

////////////////////////////////////////
//...задаем граничные значения в модели;
	int id_action = 0;
	if (id_action) {
		sm->BlockActivate();
		double pp[6] = {     0., 0., 0., 0., 0., 0.},
				 po[6] = {-par[0], 0., 0., 0., 0., 0.};
		for (k = 0; k < sm->N; k++) 
		LOOP_FACET(sm->B[k].bar, num, m) {
			sm->B[k].bar->SetFacetXParam(num, par[0], pp, FSKEWS_BND);
			sm->B[k].bar->SetFacetXParam(num, par[1], pp, FSKEWS_BND);

			sm->B[k].bar->SetFacetYParam(num, par[2], pp, FSKEWS_BND);
			sm->B[k].bar->SetFacetYParam(num, par[3], pp, FSKEWS_BND);

			sm->B[k].bar->SetFacetZParam(num, par[4], po, FSKEWS_BND);
			sm->B[k].bar->SetFacetZParam(num, par[5], pp, FSKEWS_BND);
		}
	}
/////////////////////////////////////////
//...устанавливаем граничную поверхность;
/*	double rr0 = 0.25,
			 fff = M_PI*rr0*rr0,
			 rrr = pow(fff*.75/M_PI, 1./3.), 
			 rr1 = 0.5-rrr,
			 rr2 = 0.5-rrr*M_SQRT_2,
			 rr3 = 0.5-rrr/sqrt(3.); rrr = rr0;

	if (0) sm->add_sph_surface(-rrr, 0.5, 0.5, 0.5);
	if (0) {
		sm->add_cyl_surface(2.7, 30.-2.7, 12.-2.7, 50.);
		sm->add_cyl_surface(-6., 12.+ 6., 12.+ 6., 50.);
		sm->add_cyl_surface(2.7, 12.-2.7, 40.-2.7, 50.);
	}
	if (0) {
		sm->add_cyl_surface(-1., 0., 0., 0.);
		sm->add_cyl_surface( 2., 0., 0., 0.);
	}
*/
///////////////////////////
//...parameters of problem;
	double nj1 = 0.4999,	//...полимерная матрица; 
			 nj2 = 0.30,	//...графитовое включение; 
			 nj3 = 0.30,   //...межфазный слой; 
			 E1  = 0.000135,
			 E2  = 0.031, 
			 E3  = 0.015; 
	sm->set_fasa_hmg(nj1, nj2, E1/(1.+nj1)*.5, E2/(1.+nj2)*.5, nj3, E3/(1.+nj1)*.5);

////////////////////////////
//...solving of the problem;
	if (sm->computing_kernel(/*BASIC_COMPUT*/MAPPING_COMPUT) != OK_STATE) {
		Message("Error in sample computing...");
		if (sm) delete sm;
		goto err;
	}
#ifdef ___MPI_INIT___
	if (sm->solver.id_change == EXTERN_STATE) {
			CSlvParam params;
			params.msglev = 3;
			params.ittype = 2;
			params.sttype = 1;
			params.niter = 700;
			params.eps = 1.0e-9;

			params.tau1 = 1.0e-2;
			params.tau2 = 1.0e-3;
			params.theta = 0.10e0;

			char strbuff[256];
			sprintf (strbuff,"%s%i%s","BsSolver_",comm_mpi.GetMyid(),".dat");

			std::ofstream fout (strbuff);

			sm->shapes_init(NO_STATE); 
			BCM_draft<double> pBCM = {sm, BASIC_COMPUT};
			//AbstractSolver		(& pBCM, 
			AbstractParSolver (& pBCM, 
									(void *)&comm_mpi,
									fout, params,
									Number_of_Blocks<double>, Blocks_Partitioning<double>, 
									Blocks_Sparsity<double>, Blocks_Row<double>, 
									Right_Handside<double>, Initial_Guess<double>, Store_Solution<double>);
			sm->shapes_init(OK_STATE); 
		}
#endif
//	sm->block_descrap("Descrapency.sta");

//////////////////
//..visualization;
#ifdef ___MPI_INIT___
	if (comm_mpi.GetMyid() == 0) 
#endif
	{
		int id_visual = 1;
		if (id_visual) {
			CGrid * nd = CreateNodes();
			int NX = 100, NY = 100, axis;

			sm->BlockActivate();

#ifdef ___LONGITUDINAL_SECTIOM___
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->add_new_point_Z((par[5]+par[4])*.5);
			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

			for (i = 0; i < nd->N;  i++)
			for (j = 0; j < nd->N1; j++) {
				int hit = -1;
				sm->Poly_struc_in3D (hit, nd->X[i], nd->Y[j], nd->Z[0]);
				nd->hit[i+j*nd->N] = hit;
			}
			axis = AXIS_Z;
#else
			if (1) {
				for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
				for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);

				nd->add_new_point_Z((par[3]+par[2])*.5);
				nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

				for (i = 0; i < nd->N;  i++)
				for (j = 0; j < nd->N1; j++) {
					int hit = -1;
					sm->Poly_struc_in3D (hit, nd->Y[j], nd->Z[0], nd->X[i]);
					nd->hit[i+j*nd->N] = hit;
				}
				axis = AXIS_Y;
			}
			else {
				for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
				for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);

				nd->add_new_point_Z((par[1]+par[0])*.5);
				nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

				for (i = 0; i < nd->N;  i++)
				for (j = 0; j < nd->N1; j++) {
					int hit = -1;
					sm->Poly_struc_in3D (hit, nd->Z[0], nd->X[i], nd->Y[j]);
					nd->hit[i+j*nd->N] = hit;
				}
				axis = AXIS_X;
			}
#endif
			system("del *.grd");
			sm->GetSurferFormat("bb", nd,	     ERR_VALUE, 0, axis);
			sm->GetSurferFormat("rr", nd,    DISPL_VALUE, 0, axis);
			sm->GetSurferFormat("tz", nd, STRESS_Z_VALUE, 0, axis);
			
			delete nd;
		}
	}
	delete sm;
}
#endif
#ifdef TEST_DRAFT_COHES2D_FROM_FEMAP
{
	//const char * name_ini = "../Exe/Models_inp/Box2D_sph/sph_009_84.inp";
	//const char * name_ini = "../Exe/Models_inp/Box2D_sph/sph_009_172.inp";
	const char * name_ini = "../Exe/Models_inp/Box2D_sph/sph_009_184.inp";
	//const char * name_ini = "../Exe/Models_inp/Box2D_sph/sph_009_496.inp";

	//const char * name_ini = "../Exe/Models_inp/Box2D_ellipt/Box2D_ellipt_1_4_480.inp";
	//const char * name_ini = "../Exe/Models_inp/Box2D_ellipt/Box2D_ellipt_2_4_148.inp";
	//const char * name_ini = "../Exe/Models_inp/Box2D_ellipt/Box2D_ellipt_05_4_160.inp";
	//const char * name_ini = "../Exe/Models_inp/Box2D_short cylinder/Box2D_short_cyl_1_4.inp";
	//const char * name_ini = "../Exe/Box2d_homog/ell_80_20_i.nas";
	double X0, Y0, ell_X = 0., ell_Y = 0., rot_Z = 0.;
	int  i, j, l, id_reading = 0;

//////////////////////////
//...model initialization;
	CDraft<double> * sm = CreateDraftR(COHES2D_DRAFT, 8);
	sm->set_mpls(PackInts(2, 2)); //...степень мультиполей;
	sm->set_quad(PackInts(8, 8)); //...степень квадратуры;
	sm->set_normaliz(0.92);
	sm->set_param(sm->size_of_param()-1, 1e4);
	sm->change_solv(E_PERIODIC_SOLVING);
	sm->solver.change_state(OK_STATE/*EXTERN_STATE*/);
	sm->solver.set_mode(/*REGULARIZATION*//*PRINT_MODE*//*FULLY_MODE*/);
	yes = 0;

///////////////////////////
//...parameters of problem;
	//double nju1		= 0.39, //...matrix parameters; 
	//		 nju2		= 0.20, //...inclusion parameters; 
	//		 E1		= 3.41/(1.+nju1)*.5,  //...matrix parameters;
	//		 E2		= 87.5/(1.+nju2)*.5,  //...inclusion parameters;
	//		 l1		= 0.06, //...interphase layer as ration sqrt(G1/C1);
	//		 l2		= 0.1;  //...interphase layer as ration sqrt(G2/C2);
	double nju2		= 0.20, //...matrix parameters; 
			 nju1		= 0.30, //...inclusion parameters; 
			 E2		= 385./(1.+nju1)*.5,  //...matrix parameters;
			 E1		= 70./(1.+nju2)*.5,  //...inclusion parameters;
			 l1		= 0.1,  //...interphase layer as ration sqrt(G1/C1);
			 l2		= 0.06; //...interphase layer as ration sqrt(G2/C2);
	sm->set_param(3, 1.);  //...using gradient displacements;
	sm->set_fasa_hmg(nju1, nju2, E1/(1.+nju1)*.5, E2/(1.+nju2)*.5, E1/(1.+nju1)*.5/sqr(l1), E2/(1.+nju2)*.5/sqr(l2));

///////////////////////////////////////////////////////
//...чтение модели и граничных условий из файла данных;
	if (sm) {
      sprintf(buf, "Loading model from file '%s'", name_ini);
      Message(" ");
      Message(buf);
      Message("Reading data file ...");

		sm->stru.nodes_in(name_ini);
      sm->bar_condit_in(name_ini);
		sm->LinkUniStruct();
		sm->SetBUniStruct(POLY_BLOCK);

		if (sm->id_prop && sm->pp_cond)//...reading parameters of inclusion;
		for (j = 0; j < sm->id_prop[0]; j++)
		if (sm->id_prop[j*2+2] == BSOURCE_BND) {
			X0		= sm->pp_cond[j*6]; 
			Y0		= sm->pp_cond[j*6+1];
			ell_X = sm->pp_cond[j*6+2];
			ell_Y = sm->pp_cond[j*6+3];
			rot_Z = sm->pp_cond[j*6+4];
			id_reading = 1;
			break;
		}
		Message("Finish!");
	}
	double par[6];	sm->SetGeomBounding(par);
	if (! id_reading) {
		X0 = (par[0]+par[1])*.5;
		Y0 = (par[2]+par[3])*.5;
		ell_X = 0.15;
		ell_Y = 0.15;
		rot_Z = 0.;
	}
	if (ell_X != 0. && ell_Y != 0.) {
		CCells * ce = new(CCells);
		ce->cells_new(1, 2, (l = size_of_map(1, CYL_GENUS))+1);
		ce->mp[0] = (CMap)ID_MAP(1, CYL_GENUS);
		ce->mp[1] = X0;
		ce->mp[2] = Y0;
		ce->mp[4] = rot_Z/180.*M_PI;
		ce->mp[7] = ell_X;
		ce->mp[8] = ell_Y;
		ce->mp[l] = (CMap)NULL_CELL;
		sm->bar = new(CCells);
		sm->bar->bar_add(ce);
	}

///////////////////////////
//...solving of the probem;
	if (sm->computing_kernel(MAPPING_COMPUT) != OK_STATE) {
		Message("Error in sample computing...");
		delete sm;
		goto err;
	}
#ifdef ___MPI_INIT___
	if (sm->solver.id_change == EXTERN_STATE) {
		CSlvParam params;
		params.msglev = 3;
		params.ittype = 2;
		params.sttype = 1;
		params.niter = 200;
		params.eps = 1.0e-9;

		params.tau1 = 1.0e-2;
		params.tau2 = 1.0e-3;
		params.theta = 0.10e0;

		char strbuff[256];
		sprintf (strbuff,"%s%i%s","BsSolver_",comm_mpi.GetMyid(),".dat");

		std::ofstream fout (strbuff);

		sm->shapes_init(NO_STATE); 
		BCM_draft<double> pBCM = {sm, MAPPING_COMPUT};
		//AbstractSolver		(& pBCM, 
		AbstractParSolver (& pBCM, 
								(void *)&comm_mpi,
								fout, params,
								Number_of_Blocks<double>, Blocks_Partitioning<double>, 
								Blocks_Sparsity<double>, Blocks_Row<double>, 
								Right_Handside<double>, Initial_Guess<double>, Store_Solution<double>);
		sm->shapes_init(OK_STATE); 
	}
#endif	

//////////////////
//..visualization;
#ifdef ___MPI_INIT___
	if (comm_mpi.GetMyid() == 0) 
#endif
	{
		double K[12], E0, nu, mu, C0, lm, ff_vol; memset(K, 0, 12*sizeof(double));
		sm->GetRigidy(K);

		C0 = (K[0]-2.*K[2]*K[5]/(K[5]+K[3]))/(K[3]-2.*K[5]*K[5]/(K[5]+K[3]));
		lm = (K[2]-C0*K[5])/(K[5]+K[3]);
		E0 = (C0-lm)*(C0+2.*lm)/(C0+lm);
		nu = lm/(C0+lm);
		mu = K[7]/(K[10]*2.);
		ff_vol = M_PI*ell_X*ell_Y/((par[1]-par[0])*(par[3]-par[2]));

		FILE  * TST = fopen("box2D_ell_homog.dat", "a");
		fprintf(TST, "ff_vol = %g  E0 = %g  mu = %g  nu = %g (%g, %g, %g, %g, %g, %g, %g)\n", 						 
						  ff_vol, E0, mu, nu, ell_X, ell_Y, rot_Z, E2, E1, nju2, nju1);
		fclose (TST);

		int id_visual = 1;
		if (id_visual) {//..visualization;
			CGrid * nd = CreateNodes();
			sm->BlockActivate(NULL_STATE);

			int NX = 100, NY = 100;
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(par[0]+.5*i/NX*(par[1]-par[0]));
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(par[2]+.5*j/NY*(par[3]-par[2]));

			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

			for (i = 0; i < nd->N;  i++)
			for (j = 0; j < nd->N1; j++) {
				int hit = -1;
				sm->Poly_struc_in2D (hit, nd->X[i], nd->Y[j]);
				sm->StructEllCorrect(hit, nd->X[i], nd->Y[j]);
				nd->hit[i+j*nd->N] = hit;
			}
			system("del *.grd");
			sm->GetSurferFormat("bb",	 nd,					ERR_VALUE);
			sm->GetSurferFormat("rr",	 nd,				 DISPL_VALUE);
			sm->GetSurferFormat("tf_x", nd,			 STRESS_X_VALUE);
			sm->GetSurferFormat("tt_x", nd, STRESS_X_CLASSIC_VALUE);
			
			delete nd;
		}
	}
	delete sm;
}
#endif
#ifdef TEST_DRAFT_COHES2D_CONSTRUCTION_FROM_FEMAP
{
///////////////////////////
//...parameters of problem;
	//char * name = "./Box2d_fulleren/box2D_without15.nas";  
	//char * name = "./Box2d_fulleren/box2D_sph_40.nas";     
	//char * name = "./Box2d_fulleren/box2D_ell70_35_min.nas";
	//char * name = "./Box2d_fulleren/box2D_sph40_min.nas";  
	//char * name = "./Box2d_fulleren/box2D_ell_50_20.dat";  

///////////////////////
//...for homogenizaton;
	//char * name = "./Box2d_homog/sph_04_272.nas";  
	//char * name = "./Box2d_homog/sph_035_192.nas"; 
	//char * name = "./Box2d_homog/sph_03_280.nas";  
	//char * name = "./Box2d_homog/sph_025_64.nas";  
	//char * name = "./Box2d_homog/sph_025_52.nas";  
	//char * name = "./Box2d_homog/sph_025_52a.nas"; 
	//char * name = "./Box2d_homog/sph_025_24.nas";  
	//char * name = "./Box2d_homog/sph_025_16.nas";  
	//char * name = "./Box2d_homog/sph_025_80.nas";  
	//char * name = "./Box2d_homog/sph_025_118.nas"; 
	//char * name = "./Box2d_homog/sph_025_136.nas"; 
	//char * name = "./Box2d_homog/sph_02_40.nas";   
	//char * name = "./Box2d_homog/sph_015_88.nas";  
	//char * name = "./Box2d_homog/sph_01_104.nas";  
	//char * name = "./Box2d_homog/sph_035682_76.nas";
	//char * name = "./Box2d_homog/sph_035682_40_104.nas"; 
	//char * name = "./Box2d_homog/sph_035682_100_156.nas";
	//char * name = "./Box2d_homog/sph_035682_100_184.nas";

/////////////////////////
//...rotation of ellipse;
	//char * name = "./Box2d_homog/ell_rot90_76.nas"; 
	//char * name = "./Box2d_homog/ell_50_20.nas";
	//char * name = "./Box2d_homog/ell_80_20_(equi_circ)_52.nas";
	//char * name = "./Box2d_homog/sph_04_272.nas";
	//char * name = "./Box2d_homog/sph_035682_100_184.nas";

////////////////////////
//...periodically holes;
	//char * name = "./Box2d_homog/hole_sph_025_36.nas";
	//char * name = "./Box2d_homog/hole_sph_03_204.nas";
	//char * name = "./Box2d_homog/hole_sph_01_96.nas";

	//char * name = "./Box2d_homog/layer285_03.nas";
	//char * name = "./Box2d_homog/sph285_03.nas";  
	//char * name = "./Box2d_homog/sph623_01.nas";  
	//char * name = "./Box2d_homog/sph623_02.nas";  

	//char * name = "./Box2d_homog/sph319_04_i.nas";  
	//char * name = "./Box2d_homog/sph623_04_i.nas";  
	//char * name = "./Box2d_homog/sph894_04_i.nas";  
	//char * name = "./Box2d_homog/sph1385_04_i.nas"; 

	//char * name = "./Box2d_homog/sph285_01_i.nas";
	//char * name = "./Box2d_homog/sph285_03_i.nas";
	//char * name = "./Box2d_homog/sph285_02a.nas"; 

	//char * name = "./Box2d_homog/ell_80_20_(200_80).nas";
	char * name = "./Box2d_homog/ell_80_20_i.nas";
	//char * name = "./Box2d_homog/ell_20_80_i.nas";
	//char * name = "./Box2d_homog/ell_80_20q1.nas";
	//char * name = "./Box2d_homog/sph_025_114.nas";  

	//char * name = "./Demo_Sheffild/sph_01_i_112.nas";
	//char * name = "./Box2d_homog/sph285_01.inp";

/////////////////////////////
//...задаем параметры задачи;
	double energy[] = {0., 0.}, EYoung, 
			 nj1		= 0.39, //...matrix parameters; 
			 nj2		= 0.20, //...inclusion parameters; 
			 G1		= 3.41/(1.+nj1)*.5,  //...matrix parameters;
			 G2		= 87.5/(1.+nj2)*.5,  //...inclusion parameters;
			 l0		= 0.01, //...interphase layer as ration sqrt(G1/C1);
			 l2		= 0.06, //...interphase layer as ration sqrt(G2/C2);
			 l0ini	= l0, ff;

	char * pchar, buff[2001]; strcpy(buff, name);
	if ((pchar = strrchr(buff, '.')) != NULL) {
		strcpy(pchar, ".dat");
	}
	FILE * TST = fopen("Effecive.dat", "w");

//	for (int N0 = 5, k = 11; k < 200; k++) {
//		if (k < 11) G2  = k*.1; else
//		if (k < 19) G2  = k-9.; 
//		else			G2  = 10.+(k-19.)*10.; 
//		G2  = 10.;

	for (int N0 = 5, k = 50; k <= 50; k++) {
			 ff = k/100.;
			 l0 = l2 = 2.0;

	//for (int N0 = 3, k = 0; k < 1; k++) {
		memset(energy, 0, 2*sizeof(double));
		EYoung = CIdent(name, ff, 1.0, energy, l0, l2, G1, G2, nj1, nj2, 0.*G1*(1.-nj1)/(.5-nj1)*8., 0.*G1*8., N0, OK_STATE, OK_STATE, OK_STATE);
		fprintf(TST, "ff = %g  EYoung = %g\n", ff, EYoung);
	}
	fclose(TST);
}
#endif
#ifdef TEST_DRAFT_GRADIENT2D_FROM_FEMAP
{
	char * name_ini = "./Models_inp/Box2D_circle/Box2D_circle_40_M208.inp";
	extern int gradient_model; gradient_model = 0;

	double X0, Y0, ell_X = 0., ell_Y = 0., rot_Z = 0.;
	int  i, j, l, id_reading = 1;

//////////////////////////
//...model initialization;
	CDraft<double> * sm = CreateDraftR(MINDL2D_DRAFT, 8);
	sm->set_mpls(PackInts(3, 3)); //...степень мультиполей;
	sm->set_quad(PackInts(16, 8)); //...степень квадратуры;
	sm->set_normaliz(0.92);
	sm->set_lagrange(1e5);
	sm->change_solv(E_PERIODIC_SOLVING);
	sm->solver.change_state(/*EXTERN_STATE*/);
	sm->solver.set_mode(/*REGULARIZATION*//*PRINT_MODE*//*FULLY_MODE*/);
	yes = 0;

///////////////////////////
//...parameters of problem;
	double nju1 = 0.33,					//...полимерная матрица;
			 nju2 = 0.16,					//...жесткое включение;  
			 E1   = 210.,					//...модуль Юнга матрицы;
			 E2   = 420.,					//...модуль Юнга включения;
			 AA	= E1*.0,					//...adhegion parameter;
			 BB	= E1*.5/(1.+nju1)*.0,//...adhegion parameter;
			 l1	= 0.3568*3.,			//...interphase layer for matrix;
			 l2	= 0.3568,				//...interphase layer for inclusion;
			 l1_dop	= 0.,					//...interphase layer_dop;
			 l2_dop	= 0.,					//...interphase layer_dop;
			 c0	= 0.40,					//...volume fraction; 
			 G1, G2, KH, GH, EH, nH;
	sm->set_fasa_hmg(nju1, nju2, G1 = E1/(1.+nju1)*.5, G2 = E2/(1.+nju2)*.5, l1, l1_dop = l1_dop/sqrt(1.-2.*nju1), l2, l2_dop = l2_dop/sqrt(1.-2.*nju2), AA, BB);

///////////////////////////////////////////////////////
//...чтение модели и граничных условий из файла данных;
	if (sm) {
      sprintf(buf, "Loading model from file '%s'", name_ini);
      Message(" ");
      Message(buf);
      Message("Reading data file ...");

		sm->stru.nodes_in(name_ini);
      sm->bar_condit_in(name_ini);
		sm->LinkUniStruct();
		sm->SetBUniStruct(POLY_BLOCK);

		if (sm->id_prop && sm->pp_cond)//...reading parameters of inclusion;
		for (j = 0; j < sm->id_prop[0]; j++)
		if (sm->id_prop[j*2+2] == BSOURCE_BND) {
			X0		= sm->pp_cond[j*6]; 
			Y0		= sm->pp_cond[j*6+1];
			ell_X = sm->pp_cond[j*6+2];
			ell_Y = sm->pp_cond[j*6+3];
			rot_Z = sm->pp_cond[j*6+4];
			id_reading = 1;
			break;
		}
		Message("Finish!");
	}
	double par[6];	sm->SetGeomBounding(par);
	if (! id_reading) {
		X0 = (par[0]+par[1])*.5;
		Y0 = (par[2]+par[3])*.5;
		ell_X = 0.15;
		ell_Y = 0.15;
		rot_Z = 0.;
	}
	if (ell_X != 0. && ell_Y != 0.) {
		CCells * ce = new(CCells);
		ce->cells_new(1, 2, (l = size_of_map(1, CYL_GENUS))+1);
		ce->mp[0] = (CMap)ID_MAP(1, CYL_GENUS);
		ce->mp[1] = X0;
		ce->mp[2] = Y0;
		ce->mp[4] = rot_Z/180.*M_PI;
		ce->mp[7] = ell_X;
		ce->mp[8] = ell_Y;
		ce->mp[l] = (CMap)NULL_CELL;
		sm->bar = new(CCells);
		sm->bar->bar_add(ce);
	}

///////////////////////////
//...solving of the probem;
	if (sm->computing_kernel(MAPPING_COMPUT) != OK_STATE) {
		Message("Error in sample computing...");
		delete sm;
		goto err;
	}
#ifdef ___MPI_INIT___
	if (sm->solver.id_change == EXTERN_STATE) {
		CSlvParam params;
		params.msglev = 3;
		params.ittype = 2;
		params.sttype = 1;
		params.niter = 200;
		params.eps = 1.0e-9;

		params.tau1 = 1.0e-2;
		params.tau2 = 1.0e-3;
		params.theta = 0.10e0;

		char strbuff[256];
		sprintf (strbuff,"%s%i%s","BsSolver_",comm_mpi.GetMyid(),".dat");

		std::ofstream fout (strbuff);

		sm->shapes_init(NO_STATE); 
		BCM_draft<double> pBCM = {sm, MAPPING_COMPUT};
		//AbstractSolver		(& pBCM, 
		AbstractParSolver (& pBCM, 
								(void *)&comm_mpi,
								fout, params,
								Number_of_Blocks<double>, Blocks_Partitioning<double>, 
								Blocks_Sparsity<double>, Blocks_Row<double>, 
								Right_Handside<double>, Initial_Guess<double>, Store_Solution<double>);
		sm->shapes_init(OK_STATE); 
	}
#endif	

//////////////////
//..visualization;
#ifdef ___MPI_INIT___
	if (comm_mpi.GetMyid() == 0) 
#endif
	{
		double K[16], ku1, lm1, mu1, ku2, lm2, mu2, Ez, Kxy, Gxy, Gxz, nxz, ff_vol; memset(K, 0, 16*sizeof(double));
		sm->GetRigidy(K);
		ff_vol = M_PI*ell_X*ell_Y/((par[1]-par[0])*(par[3]-par[2]));

///////////////////////
//...матрица жесткости;
		ku1 = K[0];
		lm1 = K[2];
		mu1 = K[7];
		ku2 = K[14]*G1*(1.-nju1)/(.5-nju1)+K[15]*G2*(1.-nju2)/(.5-nju2)+
				(G2*nju2/(.5-nju2)-G1*nju1/(.5-nju1))/(G2/(1.-2.*nju2)-G1/(1.-2.*nju1))*
				(K[12]-K[14]*G1*nju1/(.5-nju1)-K[15]*G2*nju2/(.5-nju2));
		lm2 = K[14]*G1*nju1/(.5-nju1)+K[15]*G2*nju2/(.5-nju2)+
				(G2*nju2/(.5-nju2)-G1*nju1/(.5-nju1))/(G2/(1.-2.*nju2)-G1/(1.-2.*nju1))*
				(K[13]-K[14]*G1/(1.-2.*nju1)-K[15]*G2/(1.-2.*nju2));
		mu2 = K[14]*G1+K[15]*G2;

///////////////////////////
//...технические константы;
		nxz = lm2/(ku1+lm1);
		Kxy = 0.5*(ku1+lm1);	
		Gxy = 0.5*(ku1-lm1);	
		Gxz = mu2;	
		Ez  = ku2-2.*lm2*nxz;

///////////////////////////////////////////////////////////////////
//...результат пространственного осреднения волокон по Кристенсену;
		KH = (Ez+4.*sqr(1.+nxz)*Kxy)/9.;
		GH = (Ez+sqr(1.-2.*nxz)*Kxy+6.*(Gxy+Gxz))/15.;
		nH = 1./(2.*(Ez+Gxy+Gxz)+(8.*sqr(nxz)+12.*nxz+7.)*Kxy);
		EH = 5.*GH*nH*(Ez+4.*sqr(1.-nxz)*Kxy);
		nH = .5*nH*(Ez+2.*(2.*sqr(nxz)+8.*nxz+3.)*Kxy-4.*(Gxy+Gxz));

		FILE  * TST = fopen("box2D_cyl_homog.dat", "a");
		fprintf(TST, "ff_vol = %g  KH = %g  GH = %g  EH = %g  nH = %g  Ez = %g  Kxy = %g  Gxy = %g  Gxz = %g  nxz = %g  mu1 = %g (%g, %g, %g, %g, %g, %g, %g)\n", 						 
						  ff_vol, KH, GH, EH, nH, Ez, Kxy, Gxy, Gxz, nxz, mu1, ell_X, ell_Y, rot_Z, E2, E1, nju2, nju1);
		fclose (TST);

		int id_visual = 1;
		if (id_visual) {//..visualization;
			CGrid * nd = CreateNodes();
			sm->BlockActivate(NULL_STATE);

			int NX = 100, NY = 100;
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(par[0]+.5*i/NX*(par[1]-par[0]));
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(par[2]+.5*j/NY*(par[3]-par[2]));

			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

			for (i = 0; i < nd->N;  i++)
			for (j = 0; j < nd->N1; j++) {
				int hit = -1;
				sm->Poly_struc_in2D (hit, nd->X[i], nd->Y[j]);
				sm->StructEllCorrect(hit, nd->X[i], nd->Y[j]);
				nd->hit[i+j*nd->N] = hit;
			}
			system("del *.grd");
			sm->GetSurferFormat("bb",	 nd,					ERR_VALUE);
			sm->GetSurferFormat("rr",	 nd,				 DISPL_VALUE);
			sm->GetSurferFormat("tf_x", nd,			 STRESS_X_VALUE);
			sm->GetSurferFormat("tt_x", nd, STRESS_X_CLASSIC_VALUE);
			
			delete nd;
		}
	}
	delete sm;
}
#endif
#ifdef TEST_DRAFT_HEAT3D_SPHEROID
{
	double par[6], RR = 1., rr = 1., AA = 3.;

//////////////////////
//...параметры задачи;
	double K1 = 1.,	 //...heat conduction (matrix);
			 K2 = 2.;	 //...heat conduction (inclusion);

//////////////////////////
//...model initialization;
	CDraft<double> * sm = CreateDraftR(HEAT3D_DRAFT, 7);
	sm->set_fasa_hmg(RR, rr, K1, K2, K2);
	sm->set_mpls(PackInts(1, 1)); //...multipoles degree;
	sm->set_quad(PackInts(8, 4));
	sm->set_normaliz(0.92);
	sm->change_solv(SPECIAL_SOLVING);
	sm->solver.set_mode(/*REDUCED_PRINT*/PRINT_MODE/*FULLY_MODE*/);
	//yes = 0;

for (int j = 1; j <= 1; j++) {
///////////////////////
//...геометрия области;
	sm->GetSpheroidBoxStruct(AA, AA, AA, RR, rr); sm->B[1].type = ESHE_ZOOM_BLOCK;
	par[0] = -AA*.5; par[2] = -AA*.5; par[4] = -AA*.5;
	par[1] =  AA*.5; par[3] =  AA*.5; par[5] =  AA*.5;

///////////////////////////
//...solving of the probem;
	if (sm->computing_kernel(ESHELBY_COMPUT) != OK_STATE) {
		Message("Error in sample computing...");
		delete sm;
		goto err;
	}

///////////////////////////////////////////////////////////////////////
//..вычисляем осредненные характеристики (модуль Юнга и модуль сдвига);
	//double K[28], E0, K0, nu, mu, C0, lm, ff_vol, ll_vol; memset(K, 0, 28*sizeof(double)); K[27] = AX*.5;
	//sm->GetRigidy(K, -1, VOLUME_COUNTING); for (i = 0; i < 25; i++) K[i] = -K[i];
	//sm->GetRigidy(K, -1, BASIC_COUNTING);
	//sm->GetRigidy(K, -1, COVERING_COUNTING);

	//ff_vol = K[25]/(K[24]+K[25]+K[26]);
	//ll_vol = K[26]/(K[24]+K[25]+K[26]);

	//C0 = (K[5]-2.*K[0]*K[6]/(K[6]+K[11]))/(K[11]-2.*K[6]*K[6]/(K[6]+K[11]));
	//lm = (K[0]-C0*K[6])/(K[6]+K[11]);
	//nu = lm/(C0+lm);
	//E0 = (C0-lm)*(C0+2.*lm)/(C0+lm);
	//K0 = E0/(3.*(1.-2.*nu));
	//mu = K[15]/K[21]*.5;
	//FILE  * TST = fopen("lame3D_homog2.dat", "a");
	//fprintf(TST, "ff_vol+ll_vol = %g  KH = %g  EH = %g  mH = %g  nH = %g (%g, %g, %g, %g, %g, %g, %g)\n", 						 
	//				  ff_vol+ll_vol, KH, EH, mH, nH, rad, E2, E3, E1, nj2, nj3, nj1);
	//fclose (TST);
}

//////////////////
//..visualization;
	int id_visual = 1;
	if (id_visual) {
		CGrid * nd = CreateNodes();
		int NX = 100, NY = 100, axis = AXIS_Y, alpha = 0, i, j;

		if (axis == AXIS_Z) {
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->add_new_point_Z(par[4]+(par[5]-par[4])*(1.+alpha)*.5);
			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
		}
		if (axis == AXIS_Y) {
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);

			nd->add_new_point_Z(par[2]+(par[3]-par[2])*(1.+alpha)*.5);
			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
		}
		if (axis == AXIS_X) {
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);

			nd->add_new_point_Z(par[0]+(par[1]-par[0])*(1.+alpha)*.5);
			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
		}
		for (i = 0; i < nd->N;  i++)
		for (j = 0; j < nd->N1; j++) {
			double X, Y, Z;
			if (axis == AXIS_Z) {
				X = nd->X[i]; Y = nd->Y[j]; Z = nd->Z[0];
			}
			else
			if (axis == AXIS_Y) {
				X = nd->Y[j]; Y = nd->Z[0]; Z = nd->X[i];
			}
			else
			if (axis == AXIS_X) {
				X = nd->Z[0]; Y = nd->X[i]; Z = nd->Y[j];
			}
			if (RR == 0. || rr == 0.) nd->hit[i+j*nd->N] = 0; else
			if (sqr(X/rr)+sqr(Y/rr)+sqr(Z/RR) < 1.) nd->hit[i+j*nd->N] = 0; 
			else	nd->hit[i+j*nd->N] = 1;	
		}

		system("del *.grd");
		sm->GetSurferFormat("rr", nd,	HEAT_VALUE, 0, axis);
		sm->GetSurferFormat("rz", nd,	HEAT_ESHE_VALUE, 0, axis);
		sm->GetSurferFormat("tz", nd, FLUX_ESHE_VALUE, 0, axis);

		delete nd;
	}
	delete sm;
}
#endif
#ifdef TEST_DRAFT_LAME3D_SPHEROID
{
	double RR = 1., rr = 0.7, AA = 3.;

//////////////////////
//...параметры задачи;
	double nj1 = 0.30, //...полимерная матрица; 
			 nj2 = 0.30, //...графитовое включение; 
			 E1  = 0.135,
			 E2  = 1.5, par[6]; 

//////////////////////////
//...model initialization;
	CDraft<double> * sm = CreateDraftR(LAME3D_DRAFT, 8);
	sm->set_fasa_hmg(RR, rr, nj2, nj1, nj1, E2/(1.+nj2)*.5, E1/(1.+nj1)*.5, E1/(1.+nj1)*.5);
	sm->set_mpls(PackInts(11, 1)); //...степень мультиполей;
	sm->set_quad(PackInts(8, 4)); //...степень квадратуры;
	sm->set_normaliz(0.92);			//...нормирующий множитель;
	sm->change_solv(/*SPECIAL_SOLVING*/);
	sm->solver.set_mode(/*REDUCED_PRINT*//*PRINT_MODE*//*FULLY_MODE*/);
	//yes = 0;

///////////////////////////////
//...цикл по параметрам задачи;
	for (int j = 1; j <= 1; j++) {
///////////////////////
//...геометрия области;
		sm->GetSpheroidBoxStruct(AA, AA, AA, RR, rr); sm->B[1].type = ESHE_ZOOM_BLOCK;
		par[0] = -AA*.5; par[2] = -AA*.5; par[4] = -AA*.5;
		par[1] =  AA*.5; par[3] =  AA*.5; par[5] =  AA*.5;

///////////////////////////
//...solving of the probem;
		if (sm->computing_kernel(ESHELBY_COMPUT) != OK_STATE) {
			Message("Error in sample computing...");
			delete sm;
			goto err;
		}
	}

//////////////////
//..visualization;
	int id_visual = 1;
	if (id_visual) {
		CGrid * nd = CreateNodes();
		int NX = 100, NY = 100, axis = AXIS_Y, alpha = 0, i, j;

		if (axis == AXIS_Z) {
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->add_new_point_Z(par[4]+(par[5]-par[4])*(1.+alpha)*.5);
			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
		}
		if (axis == AXIS_Y) {
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);

			nd->add_new_point_Z(par[2]+(par[3]-par[2])*(1.+alpha)*.5);
			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
		}
		if (axis == AXIS_X) {
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);

			nd->add_new_point_Z(par[0]+(par[1]-par[0])*(1.+alpha)*.5);
			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
		}
		for (i = 0; i < nd->N;  i++)
		for (j = 0; j < nd->N1; j++) {
			double X, Y, Z;
			if (axis == AXIS_Z) {
				X = nd->X[i]; Y = nd->Y[j]; Z = nd->Z[0];
			}
			else
			if (axis == AXIS_Y) {
				X = nd->Y[j]; Y = nd->Z[0]; Z = nd->X[i];
			}
			else
			if (axis == AXIS_X) {
				X = nd->Z[0]; Y = nd->X[i]; Z = nd->Y[j];
			}
			if (RR == 0. || rr == 0.) nd->hit[i+j*nd->N] = 0; else
			if (sqr(X/rr)+sqr(Y/rr)+sqr(Z/RR) < 1.) nd->hit[i+j*nd->N] = 0; 
			else	nd->hit[i+j*nd->N] = 1;	
		}

		system("del *.grd");
		sm->GetSurferFormat("rz", nd,	DISPL_ESHE_VALUE, 0, axis);
		sm->GetSurferFormat("tz", nd, STRESS_Z_ESHE_VALUE, 0, axis);

		delete nd;
	}
	delete sm;
}
#endif
#ifdef DIFFUSION2D_HOMOGENIZATION
{
	double AA = 1., BB = 1., ff_vol = 0.1, RR = sqrt(0.1/M_PI), B1 = 20., B2 = 1.;
	double fi=0.06, fk=0.06, gamma=0.8, kappa=0.4, Temper=413., Di=8.64e-1, Dk=8.64e-5, Ds=8.64e-1, mu=8.64e-3, Gconst=6.2e6, kk=2.e-16; 
	int id_visual = 0, NX = 100, NY = 100, axis = AXIS_Y, N0 = 11, N_elem = 16, N_max = 4, i, j, k; 

	const int N_X1 = 10, N_X2 = 10, N_C0 = 10;
	double *** X1 = NULL, *** X2 = NULL, *** C0 = NULL, *** result = NULL, *** BB1 = NULL, *** BB2 = NULL; 
	set_matrix3(X1, N_X1, N_X2, N_C0); 
	set_matrix3(X2, N_X1, N_X2, N_C0); 
	set_matrix3(C0, N_X1, N_X2, N_C0); 
	set_matrix3(result, N_X1, N_X2, N_C0); 
	set_matrix3(BB1, N_X1, N_X2, N_C0); 
	set_matrix3(BB2, N_X1, N_X2, N_C0); 

//////////////////////////
//...model initialization;
	CDraft<double> * sm = CreateDraftR(HEAT2D_DRAFT);
	sm->set_fasa_hmg(RR, RR, B2, B1, B1);
	sm->set_mpls(PackInts(N0, N0));			//...space degree of multipoles;
	sm->set_quad(PackInts(N_elem, N_max)); //...N_elem, N_max -- parameters of quadrature;
	sm->set_normaliz(0.92);						//...normalization coefficient;
	sm->change_solv(SPECIAL_SOLVING);
	sm->solver.set_mode(NO_MESSAGE);
	if (sm) {
      sprintf(buf, "Loading model...");
      Message(" ");
      Message(buf);

		sm->stru.add_new_point(-AA*.5, BB*.5, 0., 0., 0., 1.); sm->stru.hit[0] = 1;
		sm->stru.add_new_point(-AA*.5,-BB*.5, 0., 0., 0., 1.); sm->stru.hit[1] = 2;
		sm->stru.add_new_point( AA*.5,-BB*.5, 0., 0., 0., 1.); sm->stru.hit[2] = 3;
		sm->stru.add_new_point( AA*.5, BB*.5, 0., 0., 0., 1.); sm->stru.hit[3] = 4;
		sm->stru.geom = (int *)new_struct(10*sizeof(int));
		sm->stru.geom[0] = 1;
		sm->stru.geom[1] = GL_QUADS;
		sm->stru.geom[2] = 7;
		sm->stru.geom[3] = -1;
		sm->stru.geom[4] = -1;
		sm->stru.geom[5] = -1;
		sm->stru.geom[6] = 0;
		sm->stru.geom[7] = 1;
		sm->stru.geom[8] = 2;
		sm->stru.geom[9] = 3;
		sm->stru.geom_ptr = (int *)new_struct(3*sizeof(int));
		sm->stru.geom_ptr[0] = 1;
		sm->stru.geom_ptr[1] = 10;
		sm->stru.cond = (int *)new_struct(2*sizeof(int));
		sm->stru.cond_ptr = (int *)new_struct(2*sizeof(int));
		sm->stru.cond_ptr[0] = 1;

		sm->LinkUniStruct();
		sm->SetBUniStruct(CLAYER_BLOCK);
		Message("Finish!");
	}

///////////////////////////
//...parameters of problem;
	double X1_0 = 0., h_X1 = 0.01,
			 X2_0 = 0., h_X2 = 0.01,
			 C0_0 = 1.68e-2, h_C0 = 0.158;
   for (i = 0; i < N_X1; i++)
	for (j = 0; j < N_X2; j++)
	for (k = 0; k < N_C0; k++) {

////////////////////////////
//...определение параметров;
		X1[i][j][k] = X1_0+i*h_X1;
		X2[i][j][k] = X2_0+j*h_X2;
		C0[i][j][k] = C0_0-k*h_C0;
		BB1[i][j][k] = B1 = fk*Dk+(1.-fk)*gamma*kappa*Ds;
		BB2[i][j][k] = B2 = fi*Di+(fi*kk*Gconst*Temper/mu)*C0[i][j][k]; 
		sm->set_fasa_hmg(RR, RR, B2, B1, B1);

///////////////////////////
//...solving of the probem;
		if (sm->computing_kernel(PERIOD_COMPUT) != OK_STATE) {
			Message("Error in sample counting...");
			delete sm;
			goto err;
		}

////////////////////////////////
//...effective diffusion module;
		double par[6];	sm->SetGeomBounding(par);
		double D[6] = {0.,0.,0.,0.,0., min(AA, BB)*.5}, dd;

		sm->set_param(sm->NUM_QUAD, PackInts(N_elem, 2*N_max));

		sm->GetRigidy(D, -1, BASIC_COMPUT);
		sm->GetRigidy(D, -1, COVERING_COMPUT);

		dd = D[0]/(D[2]+D[3]+D[4]);
		result[i][j][k] = dd;

//////////////////
//..visualization;
		if (id_visual) {//..visualization;
			CGrid_el * nd = new CGrid_el;
			sm->BlockActivate(NULL_STATE);

			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
			system("del *.grd");

			sm->GetSurferFormat("rr", nd,			 HEAT_VALUE, 0);
			sm->GetSurferFormat("pp", nd, FLUX_COMPOS_VALUE, 0);

			delete nd;
		}
	}
	delete sm;

////////////////////////
//...печать результатов;
	FILE * TST = fopen("result_homog.dat", "w");
	fprintf(TST, "X1,       X2,       C0,       ff_vol,       result,       (B1, B2)\n");

	for (i = 0; i < N_X1; i++)
	for (j = 0; j < N_X2; j++)
	for (k = 0; k < N_C0; k++)
		fprintf(TST, "%g,       %g,       %g,        %g,       %g,       (%g,  %g)\n", 
						X1[i][j][k], X2[i][j][k], C0[i][j][k], ff_vol, result[i][j][k], BB1[i][j][k], BB2[i][j][k]);
	if (TST) fclose (TST);

	delete_struct(X1);
	delete_struct(X2);
	delete_struct(C0);
	delete_struct(result);
	delete_struct(BB1);
	delete_struct(BB2);
}
#endif

#ifdef HEAT2D_RANDOM_STRUCTURE
{
	char * name = "./Parametric/Unit2d_4.nas";
	int  i, j, l;

///////////////////////////
//...parameters of problem;
	double K1 = 1.,		//...heat conduction (matrix);
			 K2 = 20.,		//...heat conduction (inclusion);
			 K3 = 0.01,		//...heat conduction (intermediate);
			 R1 = 0.3/2.,	//...inclusion geometry;
			 R2 = 0.4/2.;	//...intermediate geometry; 

//////////////////////////
//...model initialization;
	CDraft<double> * sm = CreateDraftR(HEAT2D_DRAFT);
	sm->set_fasa_hmg(R1, R2, K1, K2, K3);	//...parameters of problem;
	sm->set_mpls(PackInts(7, 7));				//...space degree of multipoles;
	sm->set_quad(PackInts(8, 16));			//...N_elem, N_max -- parameters of quadrature;
	sm->set_normaliz(0.92);						//...normalization coefficient;
	sm->set_lagrange(1e-4);						//...Lagrange coefficient for energy;
	sm->change_solv(PERIODIC_SOLVING);
	sm->solver.change_state(EXTERN_STATE);
	sm->solver.set_mode(/*REGULARIZATION*//*PRINT_MODE*//*FULLY_MODE*//*| MASKS_MODE | ACCUMULATION*/);
	//yes = 0;

//////////////////////////////////
//...reading model from data-file;
	if (sm) {
      sprintf(buf, "Loading model from file '%s'", name);
      Message(" ");
      Message(buf);
      Message("Reading data file ...");

		sm->stru.nodes_in(name);
		sm->bar_condit_in(name);
		sm->LinkUniStruct();
		sm->SetBUniStruct( CLAYER_BLOCK);
		//for (i = 0; i < 10; i++)
		//for (j = 0; j < 10; j++) if ((i+j)%2 && (i-2)*(i-2)+(j-2)*(j-2) >= 4 
		//												 && (i-2)*(i-2)+(j-7)*(j-7) >= 4
		//												 && (i-7)*(i-7)+(j-2)*(j-2) >= 4
		//												 && (i-7)*(i-7)+(j-7)*(j-7) >= 4)
		//sm->SetBUniStruct(10*i+j, POLY_BLOCK, ERR_GENUS);
		//sm->SetBUniStruct(0, POLY_BLOCK, ERR_GENUS);
		//sm->SetBUniStruct(1, POLY_BLOCK, ERR_GENUS);

		Message("Finish!");
	}

///////////////////////////
//...solving of the probem;
	FILE  * TST = fopen("heat2D_random.dat", "w"); 
	fclose (TST);
	for (int var = 50; var < 51; var++) {
		if (sm->computing_kernel(MAPPING_COMPUT) != OK_STATE) {
			Message("Error in sample computing...");
			delete sm;
			goto err;
		}
#ifdef ___MPI_INIT___
		if (sm->solver.id_change == EXTERN_STATE) {
			CSlvParam params;
			params.msglev = 3;
			params.ittype = 2;
			params.sttype = 1;
			params.niter = 200;
			params.eps = 1.0e-9;

			params.tau1 = 1.0e-2;
			params.tau2 = 1.0e-3;
			params.theta = 0.10e0;

			char strbuff[256];
			sprintf (strbuff,"%s%i%s","BsSolver_",comm_mpi.GetMyid(),".dat");

			std::ofstream fout (strbuff);

			sm->shapes_init(NO_STATE); 
			BCM_draft<double> pBCM = {sm, MAPPING_COMPUT};
			//AbstractSolver		(& pBCM, 
			AbstractParSolver (& pBCM, 
									(void *)&comm_mpi,
									fout, params,
									Number_of_Blocks<double>, Blocks_Partitioning<double>, 
									Blocks_Sparsity<double>, Blocks_Row<double>, 
									Right_Handside<double>, Initial_Guess<double>, Store_Solution<double>);
			sm->shapes_init(OK_STATE); 
	}
#endif

//////////////////
//..visualization;
#ifdef ___MPI_INIT___
		if (comm_mpi.GetMyid() == 0) 
#endif
		{
			double par[6];	sm->SetGeomBounding(par);
			double K[5] = {0.,0.,0.,0.,0.}, KH, kk, kk_low, kk_max, ff_vol;

			sm->set_param(3, PackInts(UnPackInts(sm->get_param(3)), 2*UnPackInts(sm->get_param(3), 1)));

			sm->GetRigidy(K, -1,		BASIC_COMPUT);
			sm->GetRigidy(K, -1, COVERING_COMPUT);

			ff_vol = (K[3]+K[4])/(K[2]+K[3]+K[4]);
			kk		 =  K[0]/(K[2]+K[3]+K[4]);
			kk_low = (K[2]+K[3]+K[4])/(K[2]/K1+K[3]/K2+K[4]/K3);
			kk_max = (K[2]*K1+K[3]*K2+K[4]*K3)/(K[2]+K[3]+K[4]);

			KH = sm->TakeEshelby_two(ff_vol);

			TST = fopen("heat2D_random.dat", "a");
			fprintf(TST, "%g    %g    %g    %g    %g\n", ff_vol, kk, KH, kk_low, kk_max);
			fclose (TST);

			int id_visual = 1;
			if (id_visual) { //..visualization;
				CGrid * nd = CreateNodes();
				int NX = 200, NY = 200, i, j;

				sm->BlockActivate(NULL_STATE);

				for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
				for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

				nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

				for (i = 0; i < nd->N;  i++)
				for (j = 0; j < nd->N1; j++) {
					int hit = -1;
					sm->Poly_struc_in2D (hit, nd->X[i], nd->Y[j]);
					nd->hit[i+j*nd->N] = hit;
				}
				system("del *.grd");

				sm->GetSurferFormat("bb", nd,         ERR_VALUE, 0);
				sm->GetSurferFormat("rr", nd,        HEAT_VALUE, 0);
				sm->GetSurferFormat("pp", nd, FLUX_COMPOS_VALUE, 0);

				delete nd;
			}
		}
	}
	delete sm;
}
#endif
#ifdef HEAT3D_RANDOM_STRUCTURE
{
	char * name = "./Parametric/Unit3d_002.nas";
	double A = 1., B = 1., C = 1., rad = 0.1, ll = 0.05;
	int i = 0, j, k, M = 1, m = 1;
/////////////////////////////////////////////////////////////
//...генератор случайных чисел;                            //
//	for (srand((unsigned)time(NULL)), i = 0; i < 10; i++) { //
//	double random = (double) rand()/(double) RAND_MAX;      //
//			i = i;                                            //
//	}                                                       //
/////////////////////////////////////////////////////////////
//////////////////////////////////
//...генерим структуру вкллючений;
	const int N = 3;
	double X[] = {0., 1., 2., 3., 4., 5., 6., 7., 8., 9., 10.}, 
			 Y[] = {0., 1., 2., 3., 4., 5., 6., 7., 8., 9., 10.}, 
			 Z[] = {0., 1., 2., 3., 4., 5., 6., 7., 8., 9., 10.}, pp[8], par[8], dd_shift = 4.;
	//for (j = 0; j < 2*(M+m+1); j++) pp[j] = j/(2.*(M+m+1.));
	rad = .05/(2.*N); ll = 2.*rad;

///////////////////////////
//...parameters of problem;
	//double K1 = 1.113,	//...heat conduction (matrix);
	//		 K2 = 2.954,	//...heat conduction (inclusion);
	//		 K3 = 0.111,	//...heat conduction (intermediate) 
	double K1 = 1.,	//...heat conduction (matrix);
			 K2 = 20.,	//...heat conduction (inclusion);
			 K3 = 0.01,	//...heat conduction (intermediate);
			 R1 = rad,		//...inclusion geometry;
			 R2 = rad+ll;	//...intermediate geometry; 

//////////////////////////
//...model initialization;
	CDraft<double> * sm = CreateDraftR(HEAT3D_DRAFT, 8);
	sm->set_fasa_hmg(R1, R2, K1, K2, K3);	//...parameters of problem;
	sm->set_mpls(PackInts(13, 13));				//...space degree of multipoles;
	sm->set_quad(PackInts(8, 4));				//...N_elem, N_max -- parameters of quadrature;
	sm->set_normaliz(0.92);						//...normalization coefficient;
	sm->set_lagrange(1e5);						//...Lagrange coefficient for energy;
	sm->change_solv(/*ENERGY_SOLVING*/PERIODIC_SOLVING/*SPECIAL_SOLVING*/);
	sm->solver.change_state(EXTERN_STATE);
	sm->solver.set_mode(/*REGULARIZATION*//* | *//*PRINT_MODE*//*FULLY_MODE*//* | MASKS_MODE*//* | ACCUMULATION*/);
	//yes = 0;

//////////////////////////////////////////////
//...построение решетки для системы включений;
	CGrid * nd = CreateNodes(); nd->add_params(2);
	CGrid * lt = CreateNodes();

	pp[0] = rad; pp[1] = rad+ll; 
	par[0] = X[0]-dd_shift; par[2] = Y[0]-dd_shift; par[4] = Z[0]-dd_shift; ; par[1] = X[N-1]+dd_shift; par[3] = Y[N-1]+dd_shift; par[5] = Z[N-1]+dd_shift; 
	for (k = 0; k < N; k++)
	for (j = 0; j < N; j++)
	for (i = 0; i < N; i++) 
		nd->add_new_point((X[i]-par[0])/(par[1]-par[0]), (Y[j]-par[2])/(par[3]-par[2]), (Z[k]-par[4])/(par[5]-par[4]), pp);
	
	par[0] = par[2] = par[4] = 0.; par[1] = par[3] = par[5] = 1.;
	lt->grid_lattice(nd, par);


/////////////////////////////////////////////////
//...задание модели и граничных условий функцией;
	if (sm && 1) {
		sm->GetLatticeBox3DStruct(lt->X, lt->Y, lt->Z, lt->N, lt->N1, lt->N2, /*POLY_BLOCK*/CLAYER_BLOCK);
		//sm->GetLatticeBox3DStruct(X, Y, Z, N+1, N+1, N+1, /*POLY_BLOCK*/CLAYER_BLOCK);
		//sm->GetLatticeBox3DStruct(pp, pp, pp, 2*(M+m+1), 2*(M+m+1), 2*(M+m+1), POLY_BLOCK/*CLAYER_BLOCK*/);
		//for (k = m; k <= 2*M+m; k++)
		//for (j = m; j <= 2*M+m; j++)
		//for (i = m; i <= 2*M+m; i++) 
		//	sm->SetBUniStruct(i+(2*(M+m)+1)*(j+(2*(M+m)+1)*k), CLAYER_BLOCK, ERR_GENUS);
		sm->SetBounding(par);
	}

///////////////////////////////////////////////////////
//...чтение модели и граничных условий из файла данных;
	if (sm && 0) {
		Message(" ");
		sprintf(buf, "Loading model from file '%s'", name);
		Message(buf);
		Message("Reading data file ...");

		sm->stru.nodes_in(name);
      sm->bar_condit_in(name);
		sm->LinkUniStruct();
		sm->SetBUniStruct(CLAYER_BLOCK);
		sm->SetGeomBounding(par);

		Message("Finish!");
	}

///////////////////////////
//...solving of the probem;
	for (int var = 50; var < 51; var++) {
		if (sm->computing_kernel(/*BASIC_COMPUT*/MAPPING_COMPUT/*PERIOD_COMPUT*/) != OK_STATE) {
			Message("Error in sample computing...");
			delete sm;
			goto err;
		}
#ifdef ___MPI_INIT___
		if (sm->solver.id_change == EXTERN_STATE) {
			CSlvParam params;
			params.msglev = 3;
			params.ittype = 2;
			params.sttype = 1;
			params.niter = 200;
			params.eps = 1.0e-9;

			params.tau1 = 1.0e-2;
			params.tau2 = 1.0e-3;
			params.theta = 0.10e0;

			char strbuff[256];
			sprintf (strbuff,"%s%i%s","BsSolver_",comm_mpi.GetMyid(),".dat");

			std::ofstream fout (strbuff);

			sm->shapes_init(NO_STATE); 
			BCM_draft<double> pBCM = {sm, MAPPING_COMPUT};
			//AbstractSolver		(& pBCM, 
			AbstractParSolver (& pBCM, 
									(void *)&comm_mpi,
									fout, params,
									Number_of_Blocks<double>, Blocks_Partitioning<double>, 
									Blocks_Sparsity<double>, Blocks_Row<double>, 
									Right_Handside<double>, Initial_Guess<double>, Store_Solution<double>);
			sm->shapes_init(OK_STATE); 
		}
#endif

//////////////////
//..visualization;
#ifdef ___MPI_INIT___
		if (comm_mpi.GetMyid() == 0) 
#endif
		{
			double K[6] = {0.,0.,0.,0.,0.,0.}, KH, kk, kk_low, kk_max, ff_vol;

			sm->GetRigidy(K, -1,		BASIC_COMPUT);
			sm->GetRigidy(K, -1, COVERING_COMPUT);

			ff_vol = (K[4]+K[5])/(K[3]+K[4]+K[5]);
			kk		 =  K[2]/(K[3]+K[4]+K[5]);
			kk_low = (K[3]+K[4]+K[5])/(K[3]/K1+K[4]/K2+K[5]/K3);
			kk_max = (K[3]*K1+K[4]*K2+K[5]*K3)/(K[3]+K[4]+K[5]);

			KH = sm->TakeEshelby_two(ff_vol);

			FILE *  TST = fopen("homog_heat.dat", "a");
			fprintf(TST, "%g    %g    %g    %g    %g\n", ff_vol, kk, KH, kk_low, kk_max);
			fclose (TST);

			nd->zero_grid();
			int id_visual = ! sm->solver.mode(TESTI_MODE) || 1;
			if (id_visual && 1) {//..visualization;
				sm->BlockActivate(NULL_STATE);

				int NX = 100, NY = 100, axis;
#ifdef ___LONGITUDINAL_SECTIOM___
				for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
				for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

				nd->add_new_point_Z((par[5]+par[4])*.5);
				nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

				for (i = 0; i < nd->N;  i++)
				for (j = 0; j < nd->N1; j++) {
					int hit = -1;
					sm->Poly_struc_in3D (hit, nd->X[i], nd->Y[j], nd->Z[0], NULL_STATE);
					nd->hit[i+j*nd->N] = hit;
				}
				axis = AXIS_Z;
#else
				if (1) {
					for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
					for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);

					nd->add_new_point_Z((par[3]+par[2])*.5);
					nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

					for (i = 0; i < nd->N;  i++)
					for (j = 0; j < nd->N1; j++) {
						int hit = -1;
						sm->Poly_struc_in3D (hit, nd->Y[j], nd->Z[0], nd->X[i], NULL_STATE);
						nd->hit[i+j*nd->N] = hit;
					}
					axis = AXIS_Y;
				}
				else {
					for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
					for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);

					nd->add_new_point_Z((par[1]+par[0])*.5);
					nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

					for (i = 0; i < nd->N;  i++)
					for (j = 0; j < nd->N1; j++) {
						int hit = -1;
						sm->Poly_struc_in3D (hit, nd->Z[0], nd->X[i], nd->Y[j]);
						nd->hit[i+j*nd->N] = hit;
					}
					axis = AXIS_X;
				}
#endif
				if (! sm->solver.mode(TESTI_MODE)) 
				system("del *.grd");
				//sm->GetSurferFormat("bb", nd,			  ERR_VALUE, 0, axis);
				sm->GetSurferFormat("rr", nd,			 HEAT_VALUE, 0, axis);
				sm->GetSurferFormat("pp", nd, FLUX_COMPOS_VALUE, 0, axis);
			}
			int id_lines = 0;
			if (id_lines) {//...одномерные графики;
				double F[3];
				FILE * TST = fopen("lines.dat", "w");
				for (i = 0; i < nd->N;  i++){
					sm->GetFuncAllValues(nd->X[i], nd->Y[nd->N1/2], 0., F, nd->hit[i+nd->N1/2*nd->N], HEAT_VALUE);
					fprintf(TST, "%g   %g", nd->X[i], F[0]);

					sm->GetFuncAllValues(nd->X[i], nd->Y[0], 0., F, nd->hit[i+0*nd->N], HEAT_VALUE);
					fprintf(TST, "   %g", F[0]);

					sm->GetFuncAllValues(nd->X[i], nd->Y[nd->N1/2], 0., F, nd->hit[i+nd->N1/2*nd->N], ANALYT_VALUE, 100);
					fprintf(TST, "   %g", F[0]);

					sm->GetFuncAllValues(nd->X[i], nd->Y[nd->N1/2], 0., F, nd->hit[i+nd->N1/2*nd->N], FLUX_X_VALUE);
					fprintf(TST, "   %g", F[0]);

					sm->GetFuncAllValues(nd->X[i], nd->Y[0], 0., F, nd->hit[i+0*nd->N], FLUX_X_VALUE);
					fprintf(TST, "   %g", F[0]);

					sm->GetFuncAllValues(nd->X[i], nd->Y[nd->N1/2], 0., F, nd->hit[i+nd->N1/2*nd->N], ANALYT_VALUE, 100);
					fprintf(TST, "   %g\n", F[1]);
				}
				fclose (TST);
			}
		}
	}
	delete sm;
	delete nd;
}
#endif
#ifdef LAME3D_RANDOM_STRUCTURE
{
	char * name = "./Box3d_homog/nano_35x25x246_octa.nas";
	double A = 1., B = 1., C = 1., rad = 0.1, ll = 0.05;
	int i = 0, j, k, m, num;

///////////////////////////
//...parameters of problem;
	double X[] = {0., 0.5, 1.}, Y[] = {0., 0.5, 1.}, Z[] = {0., 0.5, 1.}, par[6];
	//double nj1 = 0.300,  //...ледяная матрица; 
	//		 nj2 = 0.100,  //...минеральная частица (песок); 
	//		 nj3 = 0.499,  //...вода; 
	//		 E1   = 6.0,
	//		 E2   = 50.,
	//		 E3   = 1e-0/*5*/, 
	//double nj1 = 0.33, //...полимерная матрица; 
	//		 nj2 = 0.20, //...графитовое включение; 
	//		 nj3 = 0.30, //...межфазный слой; 
	//		 E1  = 18.,  //...GPa;
	//		 E2  = 380., //...GPa; 
	//		 E3  = 57.5, 
	double nj1 = 0.4999,	//...полимерная матрица; 
			 nj2 = 0.30,	//...графитовое включение; 
			 nj3 = 0.30,   //...межфазный слой; 
			 E1  = 0.135,
			 E2  = 31.0, 
			 E3  = 1.50, 
			 R1 = rad,		//...inclusion geometry;
			 R2 = rad+ll;	//...intermediate geometry; 

//////////////////////////
//...model initialization;
	CDraft<double> * sm = CreateDraftR(LAME3D_DRAFT, 7);
	sm->set_fasa_hmg(R1, R2, nj2, nj3, nj1, E2/(1.+nj2)*.5, E3/(1.+nj1)*.5, E1/(1.+nj1)*.5);
	sm->set_mpls(PackInts(2, 2));				//...space degree of multipoles;
	sm->set_quad(PackInts(4, 4));				//...N_elem, N_max -- parameters of quadrature;
	sm->set_normaliz(0.92);						//...normalization coefficient;
	sm->set_lagrange(1e5);						//...Lagrange coefficient for energy;
	sm->change_solv(/*ENERGY_SOLVING*//*PERIODIC_SOLVING*/SPECIAL_SOLVING);
	sm->solver.change_state(/*EXTERN_STATE*/);
	sm->solver.set_mode(REGULARIZATION | PRINT_MODE/*FULLY_MODE*//*| MASKS_MODE | ACCUMULATION*/);
	yes = 0;
	
/////////////////////////////////////////////////
//...задание модели и граничных условий функцией;
	if (sm && 1) {
		sm->GetLatticeBox3DStruct(X, Y, Z, 2, 2, 2/*, CLAYER_BLOCK*/);
		sm->SetBounding(par);

		sm->SetBUniStruct (CLAYER_BLOCK, ERR_GENUS);
		//for (i = 0; i < sm->N; i++)
		//sm->SetBUniStruct(i, POLY_BLOCK, ERR_GENUS);
	}

///////////////////////////////////////////////////////
//...чтение модели и граничных условий из файла данных;
	if (sm && 0) {
		Message(" ");
		sprintf(buf, "Loading model from file '%s'", name);
		Message(buf);
		Message("Reading data file ...");

		sm->stru.nodes_in(name);
      sm->bar_condit_in(name);
		sm->LinkUniStruct();
		sm->SetBUniStruct(/*CLAYER_BLOCK*/);
		sm->SetGeomBounding(par);

		Message("Finish!");
	}

////////////////////////////
//...solving of the problem;
	if (sm->computing_kernel(/*BASIC_COMPUT*//*MAPPING_COMPUT*/PERIOD_COMPUT) != OK_STATE) {
		Message("Error in sample computing...");
		delete sm;
		goto err;
	}
#ifdef ___MPI_INIT___
		if (sm->solver.id_change == EXTERN_STATE) {
		CSlvParam params;
		params.msglev = 3;
		params.ittype = 2;
		params.sttype = 1;
		params.niter = 700;
		params.eps = 1.0e-9;

		params.tau1 = 1.0e-2;
		params.tau2 = 1.0e-3;
		params.theta = 0.10e0;

		char strbuff[256];
		sprintf (strbuff,"%s%i%s","BsSolver_",comm_mpi.GetMyid(),".dat");

		std::ofstream fout (strbuff);
		params.collap = 4;

		sm->shapes_init(NO_STATE); 
		BCM_draft<double> pBCM = {sm, PERIOD_COMPUT};
		AbstractParSolver (& pBCM, 
								(void *)&comm_mpi,
								fout, params,
								Number_of_Blocks<double>, Blocks_Partitioning<double>, 
								Blocks_Sparsity<double>, Blocks_Row<double>, 
								Right_Handside<double>, Initial_Guess<double>, Store_Solution<double>);
		sm->shapes_init(OK_STATE); 
		}
#endif

//////////////////
//..visualization;
#ifdef ___MPI_INIT___
	if (comm_mpi.GetMyid() == 0) 
#endif
	{
		int id_visual = 1;
		if (id_visual) {
			CGrid * nd = CreateNodes();
			int NX = 100, NY = 100, axis;

			sm->BlockActivate();

#ifdef ___LONGITUDINAL_SECTIOM___
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->add_new_point_Z((par[5]+par[4])*.5);
			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

			for (i = 0; i < nd->N;  i++)
			for (j = 0; j < nd->N1; j++) {
				int hit = -1;
				sm->Poly_struc_in3D (hit, nd->X[i], nd->Y[j], nd->Z[0]);
				nd->hit[i+j*nd->N] = hit;
			}
			axis = AXIS_Z;
#else
			if (1) {
				for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
				for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);

				nd->add_new_point_Z((par[3]+par[2])*.5);
				nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

				for (i = 0; i < nd->N;  i++)
				for (j = 0; j < nd->N1; j++) {
					int hit = -1;
					sm->Poly_struc_in3D (hit, nd->Y[j], nd->Z[0], nd->X[i], NULL_STATE);
					nd->hit[i+j*nd->N] = hit;
				}
				axis = AXIS_Y;
			}
			else {
				for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
				for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);

				nd->add_new_point_Z((par[1]+par[0])*.5);
				nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

				for (i = 0; i < nd->N;  i++)
				for (j = 0; j < nd->N1; j++) {
					int hit = -1;
					sm->Poly_struc_in3D (hit, nd->Z[0], nd->X[i], nd->Y[j]);
					nd->hit[i+j*nd->N] = hit;
				}
				axis = AXIS_X;
			}
#endif
			system("del *.grd");
			//sm->GetSurferFormat("bb", nd,	     ERR_VALUE, 0, axis);
			sm->GetSurferFormat("rr", nd,    DISPL_VALUE, 0, axis);
			sm->GetSurferFormat("tz", nd, STRESS_Z_VALUE, 0, axis);
			
			delete nd;
		}
	}
	delete sm;
}
#endif
#ifdef HEAT3D_RANDOM_HOMOGENIZATION
{
	double rad = 0.1, ll = 0.05, section = 0., section_I = 0., section_II = 0., K1 = 1., K2 = 20., K3 = 0.01, lagrange = 1e5, par[8];
	int i, j, NX = 100, NY = 100, id_visual = 0, N0 = 15, N_elem = 8, N_max = 4, axis = AXIS_Y, axis_I = AXIS_Z, axis_II = AXIS_X;
	char name[2000]; name[0] = 0;
//////////////////////////////////
//...reading model from data-file;
   sprintf(buf, "Reading data...");
   Message(" ");
   Message(buf);

	unsigned long count, upper_limit;
	char        * id_DATA = read_struct_ascii("heat3d_initial.dat");
	if         (! id_DATA) {
		sprintf(buf, "Data not found..");
		Message(" ");
		Message(buf);
		sprintf(buf, "Creating data file \"heat3d_initial.dat\"...");
		Message(buf);
		Message(" ");

		FILE  * TST = fopen("heat3d_initial.dat", "w");
		fprintf(TST, "N = %i\nN_elem = %i\nN_max = %i\nlagrange = %g\n\n", N0, N_elem, N_max, lagrange);
		fprintf(TST, "id_visual = %i\nNX = %i\nNY = %i\naxis = %i  axis_I = %i  axis_II = %i\nsection = %g  section_I = %g  section_II = %g\n\n", 
			id_visual, NX, NY, axis, axis_I, axis_II, section, section_I, section_II);
		fprintf(TST, "K_matrix = %g\nK_inclusion = %g\nK_layer = %g\n\n", K1, K2, K3);
		fprintf(TST, "structure = %s\n\n", name);
		fclose (TST);

		printf("N = %i\nN_elem = %i\nN_max = %i\nlagrange = %g\n\n", N0, N_elem, N_max, lagrange);
		printf("id_visual = %i\nNX = %i\nNY = %i\naxis = %i  axis_I = %i  axis_II = %i\nsection = %g  section_I = %g  section_II = %g\n\n", 
			id_visual, NX, NY, axis, axis_I, axis_II, section, section_I, section_II);
		printf("K_matrix = %g\nK_inclusion = %g\nK_layer = %gn\\n", K1, K2, K3);
		printf("structure = %s\n\n", name);

		goto test;
	}
	user_Count    (id_DATA, 0, upper_limit, '\x0');
	if (user_Count(id_DATA, count = 0, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) N0 = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) N_elem = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) N_max = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) lagrange = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) id_visual = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) NX = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) NY = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) axis = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) axis_I = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) axis_II = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) section = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) section_I = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) section_II = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) K1 = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) K2 = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) K3 = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') &&  
		user_Read (buf, id_DATA, count, upper_limit, NULL_STATE)) ::strcpy(name, buf);

///////////////////////////////////////
//...creating model from initiual data;
test:
	CDraft<double> * sm = CreateDraftR(HEAT3D_DRAFT, 7);
	sm->set_fasa_hmg(rad, rad+ll, K1, K2, K3);//...parameters of problem;
	sm->set_mpls(PackInts(N0, N0));				//...space degree of multipoles;
	sm->set_quad(PackInts(N_elem, N_max));		//...N_elem, N_max -- parameters of quadrature;
	sm->set_normaliz(0.92);							//...normalization coefficient;
	sm->set_lagrange(lagrange);					//...Lagrange coefficient for energy;
	sm->change_solv (lagrange ? E_PERIODIC_SOLVING : PERIODIC_SOLVING);
	sm->solver.change_state(EXTERN_STATE);
	sm->solver.set_mode(REGULARIZATION/* | *//*PRINT_MODE*//*FULLY_MODE*//* | MASKS_MODE*//* | ACCUMULATION*/);
	//yes = 0;

///////////////////////////////////////////////////////////////////////////////////////////////
//...зачитываем структуру вкллючений (и переустанавливаем геометрию включений по первой точке);
	CGrid * nd_stru = CreateNodes();
			  nd_stru->stru_in(name, par);
	sm->set_geometry(rad = nd_stru->get_param(0, 0), ll = nd_stru->get_param(1, 0));

//////////////////////////////////////////////
//...построение решетки для системы включений;
	CGrid * lt = CreateNodes();
			  lt->grid_lattice(nd_stru, par);

/////////////////////////////////////////////////
//...задание модели и граничных условий функцией;
	if (sm) {
		sm->GetLatticeBox3DStruct(lt->X, lt->Y, lt->Z, lt->N, lt->N1, lt->N2, CLAYER_BLOCK);
		sm->SetBounding(par);
		//sm->SetBUniStruct (CLAYER_BLOCK, ERR_GENUS);
	}
	delete nd_stru;
	delete lt;

///////////////////////////
//...solving of the probem;
	res = system("mkdir ./bcm_results/heat3d_homog"); Num_Comput temp_comput;
	if (sm->computing_kernel(temp_comput = sm->N > 1 ? MAPPING_COMPUT : PERIOD_COMPUT) != OK_STATE) {
		Message("Error in sample computing...");
		delete sm;
		goto err;
	}
#ifdef ___MPI_INIT___
	if (sm->solver.id_change == EXTERN_STATE) {
		CSlvParam params;
		params.msglev = 3;
		params.ittype = 2;
		params.sttype = 1;
		params.niter = 700;
		params.eps = 1.0e-9;

		params.tau1 = 1.0e-2;
		params.tau2 = 1.0e-3;
		params.theta = 0.10e0;

		char strbuff[256];
		sprintf (strbuff,"%s%i%s","BsSolver_",comm_mpi.GetMyid(),".dat");

		std::ofstream fout (strbuff);
		params.collap = 4;

		sm->shapes_init(NO_STATE); 
		BCM_draft<double> pBCM = {sm, temp_comput};
		AbstractParSolver (& pBCM, 
								(void *)&comm_mpi,
								fout, params,
								Number_of_Blocks<double>, Blocks_Partitioning<double>, 
								Blocks_Sparsity<double>, Blocks_Row<double>, 
								Right_Handside<double>, Initial_Guess<double>, Store_Solution<double>);
		sm->shapes_init(OK_STATE); 
	}
#endif

//////////////////
//..visualization;
#ifdef ___MPI_INIT___
	if (comm_mpi.GetMyid() == 0) 
#endif
	{
		double K[7] = {0.,0.,0.,0.,0.,0.}, KH, kk, kk_low, kk_max; K[6] = (par[1]-par[0])*.5;

		sm->GetRigidy(K, -1,		BASIC_COMPUT);
		sm->GetRigidy(K, -1, COVERING_COMPUT);

		kk		 =  K[2]/(K[3]+K[4]+K[5]);
		kk_low = (K[3]+K[4]+K[5])/(K[3]/K1+K[4]/K2+K[5]/K3);
		kk_max = (K[3]*K1+K[4]*K2+K[5]*K3)/(K[3]+K[4]+K[5]);

		KH = sm->TakeEshelby(par[6], par[7]);

		FILE * TST = fopen("./bcm_results/heat3d_homog/heat3d_homog.dat", "a");
		if (TST) fprintf(TST, "%g    %g    %g    %g    %g\n", par[6], kk, KH, kk_low, kk_max);
		if (TST)	fclose (TST);

//////////////////
//..visualization;
		if (id_visual) { //..visualization;
			CGrid * nd = CreateNodes();
			if (axis == AXIS_Z) {
				for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
				for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);
				nd->add_new_point_Z(par[4]+(par[5]-par[4])*(1.+section)*.5);
			}
			if (axis == AXIS_Y) {
				for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
				for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);
				nd->add_new_point_Z(par[2]+(par[3]-par[2])*(1.+section)*.5);
			}
			if (axis == AXIS_X) {
				for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
				for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);
				nd->add_new_point_Z(par[0]+(par[1]-par[0])*(1.+section)*.5);
			}
			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
			for (i = 0; i < nd->N;  i++)
			for (j = 0; j < nd->N1; j++) {
				int hit = -1;
				if (axis == AXIS_Z) sm->Poly_struc_in3D(hit, nd->X[i], nd->Y[j], nd->Z[0], NULL_STATE); else
				if (axis == AXIS_Y) sm->Poly_struc_in3D(hit, nd->Y[j], nd->Z[0], nd->X[i], NULL_STATE); else
				if (axis == AXIS_X) sm->Poly_struc_in3D(hit, nd->Z[0], nd->X[i], nd->Y[j], NULL_STATE);
				nd->hit[i+j*nd->N] = hit;
			}
			sm->GetSurferFormat("./bcm_results/heat3d_homog/rr", nd,		  HEAT_VALUE, 0, axis);
			sm->GetSurferFormat("./bcm_results/heat3d_homog/pp", nd, FLUX_COMPOS_VALUE, 0, axis);

///////////////////////////////////////////
//...дополнительные сечения I (если нужно);
			if (id_visual > 1) { 
				nd->zero_grid();
				if (axis_I == AXIS_Z) {
					for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
					for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);
					nd->add_new_point_Z(par[4]+(par[5]-par[4])*(1.+section_I)*.5);
				}
				if (axis_I == AXIS_Y) {
					for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
					for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);
					nd->add_new_point_Z(par[2]+(par[3]-par[2])*(1.+section_I)*.5);
				}
				if (axis_I == AXIS_X) {
					for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
					for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);
					nd->add_new_point_Z(par[0]+(par[1]-par[0])*(1.+section_I)*.5);
				}
				nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
				for (i = 0; i < nd->N;  i++)
				for (j = 0; j < nd->N1; j++) {
					int hit = -1;
					if (axis_I == AXIS_Z) sm->Poly_struc_in3D(hit, nd->X[i], nd->Y[j], nd->Z[0], NULL_STATE); else
					if (axis_I == AXIS_Y) sm->Poly_struc_in3D(hit, nd->Y[j], nd->Z[0], nd->X[i], NULL_STATE); else
					if (axis_I == AXIS_X) sm->Poly_struc_in3D(hit, nd->Z[0], nd->X[i], nd->Y[j], NULL_STATE);
					nd->hit[i+j*nd->N] = hit;
				}
				sm->GetSurferFormat("./bcm_results/heat3d_homog/rr_I", nd,			 HEAT_VALUE, 0, axis_I);
				sm->GetSurferFormat("./bcm_results/heat3d_homog/pp_I", nd, FLUX_COMPOS_VALUE, 0, axis_I);

////////////////////////////////////////////
//...дополнительные сечения II (если нужно);
				if (id_visual > 2) { 
					nd->zero_grid();
					if (axis_II == AXIS_Z) {
						for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
						for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);
						nd->add_new_point_Z(par[4]+(par[5]-par[4])*(1.+section_II)*.5);
					}
					if (axis_II == AXIS_Y) {
						for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
						for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);
						nd->add_new_point_Z(par[2]+(par[3]-par[2])*(1.+section_II)*.5);
					}
					if (axis_II == AXIS_X) {
						for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
						for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);
						nd->add_new_point_Z(par[0]+(par[1]-par[0])*(1.+section_II)*.5);
					}
					nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
					for (i = 0; i < nd->N;  i++)
					for (j = 0; j < nd->N1; j++) {
						int hit = -1;
						if (axis_II == AXIS_Z) sm->Poly_struc_in3D(hit, nd->X[i], nd->Y[j], nd->Z[0], NULL_STATE); else
						if (axis_II == AXIS_Y) sm->Poly_struc_in3D(hit, nd->Y[j], nd->Z[0], nd->X[i], NULL_STATE); else
						if (axis_II == AXIS_X) sm->Poly_struc_in3D(hit, nd->Z[0], nd->X[i], nd->Y[j], NULL_STATE);
						nd->hit[i+j*nd->N] = hit;
					}
					sm->GetSurferFormat("./bcm_results/heat3d_homog/rr_II", nd,			 HEAT_VALUE, 0, axis_I);
					sm->GetSurferFormat("./bcm_results/heat3d_homog/pp_II", nd, FLUX_COMPOS_VALUE, 0, axis_I);
				}
			}
			delete nd;
		}
	}
	delete sm;
}
#endif
#ifdef LAME3D_RANDOM_HOMOGENIZATION
{
	double rad = 0.1, ll = 0.05, section = 0., section_I = 0., section_II = 0., nj1 = 0.3, nj2 = 0.3, nj3 = 0.3, E1 = 1.0, E2 = 2.0, E3 = 3.0, lagrange = 0, par[8];
	int i, j, NX = 100, NY = 100, id_visual = 0, N0 = 7, N_elem = 8, N_max = 4, axis = AXIS_Y, axis_I = AXIS_Z, axis_II = AXIS_X;
	char name[2000]; name[0] = 0;
//////////////////////////////////
//...reading model from data-file;
   sprintf(buf, "Reading data...");
   Message(" ");
   Message(buf);

	unsigned long count, upper_limit;
	char        * id_DATA = read_struct_ascii("lame3d_initial.dat");
	if         (! id_DATA) {
		sprintf(buf, "Data not found..");
		Message(" ");
		Message(buf);
		sprintf(buf, "Creating data file \"lame3d_initial.dat\"...");
		Message(buf);
		Message(" ");

		FILE  * TST = fopen("lame3d_initial.dat", "w");
		fprintf(TST, "N = %i\nN_elem = %i\nN_max = %i\nlagrange = %g\n\n", N0, N_elem, N_max, lagrange);
		fprintf(TST, "id_visual = %i\nNX = %i\nNY = %i\naxis = %i  axis_I = %i  axis_II = %i\nsection = %g  section_I = %g  section_II = %g\n\n", 
			id_visual, NX, NY, axis, axis_I, axis_II, section, section_I, section_II);
		fprintf(TST, "E_matrix = %g     \tnju_matrix = %g\nE_inclusion = %g     \tnju_inclusion = %g\nE_layer = %g     \tnju_layer = %g\n\n", E1, nj1, E2, nj2, E3, nj3);
		fprintf(TST, "structure = %s\n\n", name);
		fclose (TST);

		printf("N = %i\nN_elem = %i\nN_max = %i\nlagrange = %g\n\n", N0, N_elem, N_max, lagrange);
		printf("id_visual = %i\nNX = %i\nNY = %i\naxis = %i  axis_I = %i  axis_II = %i\nsection = %g  section_I = %g  section_II = %g\n\n", 
			id_visual, NX, NY, axis, axis_I, axis_II, section, section_I, section_II);
		printf("E_matrix = %g     \tnju_matrix = %g\nE_inclusion = %g     \tnju_inclusion = %g\nE_layer = %g     \tnju_layer = %g\n\n", E1, nj1, E2, nj2, E3, nj3);
		printf("structure = %s\n\n", name);

		goto test;
	}
	user_Count    (id_DATA, 0, upper_limit, '\x0');
	if (user_Count(id_DATA, count = 0, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) N0 = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) N_elem = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) N_max = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) lagrange = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) id_visual = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) NX = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) NY = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) axis = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) axis_I = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) axis_II = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) section = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) section_I = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) section_II = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) E1 = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) nj1 = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) E2 = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) nj2 = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) E3 = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) nj3 = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') &&  
		user_Read (buf, id_DATA, count, upper_limit, NULL_STATE)) ::strcpy(name, buf);

///////////////////////////////////////
//...creating model from initiual data;
test:
	CDraft<double> * sm = CreateDraftR(LAME3D_DRAFT, 8);
	sm->set_fasa_hmg(rad, rad+ll, nj2, nj3, nj1, E2/(1.+nj2)*.5, E3/(1.+nj3)*.5, E1/(1.+nj1)*.5);//...parameters of problem;
	sm->set_mpls(PackInts(N0, N0));				//...space degree of multipoles;
	sm->set_quad(PackInts(N_elem, N_max));		//...N_elem, N_max -- parameters of quadrature;
	sm->set_normaliz(0.92);							//...normalization coefficient;
	sm->set_lagrange(lagrange);					//...Lagrange coefficient for energy;
	sm->change_solv (lagrange ? E_PERIODIC_SOLVING : PERIODIC_SOLVING);
	sm->solver.change_state(EXTERN_STATE);
	sm->solver.set_mode(REGULARIZATION/* | PRINT_MODE*//*FULLY_MODE*//* | MASKS_MODE*//* | ACCUMULATION*/);
	yes = 0;

///////////////////////////////////////////////////////////////////////////////////////////////
//...зачитываем структуру вкллючений (и переустанавливаем геометрию включений по первой точке);
	CGrid * nd_stru = CreateNodes();
			  nd_stru->stru_in(name, par);
	sm->set_geometry(rad = nd_stru->get_param(0, 0), ll = nd_stru->get_param(1, 0));

//////////////////////////////////////////////
//...построение решетки для системы включений;
	CGrid * lt = CreateNodes();
			  lt->grid_lattice(nd_stru, par);

/////////////////////////////////////////////////
//...задание модели и граничных условий функцией;
	if (sm) {
		sm->GetLatticeBox3DStruct(lt->X, lt->Y, lt->Z, lt->N, lt->N1, lt->N2, CLAYER_BLOCK);
		sm->SetBounding(par);
		sm->SetBUniStruct (CLAYER_BLOCK, ERR_GENUS);
	}
	delete nd_stru;
	delete lt;

///////////////////////////
//...solving of the probem;
	res = system("mkdir ./bcm_results/lame3d_homog"); Num_Comput temp_comput;
	if (sm->computing_kernel(temp_comput = sm->N > 1 ? MAPPING_COMPUT : PERIOD_COMPUT) != OK_STATE) {
		Message("Error in sample computing...");
		delete sm;
		goto err;
	}
#ifdef ___MPI_INIT___
	if (sm->solver.id_change == EXTERN_STATE) {
		CSlvParam params;
		params.msglev = 3;
		params.ittype = 2;
		params.sttype = 1;
		params.niter = 1000;
		params.eps = 1.0e-9;

		params.tau1 = 1.0e-2;
		params.tau2 = 1.0e-3;
		params.theta = 0.10e0;

		char strbuff[256];
		sprintf (strbuff,"%s%i%s","BsSolver_",comm_mpi.GetMyid(),".dat");

		std::ofstream fout (strbuff);
		params.collap = 4;

		sm->shapes_init(NO_STATE); 
		BCM_draft<double> pBCM = {sm, temp_comput};
		AbstractParSolver (& pBCM, 
								(void *)&comm_mpi,
								fout, params,
								Number_of_Blocks<double>, Blocks_Partitioning<double>, 
								Blocks_Sparsity<double>, Blocks_Row<double>, 
								Right_Handside<double>, Initial_Guess<double>, Store_Solution<double>);
		sm->shapes_init(OK_STATE); 
	}
#endif

//////////////////
//..visualization;
#ifdef ___MPI_INIT___
	if (comm_mpi.GetMyid() == 0) 
#endif
	{
//////////////////////////////////////////
//..вычисляем эффективные модули композита;
			double K[28], E0, nu, K0, m0, mu, lm, C0, KH, EH, mH, nH; memset(K, 0, 28*sizeof(double)); K[27] = (par[1]-par[0])*.5;
			sm->GetRigidy(K, -1, BASIC_COMPUT);
			sm->GetRigidy(K, -1, COVERING_COMPUT);
			
			C0 = (K[5]-2.*K[0]*K[6]/(K[6]+K[11]))/(K[11]-2.*K[6]*K[6]/(K[6]+K[11]));
			lm = (K[0]-C0*K[6])/(K[6]+K[11]);
			nu = lm/(C0+lm);
			E0 = C0*(1.-2.*nu)*(1.+nu)/(1.-nu);
			K0 = E0/(3.*(1.-2.*nu));
			m0 = E0/(2.*(1.+nu));
			mu = K[15]/K[21]*.5;

////////////////////////////////////////
//...четырехфазная модель, метод Эшелби;
			KH = sm->TakeEshelby_volm(par[6], par[7]);
			mH = sm->TakeEshelby_shear_two(par[6]+par[7]);
			//mH = sm->TakeEshelby_shear(par[6], par[7]);
			EH = 9.*KH*mH/(3.*KH+mH);
			nH = (1.5*KH-mH)/(3.*KH+mH);

			FILE * TST = fopen("./bcm_results/lame3d_homog/lame3d_homog.dat", "a");
			if (TST) fprintf(TST, "rad = %g  ll = %g  E0 = %g  nu = %g  K0 = %g  m0 = %g  mu = %g  EH = %g  KH = %g  (%g, %g, %g, %g, %g, %g) (N = %i)\n", 
										  rad, ll, E0, nu, K0, m0, mu, EH, KH, E1, nj1, E2, nj2, E3, nj3, N0);
			if (TST) fclose (TST);

//////////////////
//..visualization;
		if (id_visual) { //..visualization;
			CGrid * nd = CreateNodes();
			if (axis == AXIS_Z) {
				for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
				for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);
				nd->add_new_point_Z(par[4]+(par[5]-par[4])*(1.+section)*.5);
			}
			if (axis == AXIS_Y) {
				for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
				for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);
				nd->add_new_point_Z(par[2]+(par[3]-par[2])*(1.+section)*.5);
			}
			if (axis == AXIS_X) {
				for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
				for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);
				nd->add_new_point_Z(par[0]+(par[1]-par[0])*(1.+section)*.5);
			}
			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
			for (i = 0; i < nd->N;  i++)
			for (j = 0; j < nd->N1; j++) {
				int hit = -1;
				if (axis == AXIS_Z) sm->Poly_struc_in3D(hit, nd->X[i], nd->Y[j], nd->Z[0], NULL_STATE); else
				if (axis == AXIS_Y) sm->Poly_struc_in3D(hit, nd->Y[j], nd->Z[0], nd->X[i], NULL_STATE); else
				if (axis == AXIS_X) sm->Poly_struc_in3D(hit, nd->Z[0], nd->X[i], nd->Y[j], NULL_STATE);
				nd->hit[i+j*nd->N] = hit;
			}
			sm->GetSurferFormat("./bcm_results/lame3d_homog/rz", nd,	   DISPL_VALUE, 0, axis);
			sm->GetSurferFormat("./bcm_results/lame3d_homog/rx", nd,	   DISPL_VALUE, 1, axis);
			sm->GetSurferFormat("./bcm_results/lame3d_homog/tz", nd, STRESS_Z_VALUE, 0, axis);
			sm->GetSurferFormat("./bcm_results/lame3d_homog/tx", nd, STRESS_X_VALUE, 1, axis);

///////////////////////////////////////////
//...дополнительные сечения I (если нужно);
			if (id_visual > 1) { 
				nd->zero_grid();
				if (axis_I == AXIS_Z) {
					for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
					for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);
					nd->add_new_point_Z(par[4]+(par[5]-par[4])*(1.+section_I)*.5);
				}
				if (axis_I == AXIS_Y) {
					for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
					for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);
					nd->add_new_point_Z(par[2]+(par[3]-par[2])*(1.+section_I)*.5);
				}
				if (axis_I == AXIS_X) {
					for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
					for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);
					nd->add_new_point_Z(par[0]+(par[1]-par[0])*(1.+section_I)*.5);
				}
				nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
				for (i = 0; i < nd->N;  i++)
				for (j = 0; j < nd->N1; j++) {
					int hit = -1;
					if (axis_I == AXIS_Z) sm->Poly_struc_in3D(hit, nd->X[i], nd->Y[j], nd->Z[0], NULL_STATE); else
					if (axis_I == AXIS_Y) sm->Poly_struc_in3D(hit, nd->Y[j], nd->Z[0], nd->X[i], NULL_STATE); else
					if (axis_I == AXIS_X) sm->Poly_struc_in3D(hit, nd->Z[0], nd->X[i], nd->Y[j], NULL_STATE);
					nd->hit[i+j*nd->N] = hit;
				}
				sm->GetSurferFormat("./bcm_results/lame3d_homog/rz_I", nd,	   DISPL_VALUE, 0, axis);
				sm->GetSurferFormat("./bcm_results/lame3d_homog/rx_I", nd,	   DISPL_VALUE, 1, axis);
				sm->GetSurferFormat("./bcm_results/lame3d_homog/tz_I", nd, STRESS_Z_VALUE, 0, axis);
				sm->GetSurferFormat("./bcm_results/lame3d_homog/tx_I", nd, STRESS_X_VALUE, 1, axis);

////////////////////////////////////////////
//...дополнительные сечения II (если нужно);
				if (id_visual > 2) { 
					nd->zero_grid();
					if (axis_II == AXIS_Z) {
						for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
						for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);
						nd->add_new_point_Z(par[4]+(par[5]-par[4])*(1.+section_II)*.5);
					}
					if (axis_II == AXIS_Y) {
						for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
						for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);
						nd->add_new_point_Z(par[2]+(par[3]-par[2])*(1.+section_II)*.5);
					}
					if (axis_II == AXIS_X) {
						for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
						for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);
						nd->add_new_point_Z(par[0]+(par[1]-par[0])*(1.+section_II)*.5);
					}
					nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
					for (i = 0; i < nd->N;  i++)
					for (j = 0; j < nd->N1; j++) {
						int hit = -1;
						if (axis_II == AXIS_Z) sm->Poly_struc_in3D(hit, nd->X[i], nd->Y[j], nd->Z[0], NULL_STATE); else
						if (axis_II == AXIS_Y) sm->Poly_struc_in3D(hit, nd->Y[j], nd->Z[0], nd->X[i], NULL_STATE); else
						if (axis_II == AXIS_X) sm->Poly_struc_in3D(hit, nd->Z[0], nd->X[i], nd->Y[j], NULL_STATE);
						nd->hit[i+j*nd->N] = hit;
					}
					sm->GetSurferFormat("./bcm_results/lame3d_homog/rz_II", nd,	   DISPL_VALUE, 0, axis);
					sm->GetSurferFormat("./bcm_results/lame3d_homog/rx_II", nd,	   DISPL_VALUE, 1, axis);
					sm->GetSurferFormat("./bcm_results/lame3d_homog/tz_II", nd, STRESS_Z_VALUE, 0, axis);
					sm->GetSurferFormat("./bcm_results/lame3d_homog/tx_II", nd, STRESS_X_VALUE, 1, axis);
				}
			}
			delete nd;
		}
	}
	delete sm;
}
#endif
#ifdef TEST_HEAT3D_RANDOM_HOMOGENIZATION
{
	int M = 3, M_max_add = 1, M_add;
	double A = 1., B = 1., C = 1., section = 0., section_I = 0., section_II = 0., K1 = 1., K2 = 20., K3 = 0.01, lagrange = 0, par[8], pp[2], cc_rad = .05, ll_rad = 7., c0, c1;
	int i, j, k, NX = 100, NY = 100, id_visual = 1, N0 = 5, N_elem = 4, N_max = 4, axis = AXIS_Y, axis_I = AXIS_Z, axis_II = AXIS_X;

//////////////////////////////////
//...reading model from data-file;
   sprintf(buf, "Reading data...");
   Message(" ");
   Message(buf);

	unsigned long count, upper_limit;
	char        * id_DATA = read_struct_ascii("lame3d_initial.dat");
	if         (! id_DATA) {
		sprintf(buf, "Data not found..");
		Message(" ");
		Message(buf);
		sprintf(buf, "Creating data file \"lame3d_initial.dat\"...");
		Message(buf);
		Message(" ");

		FILE  * TST = fopen("lame3d_initial.dat", "w");
		fprintf(TST, "N = %i\nN_elem = %i\nN_max = %i\nlagrange = %g\n\n", N0, N_elem, N_max, lagrange);
		fprintf(TST, "id_visual = %i\nNX = %i\nNY = %i\naxis = %i  axis_I = %i  axis_II = %i\nsection = %g  section_I = %g  section_II = %g\n\n", 
			id_visual, NX, NY, axis, axis_I, axis_II, section, section_I, section_II);
		fprintf(TST, "K_matrix = %g\nK_inclusion = %g\nK_layer = %g\ncc_rad = %g     \tll_rad = %g\n\n", K1, K2, K3, cc_rad, ll_rad);
		fprintf(TST, "M = %i\nM_max_add = %i\n\n", M, M_max_add);
		fclose (TST);

		printf("N = %i\nN_elem = %i\nN_max = %i\nlagrange = %g\n\n", N0, N_elem, N_max, lagrange);
		printf("id_visual = %i\nNX = %i\nNY = %i\naxis = %i  axis_I = %i  axis_II = %i\nsection = %g  section_I = %g  section_II = %g\n\n", 
			id_visual, NX, NY, axis, axis_I, axis_II, section, section_I, section_II);
		printf("K_matrix = %g\nK_inclusion = %g\nK_layer = %g\ncc_rad = %g     \tll_rad = %g\n\n", K1, K2, K3, cc_rad, ll_rad);
		printf("M = %i\nM_max_add = %i\n\n", M, M_max_add);

		goto test;
	}
	user_Count    (id_DATA, 0, upper_limit, '\x0');
	if (user_Count(id_DATA, count = 0, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) N0 = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) N_elem = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) N_max = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) lagrange = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) id_visual = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) NX = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) NY = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) axis = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) axis_I = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) axis_II = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) section = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) section_I = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) section_II = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) K1 = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) K2 = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) K3 = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) cc_rad = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) ll_rad = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) M = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) M_max_add = atoi(buf);

///////////////////////////////////////
//...creating model from initiual data;
test:
	CDraft<double> * sm = CreateDraftR(HEAT3D_DRAFT, 8);
	sm->set_fasa_hmg(pp[0] = cc_rad/(2.*M), pp[1] = (ll_rad+1.)*cc_rad/(2.*M), K1, K2, K3);//...parameters of problem;
	sm->set_mpls(PackInts(N0, N0));				//...space degree of multipoles;
	sm->set_quad(PackInts(N_elem, N_max));		//...N_elem, N_max -- parameters of quadrature;
	sm->set_normaliz(0.92);							//...normalization coefficient;
	sm->set_lagrange(lagrange);					//...Lagrange coefficient for energy;
	sm->change_solv (lagrange ? E_PERIODIC_SOLVING : PERIODIC_SOLVING);
	sm->solver.change_state(EXTERN_STATE);
	sm->solver.set_mode(REGUL_BOUNDARY/* | REDUCED_PRINT | PRINT_MODE | FULLY_MODE*//* | TESTI_GRAM*//* | MASKS_MODE*//* | ACCUMULATION*/);
	yes = 0;

////////////////////
//...печатаем шапку;
	res = system("mkdir ./bcm_results");
	res = system("mkdir ./bcm_results/heat3d_homog");
	FILE * TST = fopen("./bcm_results/heat3d_homog/heat3d_homog.dat", "a");
	if (TST) fprintf(TST, "c0,              c1,            kk,         kH,          kk_low,      kk_max,      (N = %i, K_matrix = %g, K_inclu = %g, K_layer = %g))\n", N0, K1, K2, K3);
	if (TST)	fclose (TST);

//////////////////////////////////
//...цикл по параметру аггрегации;
	for (k = 0; k <= M_max_add; k++) {
		M_add = k;

////////////////////////////////////////////////////////////////////////////
//...генерим структуру вкллючений (и переустанавливаем геометрию включений);
		CGrid * nd_stru = CreateNodes(); nd_stru->add_params(2);
		par[0] = 0.; par[1] = A;
		par[2] = 0.; par[3] = B;
		par[4] = 0.; par[5] = C;
		for (int mZ = 1; mZ < 2*(M+2*M_add); mZ += 2) 
		for (int mY = 1; mY < 2*(M+2*M_add); mY += 2)
		for (int mX = 1; mX < 2*(M+2*M_add); mX += 2)
			if (nd_stru->add_new_point(mX/(2.*(M+2*M_add)), mY/(2.*(M+2*M_add)), mZ/(2.*(M+2*M_add)), 0., 0., 1., pp)) nd_stru->hit[nd_stru->N-1] = nd_stru->N;

//////////////////////////////////////////////
//...построение решетки для системы включений;
		CGrid * lt = CreateNodes();
				  lt->grid_lattice(nd_stru, par);
		if (! k) {
			c0 = par[6]; c1 = par[7];
		}

/////////////////////////////////////////////////
//...задание модели и граничных условий функцией;
		if (sm) {
			sm->GetLatticeBox3DStruct(lt->X, lt->Y, lt->Z, lt->N, lt->N1, lt->N2, CLAYER_BLOCK);
			sm->SetBUniStruct (POLY_BLOCK, ERR_GENUS);
			for (int mZ = M_add; mZ < M+M_add; mZ++) 
			for (int mY = M_add; mY < M+M_add; mY++)
			for (int mX = M_add; mX < M+M_add; mX++)
				sm->SetBUniStruct(mX+(M+2*M_add)*(mY+(M+2*M_add)*mZ), CLAYER_BLOCK, ERR_GENUS);
		}
		delete nd_stru;
		delete lt;

///////////////////////////
//...solving of the probem;
		Num_Comput temp_comput;
		if (sm->computing_kernel(temp_comput = sm->N > 1 ? MAPPING_COMPUT : PERIOD_COMPUT) != OK_STATE) {
			Message("Error in sample computing...");
			delete sm;
			goto err;
		}
#ifdef ___MPI_INIT___
		if (sm->solver.id_change == EXTERN_STATE) {
			CSlvParam params;
			params.msglev = 3;
			params.ittype = 2;
			params.sttype = 1;
			params.niter = 1500;
			params.eps = 1.0e-12;

			params.tau1 = 1.0e-2;
			params.tau2 = 1.0e-4;
			params.theta = 0.10e0;

			char strbuff[256];
			sprintf (strbuff,"%s%i%s","BsSolver_",comm_mpi.GetMyid(),".dat");

			std::ofstream fout (strbuff);
			params.collap = 4;

			sm->shapes_init(NO_STATE); 
			BCM_draft<double> pBCM = {sm, temp_comput};
			AbstractParSolver (& pBCM, 
									(void *)&comm_mpi,
									fout, params,
									Number_of_Blocks<double>, Blocks_Partitioning<double>, 
									Blocks_Sparsity<double>, Blocks_Row<double>, 
									Right_Handside<double>, Initial_Guess<double>, Store_Solution<double>);
			sm->shapes_init(OK_STATE); 
		}
#endif

//////////////////
//..visualization;
#ifdef ___MPI_INIT___
		if (comm_mpi.GetMyid() == 0) 
#endif
		{
			double K[7] = {0.,0.,0.,0.,0.,0.}, kH, kk, kk_low, kk_max; K[6] = (par[1]-par[0])*.5;

			sm->GetRigidy(K, -1,		BASIC_COMPUT);
			sm->GetRigidy(K, -1, COVERING_COMPUT);

			kk		 =  K[2]/(K[3]+K[4]+K[5]);
			kk_low = (K[3]+K[4]+K[5])/(K[3]/K1+K[4]/K2+K[5]/K3);
			kk_max = (K[3]*K1+K[4]*K2+K[5]*K3)/(K[3]+K[4]+K[5]);

			kH = sm->TakeEshelby(c0, c1);

			FILE * TST = fopen("./bcm_results/heat3d_homog/heat3d_homog.dat", "a");
			if (TST) fprintf(TST, "%g,    %g,    %g,    %g,    %g,    %g\n", c0, c1, kk, kH, kk_low, kk_max);
			if (TST)	fclose (TST);

	//////////////////
	//..visualization;
			if (id_visual) { //..visualization;
			CGrid * nd = CreateNodes();
				if (axis == AXIS_Z) {
					for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
					for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);
					nd->add_new_point_Z(par[4]+(par[5]-par[4])*(1.+section)*.5);
				}
				if (axis == AXIS_Y) {
					for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
					for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);
					nd->add_new_point_Z(par[2]+(par[3]-par[2])*(1.+section)*.5);
				}
				if (axis == AXIS_X) {
					for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
					for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);
					nd->add_new_point_Z(par[0]+(par[1]-par[0])*(1.+section)*.5);
				}
				nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
				for (i = 0; i < nd->N;  i++)
				for (j = 0; j < nd->N1; j++) {
					int hit = -1;
					if (axis == AXIS_Z) sm->Poly_struc_in3D(hit, nd->X[i], nd->Y[j], nd->Z[0], NULL_STATE); else
					if (axis == AXIS_Y) sm->Poly_struc_in3D(hit, nd->Y[j], nd->Z[0], nd->X[i], NULL_STATE); else
					if (axis == AXIS_X) sm->Poly_struc_in3D(hit, nd->Z[0], nd->X[i], nd->Y[j], NULL_STATE);
					nd->hit[i+j*nd->N] = hit;
				}
				sprintf(buf, "./bcm_results/heat3d_homog/rr(%i)", k);	sm->GetSurferFormat(buf, nd, HEAT_VALUE, 0, axis);
				sprintf(buf, "./bcm_results/heat3d_homog/pp(%i)", k);	sm->GetSurferFormat(buf, nd, FLUX_COMPOS_VALUE, 0, axis);

	///////////////////////////////////////////
	//...дополнительные сечения I (если нужно);
				if (id_visual > 1) { 
					nd->zero_grid();
					if (axis_I == AXIS_Z) {
						for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
						for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);
						nd->add_new_point_Z(par[4]+(par[5]-par[4])*(1.+section_I)*.5);
					}
					if (axis_I == AXIS_Y) {
						for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
						for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);
						nd->add_new_point_Z(par[2]+(par[3]-par[2])*(1.+section_I)*.5);
					}
					if (axis_I == AXIS_X) {
						for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
						for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);
						nd->add_new_point_Z(par[0]+(par[1]-par[0])*(1.+section_I)*.5);
					}
					nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
					for (i = 0; i < nd->N;  i++)
					for (j = 0; j < nd->N1; j++) {
						int hit = -1;
						if (axis_I == AXIS_Z) sm->Poly_struc_in3D(hit, nd->X[i], nd->Y[j], nd->Z[0], NULL_STATE); else
						if (axis_I == AXIS_Y) sm->Poly_struc_in3D(hit, nd->Y[j], nd->Z[0], nd->X[i], NULL_STATE); else
						if (axis_I == AXIS_X) sm->Poly_struc_in3D(hit, nd->Z[0], nd->X[i], nd->Y[j], NULL_STATE);
						nd->hit[i+j*nd->N] = hit;
					}
					sprintf(buf, "./bcm_results/heat3d_homog/rr(%i)_I", k);	sm->GetSurferFormat(buf, nd, HEAT_VALUE, 0, axis_I);
					sprintf(buf, "./bcm_results/heat3d_homog/pp(%i)_I", k);	sm->GetSurferFormat(buf, nd, FLUX_COMPOS_VALUE, 0, axis_I);

	////////////////////////////////////////////
	//...дополнительные сечения II (если нужно);
					if (id_visual > 2) { 
						nd->zero_grid();
						if (axis_II == AXIS_Z) {
							for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
							for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);
							nd->add_new_point_Z(par[4]+(par[5]-par[4])*(1.+section_II)*.5);
						}
						if (axis_II == AXIS_Y) {
							for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
							for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);
							nd->add_new_point_Z(par[2]+(par[3]-par[2])*(1.+section_II)*.5);
						}
						if (axis_II == AXIS_X) {
							for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
							for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);
							nd->add_new_point_Z(par[0]+(par[1]-par[0])*(1.+section_II)*.5);
						}
						nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
						for (i = 0; i < nd->N;  i++)
						for (j = 0; j < nd->N1; j++) {
							int hit = -1;
							if (axis_II == AXIS_Z) sm->Poly_struc_in3D(hit, nd->X[i], nd->Y[j], nd->Z[0], NULL_STATE); else
							if (axis_II == AXIS_Y) sm->Poly_struc_in3D(hit, nd->Y[j], nd->Z[0], nd->X[i], NULL_STATE); else
							if (axis_II == AXIS_X) sm->Poly_struc_in3D(hit, nd->Z[0], nd->X[i], nd->Y[j], NULL_STATE);
							nd->hit[i+j*nd->N] = hit;
						}
						sprintf(buf, "./bcm_results/heat3d_homog/rr(%i)_II", k);	sm->GetSurferFormat(buf, nd, HEAT_VALUE, 0, axis_II);
						sprintf(buf, "./bcm_results/heat3d_homog/pp(%i)_II", k);	sm->GetSurferFormat(buf, nd, FLUX_COMPOS_VALUE, 0, axis_II);
					}
				}
				delete nd;
			}
		}
	}
	delete sm;
}
#endif
#ifdef TEST_LAME3D_RANDOM_HOMOGENIZATION
{
	int M = 3, M_max_add = 1, M_add;
	double A = 1., B = 1., C = 1., section = 0., section_I = 0., section_II = 0., nj1 = 0.3, nj2 = 0.3, nj3 = 0.3, E1 = 1.0, E2 = 2.0, E3 = 3.0, lagrange = 0, par[8], pp[2], cc_rad = .05, ll_rad = 7., c0, c1;
	int i, j, k, NX = 100, NY = 100, id_visual = 1, N0 = 5, N_elem = 4, N_max = 4, axis = AXIS_Y, axis_I = AXIS_Z, axis_II = AXIS_X;

//////////////////////////////////
//...reading model from data-file;
   sprintf(buf, "Reading data...");
   Message(" ");
   Message(buf);

	unsigned long count, upper_limit;
	char        * id_DATA = read_struct_ascii("lame3d_initial.dat");
	if         (! id_DATA) {
		sprintf(buf, "Data not found..");
		Message(" ");
		Message(buf);
		sprintf(buf, "Creating data file \"lame3d_initial.dat\"...");
		Message(buf);
		Message(" ");

		FILE  * TST = fopen("lame3d_initial.dat", "w");
		fprintf(TST, "N = %i\nN_elem = %i\nN_max = %i\nlagrange = %g\n\n", N0, N_elem, N_max, lagrange);
		fprintf(TST, "id_visual = %i\nNX = %i\nNY = %i\naxis = %i  axis_I = %i  axis_II = %i\nsection = %g  section_I = %g  section_II = %g\n\n", 
			id_visual, NX, NY, axis, axis_I, axis_II, section, section_I, section_II);
		fprintf(TST, "E_matrix = %g     \tnju_matrix = %g\nE_inclusion = %g     \tnju_inclusion = %g\nE_layer = %g     \tnju_layer = %g\ncc_rad = %g     \tll_rad = %g\n\n", E1, nj1, E2, nj2, E3, nj3, cc_rad, ll_rad);
		fprintf(TST, "M = %i\nM_max_add = %i\n\n", M, M_max_add);
		fclose (TST);

		printf("N = %i\nN_elem = %i\nN_max = %i\nlagrange = %g\n\n", N0, N_elem, N_max, lagrange);
		printf("id_visual = %i\nNX = %i\nNY = %i\naxis = %i  axis_I = %i  axis_II = %i\nsection = %g  section_I = %g  section_II = %g\n\n", 
			id_visual, NX, NY, axis, axis_I, axis_II, section, section_I, section_II);
		printf("E_matrix = %g     \tnju_matrix = %g\nE_inclusion = %g     \tnju_inclusion = %g\nE_layer = %g     \tnju_layer = %g\ncc_rad = %g     \tll_rad = %g\n\n", E1, nj1, E2, nj2, E3, nj3, cc_rad, ll_rad);
		printf("M = %i\nM_max_add = %i\n\n", M, M_max_add);

		goto test;
	}
	user_Count    (id_DATA, 0, upper_limit, '\x0');
	if (user_Count(id_DATA, count = 0, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) N0 = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) N_elem = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) N_max = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) lagrange = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) id_visual = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) NX = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) NY = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) axis = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) axis_I = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) axis_II = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) section = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) section_I = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) section_II = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) E1 = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) nj1 = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) E2 = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) nj2 = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) E3 = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) nj3 = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) cc_rad = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) ll_rad = user_strtod(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) M = atoi(buf);

	if (user_Count(id_DATA, count, count, '=') && 
		 user_Read (buf, id_DATA, count, upper_limit)) M_max_add = atoi(buf);

///////////////////////////////////////
//...creating model from initiual data;
test:
	CDraft<double> * sm = CreateDraftR(LAME3D_DRAFT, 8);
	sm->set_fasa_hmg(pp[0] = cc_rad/(2.*M), pp[1] = (ll_rad+1.)*cc_rad/(2.*M), 
		nj2, nj3, nj1, E2/(1.+nj2)*.5, E3/(1.+nj3)*.5, E1/(1.+nj1)*.5);//...parameters of problem;
	sm->set_mpls(PackInts(N0, N0));				//...space degree of multipoles;
	sm->set_quad(PackInts(N_elem, N_max));		//...N_elem, N_max -- parameters of quadrature;
	sm->set_normaliz(0.92);							//...normalization coefficient;
	sm->set_lagrange(lagrange);					//...Lagrange coefficient for energy;
	sm->change_solv (lagrange ? E_PERIODIC_SOLVING : PERIODIC_SOLVING);
	sm->solver.change_state(EXTERN_STATE);
	sm->solver.set_mode(REGUL_BOUNDARY/* | PRINT_MODE | REDUCED_PRINT | FULLY_MODE*//* | TESTI_GRAM*//* | MASKS_MODE*//* | ACCUMULATION*/);
	yes = 0;

////////////////////m
//...печатаем шапку;
#ifdef ___MPI_INIT___
	if (comm_mpi.GetMyid() == 0) 
#endif
	{
		res = system("mkdir ./bcm_results");
		res = system("mkdir ./bcm_results/lame3d_homog");
		FILE * TST = fopen("./bcm_results/lame3d_homog/lame3d_homog.dat", "a");
		if (TST) fprintf(TST, "c0,              c1,            E0,          EH,          E0_min,      E0_max,         K0,          KH,          m0,          mu,          nu,      (N = %i, E_matrix = %g, E_inclu = %g, E_layer = %g, nju_matrix = %g, nju_inclu = %g, nju_layer = %g))\n", 
									  N0, E1, E2, E3, nj1, nj2, nj3);
		if (TST)	fclose (TST);
	}

//////////////////////////////////
//...цикл по параметру аггрегации;
	for (k = 0; k <= M_max_add; k++) {
		M_add = k;

////////////////////////////////////////////////////////////////////////////
//...генерим структуру вкллючений (и переустанавливаем геометрию включений);
		CGrid * nd_stru = CreateNodes(); nd_stru->add_params(2);
		par[0] = 0.; par[1] = A;
		par[2] = 0.; par[3] = B;
		par[4] = 0.; par[5] = C;
		for (int mZ = 1; mZ < 2*(M+2*M_add); mZ += 2) 
		for (int mY = 1; mY < 2*(M+2*M_add); mY += 2)
		for (int mX = 1; mX < 2*(M+2*M_add); mX += 2)
			if (nd_stru->add_new_point(mX/(2.*(M+2*M_add)), mY/(2.*(M+2*M_add)), mZ/(2.*(M+2*M_add)), 0., 0., 1., pp)) nd_stru->hit[nd_stru->N-1] = nd_stru->N;

//////////////////////////////////////////////
//...построение решетки для системы включений;
		CGrid * lt = CreateNodes();
				  lt->grid_lattice(nd_stru, par);
		if (! k) {
			c0 = par[6]; c1 = par[7];
		}

/////////////////////////////////////////////////
//...задание модели и граничных условий функцией;
		if (sm) {
			sm->GetLatticeBox3DStruct(lt->X, lt->Y, lt->Z, lt->N, lt->N1, lt->N2, CLAYER_BLOCK);
			sm->SetBUniStruct (POLY_BLOCK, ERR_GENUS);
			for (int mZ = M_add; mZ < M+M_add; mZ++) 
			for (int mY = M_add; mY < M+M_add; mY++)
			for (int mX = M_add; mX < M+M_add; mX++)
				sm->SetBUniStruct(mX+(M+2*M_add)*(mY+(M+2*M_add)*mZ), CLAYER_BLOCK, ERR_GENUS);
		}
		delete nd_stru;
		delete lt;

///////////////////////////
//...solving of the probem;
		Num_Comput temp_comput;
		if (sm->computing_kernel(temp_comput = sm->N > 1 ? MAPPING_COMPUT : PERIOD_COMPUT) != OK_STATE) {
			Message("Error in sample computing...");
			delete sm;
			goto err;
		}
#ifdef ___MPI_INIT___
		if (sm->solver.id_change == EXTERN_STATE) {
			CSlvParam params;
			params.msglev = 3;
			params.ittype = 2;
			params.sttype = 1;
			params.niter = 1500;
			params.eps = 1.0e-12;

			params.tau1 = 1.0e-2;
			params.tau2 = 1.0e-4;
			params.theta = 0.10e0;

			char strbuff[256];
			sprintf (strbuff,"%s%i%s","BsSolver_",comm_mpi.GetMyid(),".dat");

			std::ofstream fout (strbuff);
			params.collap = 4;

			sm->shapes_init(NO_STATE); 
			BCM_draft<double> pBCM = {sm, temp_comput};
			AbstractParSolver (& pBCM, 
									(void *)&comm_mpi,
									fout, params,
									Number_of_Blocks<double>, Blocks_Partitioning<double>, 
									Blocks_Sparsity<double>, Blocks_Row<double>, 
									Right_Handside<double>, Initial_Guess<double>, Store_Solution<double>);
			sm->shapes_init(OK_STATE); 
		}
#endif

//////////////////
//..visualization;
#ifdef ___MPI_INIT___
		if (comm_mpi.GetMyid() == 0) 
#endif
		{
//////////////////////////////////////////
//..вычисляем эффективные модули композита;
			double K[28], E0, E0_min, E0_max, nu, K0, m0, mu, lm, C0, KH, EH, mH, nH; memset(K, 0, 28*sizeof(double)); K[27] = (par[1]-par[0])*.5;
			sm->GetRigidy(K, -1, BASIC_COMPUT);
			sm->GetRigidy(K, -1, COVERING_COMPUT);
			
			C0 = (K[5]-2.*K[0]*K[6]/(K[6]+K[11]))/(K[11]-2.*K[6]*K[6]/(K[6]+K[11]));
			lm = (K[0]-C0*K[6])/(K[6]+K[11]);
			nu = lm/(C0+lm);
			E0 = C0*(1.-2.*nu)*(1.+nu)/(1.-nu);
			K0 = E0/(3.*(1.-2.*nu));
			m0 = E0/(2.*(1.+nu));
			mu = K[15]/K[21]*.5;
			E0_min = (K[24]+K[25]+K[26])/(K[24]/E1+K[25]/E2+K[26]/E3);
			E0_max = (K[24]*E1+K[25]*E2+K[26]*E3)/(K[24]+K[25]+K[26]);

////////////////////////////////////////
//...четырехфазная модель, метод Эшелби;
			KH = sm->TakeEshelby_volm(par[6], par[7]);
			//mH = sm->TakeEshelby_shear_two(par[6]+par[7]);
			mH = sm->TakeEshelby_shear(par[6], par[7]);
			EH = 9.*KH*mH/(3.*KH+mH);
			nH = (1.5*KH-mH)/(3.*KH+mH);

			FILE * TST = fopen("./bcm_results/lame3d_homog/lame3d_homog.dat", "a");
			if (TST) fprintf(TST, "%g,    %g,    %g,    %g,    %g,    %g,  %g,    %g,    %g,    %g,    %g\n", 
											c0, c1, E0, EH, E0_min, E0_max, K0, KH, m0, mu, nu);
			if (TST)	fclose (TST);

	//////////////////
	//..visualization;
			if (id_visual) { //..visualization;
			CGrid * nd = CreateNodes();
				if (axis == AXIS_Z) {
					for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
					for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);
					nd->add_new_point_Z(par[4]+(par[5]-par[4])*(1.+section)*.5);
				}
				if (axis == AXIS_Y) {
					for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
					for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);
					nd->add_new_point_Z(par[2]+(par[3]-par[2])*(1.+section)*.5);
				}
				if (axis == AXIS_X) {
					for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
					for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);
					nd->add_new_point_Z(par[0]+(par[1]-par[0])*(1.+section)*.5);
				}
				nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
				for (i = 0; i < nd->N;  i++)
				for (j = 0; j < nd->N1; j++) {
					int hit = -1;
					if (axis == AXIS_Z) sm->Poly_struc_in3D(hit, nd->X[i], nd->Y[j], nd->Z[0], NULL_STATE); else
					if (axis == AXIS_Y) sm->Poly_struc_in3D(hit, nd->Y[j], nd->Z[0], nd->X[i], NULL_STATE); else
					if (axis == AXIS_X) sm->Poly_struc_in3D(hit, nd->Z[0], nd->X[i], nd->Y[j], NULL_STATE);
					nd->hit[i+j*nd->N] = hit;
				}
				sprintf(buf, "./bcm_results/lame3d_homog/rz(%i)", k);	sm->GetSurferFormat(buf, nd,    DISPL_VALUE, 0, axis);
				sprintf(buf, "./bcm_results/lame3d_homog/rx(%i)", k);	sm->GetSurferFormat(buf, nd,    DISPL_VALUE, 1, axis);
				sprintf(buf, "./bcm_results/lame3d_homog/tz(%i)", k);	sm->GetSurferFormat(buf, nd, STRESS_Z_VALUE, 0, axis);
				sprintf(buf, "./bcm_results/lame3d_homog/tx(%i)", k);	sm->GetSurferFormat(buf, nd, STRESS_X_VALUE, 1, axis);

	///////////////////////////////////////////
	//...дополнительные сечения I (если нужно);
				if (id_visual > 1) { 
					nd->zero_grid();
					if (axis_I == AXIS_Z) {
						for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
						for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);
						nd->add_new_point_Z(par[4]+(par[5]-par[4])*(1.+section_I)*.5);
					}
					if (axis_I == AXIS_Y) {
						for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
						for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);
						nd->add_new_point_Z(par[2]+(par[3]-par[2])*(1.+section_I)*.5);
					}
					if (axis_I == AXIS_X) {
						for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
						for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);
						nd->add_new_point_Z(par[0]+(par[1]-par[0])*(1.+section_I)*.5);
					}
					nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
					for (i = 0; i < nd->N;  i++)
					for (j = 0; j < nd->N1; j++) {
						int hit = -1;
						if (axis_I == AXIS_Z) sm->Poly_struc_in3D(hit, nd->X[i], nd->Y[j], nd->Z[0], NULL_STATE); else
						if (axis_I == AXIS_Y) sm->Poly_struc_in3D(hit, nd->Y[j], nd->Z[0], nd->X[i], NULL_STATE); else
						if (axis_I == AXIS_X) sm->Poly_struc_in3D(hit, nd->Z[0], nd->X[i], nd->Y[j], NULL_STATE);
						nd->hit[i+j*nd->N] = hit;
					}
					sprintf(buf, "./bcm_results/lame3d_homog/rz(%i)_I", k);	sm->GetSurferFormat(buf, nd,    DISPL_VALUE, 0, axis_I);
					sprintf(buf, "./bcm_results/lame3d_homog/rx(%i)_I", k);	sm->GetSurferFormat(buf, nd,    DISPL_VALUE, 1, axis_I);
					sprintf(buf, "./bcm_results/lame3d_homog/tz(%i)_I", k);	sm->GetSurferFormat(buf, nd, STRESS_Z_VALUE, 0, axis_I);
					sprintf(buf, "./bcm_results/lame3d_homog/tx(%i)_I", k);	sm->GetSurferFormat(buf, nd, STRESS_X_VALUE, 1, axis_I);

	////////////////////////////////////////////
	//...дополнительные сечения II (если нужно);
					if (id_visual > 2) { 
						nd->zero_grid();
						if (axis_II == AXIS_Z) {
							for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
							for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);
							nd->add_new_point_Z(par[4]+(par[5]-par[4])*(1.+section_II)*.5);
						}
						if (axis_II == AXIS_Y) {
							for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[5]-par[4])+par[4]);
							for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[1]-par[0])+par[0]);
							nd->add_new_point_Z(par[2]+(par[3]-par[2])*(1.+section_II)*.5);
						}
						if (axis_II == AXIS_X) {
							for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[3]-par[2])+par[2]);
							for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[5]-par[4])+par[4]);
							nd->add_new_point_Z(par[0]+(par[1]-par[0])*(1.+section_II)*.5);
						}
						nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));
						for (i = 0; i < nd->N;  i++)
						for (j = 0; j < nd->N1; j++) {
							int hit = -1;
							if (axis_II == AXIS_Z) sm->Poly_struc_in3D(hit, nd->X[i], nd->Y[j], nd->Z[0], NULL_STATE); else
							if (axis_II == AXIS_Y) sm->Poly_struc_in3D(hit, nd->Y[j], nd->Z[0], nd->X[i], NULL_STATE); else
							if (axis_II == AXIS_X) sm->Poly_struc_in3D(hit, nd->Z[0], nd->X[i], nd->Y[j], NULL_STATE);
							nd->hit[i+j*nd->N] = hit;
						}
						sprintf(buf, "./bcm_results/lame3d_homog/rz(%i)_II", k);	sm->GetSurferFormat(buf, nd,    DISPL_VALUE, 0, axis_II);
						sprintf(buf, "./bcm_results/lame3d_homog/rx(%i)_II", k);	sm->GetSurferFormat(buf, nd,    DISPL_VALUE, 1, axis_II);
						sprintf(buf, "./bcm_results/lame3d_homog/tz(%i)_II", k);	sm->GetSurferFormat(buf, nd, STRESS_Z_VALUE, 0, axis_II);
						sprintf(buf, "./bcm_results/lame3d_homog/tx(%i)_II", k);	sm->GetSurferFormat(buf, nd, STRESS_X_VALUE, 1, axis_II);
					}
				}
				delete nd;
			}
		}
	}
	delete sm;
}
#endif
#ifdef DRAFT_LAME_ESHELBY_NONLINEAR_DIAGRAM
{
double glina[][2] = {{0.4506, 9.727 },{0.5719,10.2481},{0.7106,10.9429},{0.8492,11.6377},{0.9705,12.5062},{1.0745,13.201 },{1.1958,13.7221},{1.3345,14.4169},{1.5078,15.4591},
							{1.6464,16.1538},{1.7504,16.8486},{1.8718,17.5434},{2.1144,18.933 },{2.2704,19.6278},{2.513 ,20.8437},{2.6516,21.5385},
							{2.7903,22.4069},{3.0503,23.6228},{3.1716,24.3176},{3.2929,24.8387},{3.4315,25.5335},{3.5529,26.2283},{3.6915,26.9231},{3.8302,27.4442},
							{3.9341,28.139 },{4.0728,28.8337},{4.2114,29.3548},{4.3501,30.0496},{4.6447,31.2655},{4.8007,31.9603},{4.9393,32.4814},
							{5.0607,32.8288},{5.2166,33.5236},{5.338 ,34.0447},{5.4766,34.5658},{5.6153,35.0868},{5.7366,35.6079},{5.8925,36.3027},{6.1352,37.1712},
							{6.2738,37.5186},{6.4298,38.0397},{6.7244,39.0819},{6.8631,39.603 },{7.0191,39.9504},{7.1577,40.2978},{7.2964,40.8189},
							{7.6256,41.861 },{7.7816,42.3821},{7.9203,42.7295},{8.0589,43.0769},{8.2496,43.4243},{8.3882,43.7717},{8.5442,44.1191},{8.7002,44.6402},{8.8562,44.9876},
							{8.9775,45.335 },{9.1681,45.8561},{9.3241,46.2035},{9.4801,46.5509}};//...данные для модуля Юнга в MPa;
int N_glina = 59;

double dural[][2] = {{20.,72.},{100.,63.5},{350.,48.}}, //...данные для модуля Юнга в GPa, температура в C;
					A  = ((dural[0][1]-dural[1][1])/(dural[0][0]-dural[1][0])-(dural[0][1]-dural[2][1])/(dural[0][0]-dural[2][0]))/(dural[1][0]-dural[2][0]), 
					B  =  (dural[0][1]-dural[1][1])/(dural[0][0]-dural[1][0])-(dural[0][0]+dural[1][0])*A, 
					C  =   dural[0][1]-dural[0][0]*B-dural[0][0]*dural[0][0]*A;//...квадратичная аппроксимация;
int N_dural = 3;

double spinel[][2] = {{20.,250.},{350.,440.}};//...C/GPa;
int N_spinel = 2;
//////////////////
//...initial data;
	double nju1 = 0.36, //...полимерная матрица;
			 nju2 = 0.16, //...жесткое включение;  
			 nju3 = 0.30, //...промежуточный слой;  
			 E1   = 1.0,  //...модуль Юнга матрицы;
			 E2   = 380., //...модуль Юнга включения;
			 E3   = 1.0,  //...модуль Юнга промежуточного слоя;
			 K1   = E1/(3.*(1.-2.*nju1)),//...модуль Юнга матрицы;
			 K2   = E2/(3.*(1.-2.*nju2)),//...модуль Юнга включения;
			 K3   = E3/(3.*(1.-2.*nju3)),//...модуль Юнга промежуточного слоя;
			 G1   = E1/(2.*(1.+nju1)),   //...модуль сдвига матрицы;
			 G2   = E2/(2.*(1.+nju2)),   //...модуль сдвига включения;
			 G3   = E3/(2.*(1.+nju3)),   //...модуль сдвига промежуточного слоя;
			 l1   = 0.15,			//...доля межфазного слоя по отношению к радиусу включения;
			 c0   = 0.60,			//...volume fraction of inclusion; 
			 c1   = l1*(l1+2.),	//...volume fraction of interface layer; 
			 T0   = 20.0,			//...начальная температура среды;
			 KS, KC, KH, LH, nn, nc, ns, K_min, K_max, ES, EC, EH, GS, GC, GH, E_min, E_max, G_min, G_max;
	yes = 0;

/////////////////////
//...данные по слоям;
	const int N = 3;
	double ff[N] = {c0, c1, 1.-c1-c0}, kv[N] = {K2, K3, K1},
			 mu[N] = {G2, G3, G1}, nj[N] = {nju2, nju3, nju1}, ee[N] = {E2, E3, E1},
			 kp[N] = {G2/(1.-2.*nju2), G3/(1.-2.*nju3), G1/(1.-2.*nju1)},
			 kk[N] = {E2*(1.-nju2)/((1.+nju2)*(1.-2.*nju2)), E3*(1.-nju3)/((1.+nju3)*(1.-2.*nju3)), E1*(1.-nju1)/((1.+nju1)*(1.-2.*nju1))},
			 lm[N] = {G2*2.*nju2/(1.-2.*nju2), G3*2.*nju3/(1.-2.*nju3), G1*2.*nju1/(1.-2.*nju1)};

	//const int N = 2;
	//double ff[N] = {c0, 1.-c0}, kv[N] = {K2, K1}, mu[N] = {G2, G1}, 
	//		 kp[N] = {G2/(1.-2.*nju2), G1/(1.-2.*nju1)}, nj[N] = {nju2, nju1},
	//		 kk[N] = {E2*(1.-nju2)/((1.+nju2)*(1.-2.*nju2)), E1*(1.-nju1)/((1.+nju1)*(1.-2.*nju1))}, 
	//		 lm[N] = {G2*2.*nju2/(1.-2.*nju2), G1*2.*nju1/(1.-2.*nju1)};

///////////////////////////////
//...цикл по параметрам задачи;
	FILE * TST = fopen("homog_KK.dat", "w");
	FILE * TSE = fopen("homog_EE.dat", "w");
	for (int j = 20; j <= 350; j += 1) {
		T0 = j*.001*1000.; 
		//E1 = table_approx(T0, glina, N_glina)*0.001;
		E1 = ee[2] = C+(B+A*T0)*T0;
		E3 = ee[1] = table_approx(T0, spinel, N_spinel);
		kv[1] = K3 = E3/(3.*(1.-2.*nju3));
		kv[2] = K1 = E1/(3.*(1.-2.*nju1));
		mu[1] = G3 = E3/(2.*(1.+nju3));
		mu[2] = G1 = E1/(2.*(1.+nju1));
		kp[1] = G3/(1.-2.*nju3);
		kp[2] = G1/(1.-2.*nju1);
		kk[1] = E3*(1.-nju3)/((1.+nju3)*(1.-2.*nju3));
		kk[2] = E1*(1.-nju1)/((1.+nju1)*(1.-2.*nju1));
		lm[1] = G3*2.*nju3/(1.-2.*nju3);
		lm[2] = G1*2.*nju1/(1.-2.*nju1);

		KS = TakeSphere_KH(N, ff, kv, mu); 
		GS = TakeSphere_GH(N, ff, kv, mu, nj); 
		ES = 9.*KS*fabs(GS)/(3.*KS+fabs(GS));
		ns = (1.5*KS-fabs(GS))/(3.*KS+fabs(GS));

		KC = TakeCylinder_KH(N, ff, kp, mu); 
		GC = TakeCylinder_GH(N, ff, kp, mu, nj); 
		EC = fabs(GC)*(3.*KC-fabs(GC))/KC;
		nc = (1.-fabs(GC)/KC)*.5;

		KH = TakeCylinder_EH(N, ff, kk);	//...формула смеси, дополнительные характеристики в цилиндрической симметрии; 
		EH = TakeCylinder_EH(N, ff, ee);	//...формула смеси; 
		LH = TakeCylinder_LH(N, ff, lm, mu, nj);
		GH = TakeCylinder_GH(N, ff, mu, nj); //...продольный модуль сдвига; 
		nn = LH/(LH+KH);

		K_min = 1./(c0/K2+(1.-c0)/K1);
		K_max = c0*K2+(1.-c0)*K1;
		E_min = 1./(c0/E2+(1.-c0)/E1);
		E_max = c0*E2+(1.-c0)*E1;
		G_min = 1./(c0/G2+(1.-c0)/G1);
		G_max = c0*G2+(1.-c0)*G1;

  		fprintf(TST, " c0 = %g, l1 = %g, T0 = %g, KS = %g, KC = %g, KH = %g, LH = %g, GH = %g, K_min = %g, K_max = %g\n", c0, l1, T0, KS, KC, KH, LH, GH, K_min, K_max);
  		fprintf(TSE, " c0 = %g, l1 = %g, T0 = %g, ES = %g, EC = %g, EH = %g, ns = %g, nc = %g, nn = %g, E_min = %g, E_max = %g, G_min = %g, G_max = %g\n", c0, l1, T0, ES, EC, EH, ns, nc, nn, E_min, E_max, G_min, G_max);
	}
	fclose(TST);
	fclose(TSE);
}
#endif
#ifdef DRAFT_LAME_ESHELBY_COMPARISON_DIAGRAM
{
//////////////////
//...initial data;
	double nju1 = 0.48, //...полимерная матрица;
			 nju2 = 0.30, //...жесткое включение;  
			 E1   = 1.0,  //...модуль Юнга матрицы;
			 E2   = 20.0, //...модуль Юнга включения;
			 K1   = E1/(3.*(1.-2.*nju1)),//...модуль Юнга матрицы;
			 K2   = E2/(3.*(1.-2.*nju2)),//...модуль Юнга включения;
			 G1   = E1/(2.*(1.+nju1)),   //...модуль сдвига матрицы;
			 G2   = E2/(2.*(1.+nju2)),   //...модуль сдвига включения;
			 l1   = 0.10, //...доля межфазного слоя во включении;
			 l2   = 0.10, //...доля межфазного слоя по отношению к радиусу включения в матрице;
			 c0   = 0.10, //...volume fraction of inclusion; 
			 KS, KH, K0, ES, EH, E0, GS, GH, G0, ns, nn, n0, K_min, K_max, E_min, E_max, G_min, G_max;
	yes = 0;

///////////////////////////////
//...цикл по параметрам задачи;
	FILE * TST = fopen("homog_EE.dat", "w");
	for (int j = 1; j < 400; j += 1) {
		l2 = 0.066+j*.00001;

		KS = TakeSphere_volm_sym (c0, nju1, nju2, E1, E2, l1, l2);
		GS = TakeSphere_shear_sym(c0, nju1, nju2, E1, E2, l1, l2);
		ES = 9.*KS*fabs(GS)/(3.*KS+fabs(GS));
		ns = (1.5*KS-fabs(GS))/(3.*KS+fabs(GS));
		
		KH = TakeSphere_volm_two (c0, nju1, nju2, E1, E2, l1, l2);
		GH = TakeSphere_shear_two(c0, nju1, nju2, E1, E2, l1, l2);
		EH = 9.*KH*fabs(GH)/(3.*KH+fabs(GH));
		nn = (1.5*KH-fabs(GH))/(3.*KH+fabs(GH));
		
		K0 = TakeSphere_volm_two (c0, nju1, nju2, E1, E2, 0., 0.);
		G0 = TakeSphere_shear_two(c0, nju1, nju2, E1, E2, 0., 0.);
		E0 = 9.*K0*fabs(G0)/(3.*K0+fabs(G0));
		n0 = (1.5*K0-fabs(G0))/(3.*K0+fabs(G0));
		
		K_min = 1./(c0/K2+(1.-c0)/K1);
		K_max = c0*K2+(1.-c0)*K1;
		E_min = 1./(c0/E2+(1.-c0)/E1);
		E_max = c0*E2+(1.-c0)*E1;
		G_min = 1./(c0/G2+(1.-c0)/G1);
		G_max = c0*G2+(1.-c0)*G1;

  		//fprintf(TST, " c0 = %g, l1 = %g, l2 = %g, KS = %g, KH = %g, K0 = %g, ES = %g, EH = %g, E0 = %g, GS = %g, GH = %g, G0 = %g, KI = %g, KM = %g\n", 
				//			c0, l1, l2, KS, KH, K0, ES, EH, E0, GS, GH, G0, K2, K1);
  		//fprintf(TST, " c0 = %g, l1 = %g, l2 = %g, %g, %g, %g, %g, %g, %g, %g, %g, %g, KI = %g, KM = %g\n", 
				//			c0, l1, l2, KS, KH, K0, ES, EH, E0, GS, GH, G0, K2, K1);
  		fprintf(TST, " %g, %g, %g, %g, %g, %g, %g, %g, %g, %g\n", l2, KS, KH, K0, ES, EH, E0, GS, GH, G0);
	}
	fclose(TST);
}
#endif
#ifdef TEST_DRAFT_LAME_ESHELBY_INTERMEDIATE_PHASE
{
//////////////////
//...initial data;
	double nju1 = 0.40, //...полимерная матрица;
			 nju2 = 0.22, //...жесткое включение;  
			 nju3 = 0.30, //...промежуточный слой;  
			 E1   = 1.0,//...модуль Юнга матрицы;
			 E2   = 12.,//...модуль Юнга включения;
			 E3   = 1.0,//...модуль Юнга промежуточного слоя;
			 al1  = 0.001,//...KTE матрицы;
			 al2  = 0.010,//...KTE включения;
			 al3  = 0.0,  //...KTE промежуточного слоя;
			 K1   = E1/(3.*(1.-2.*nju1)),//...модуль Юнга матрицы;
			 K2   = E2/(3.*(1.-2.*nju2)),//...модуль Юнга включения;
			 K3   = E3/(3.*(1.-2.*nju3)),//...модуль Юнга промежуточного слоя;
			 G1   = E1/(2.*(1.+nju1)),   //...модуль сдвига матрицы;
			 G2   = E2/(2.*(1.+nju2)),   //...модуль сдвига включения;
			 G3   = E3/(2.*(1.+nju3)),   //...модуль сдвига промежуточного слоя;
			 l1	= 0.1,   //...interphase layer for matrix;
			 l2	= 0.03,  //...interphase layer for inclusion;
			 limit  = 10., //...maximal length of layer;
			 c0     = 0.20,//...volume fraction; 
			 GH = 0., GL, GS, GC, G0, G_min, G_max, KH, KL, KS, KC, K0, KK, K_min, K_max, EH, EL, ES, EC, E0, E_min, E_max, LH, L_min, L_max, nn;
		yes = 0;

/////////////////////
//...данные по слоям;
	//const int N = 3;
	//double ff[N] = {c0*.8, c0*.2, 1.-c0}, kv[N] = {K2, K3, K1},
	//		 mu[N] = {G2, G3, G1}, ll[N] = {l2, 0., l1}, nj[N] = {nju2, nju3, nju1}, 
	//		 kp[N] = {G2/(1.-2.*nju2), G3/(1.-2.*nju3), G1/(1.-2.*nju1)},
	//		 kk[N] = {E2*(1.-nju2)/((1.+nju2)*(1.-2.*nju2)), E3*(1.-nju3)/((1.+nju3)*(1.-2.*nju3)), E1*(1.-nju1)/((1.+nju1)*(1.-2.*nju1))},
	//		 lm[N] = {G2*2.*nju2/(1.-2.*nju2), G3*2.*nju3/(1.-2.*nju3), G1*2.*nju1/(1.-2.*nju1)};

	const int N = 2;
	double ff[N] = {c0, 1.-c0}, kv[N] = {K2, K1}, mu[N] = {G2, G1}, ll[N] = {l2, l1}, 
			 kp[N] = {G2/(1.-2.*nju2), G1/(1.-2.*nju1)}, nj[N] = {nju2, nju1},
			 kk[N] = {E2*(1.-nju2)/((1.+nju2)*(1.-2.*nju2)), E1*(1.-nju1)/((1.+nju1)*(1.-2.*nju1))}, 
			 lm[N] = {G2*2.*nju2/(1.-2.*nju2), G1*2.*nju1/(1.-2.*nju1)};

///////////////////////////////
//...цикл по параметрам задачи;
	FILE * TST = fopen("homog_KK.dat", "w");
	FILE * TSG = fopen("homog_GG.dat", "w");
	FILE * TSE = fopen("homog_EE.dat", "w");
	for (int j = 1; j < 1000; j += 1) {
		c0 = j*.001; 
		//l1 = j*.001*limit;
		
		//ff[0] = c0*.8; ff[1] = c0*.2; ff[2] = 1.-c0; ll[0] = l1;
		ff[0] = c0; ff[1] = 1.-c0; ll[0] = l1;
		E_min = TakeLayer_EH(N, ff, kk, NULL);
		KL = TakeLayer_EH(N, ff, kk, ll);
		GL = TakeLayer_EH(N, ff, mu, ll);
		EL = (3.*KL-4.*fabs(GL))*fabs(GL)/(KL-fabs(GL));
		E_max = TakeCylinder_EH(N, ff, kk);

		KH = TakeCylinder_EH(N, ff, kk); 
		KC = TakeCylinder_KH(N, ff, kp, mu); 
		KK = kp[1]+ff[0]*(kp[0]-kp[1])/(1.+ff[1]*(kp[0]-kp[1])/(kp[1]+mu[1]));
		GC = TakeCylinder_GH(N, ff, kp, mu, nj); 
		EC = fabs(GC)*(3.*KC-fabs(GC))/KC;
		LH = TakeCylinder_LH(N, ff, lm, mu, nj);
		KK = lm[1]+ff[0]*(lm[0]-lm[1])/(1.+ff[1]*(kp[0]-kp[1])/(kp[1]+mu[1]));
		nn = LH/(LH+KH);
		GH = TakeCylinder_EH(N, ff, mu); 
		GH = TakeCylinder_GH(N, ff, mu, nj); 

		KS = TakeSphere_KH(N, ff, kv, mu); 
		GS = TakeSphere_GH(N, ff, kv, mu, nj); 
		G0 = TakeSphere_GH_det(c0, nju1, nju2, E1, E2); 
		ES = 9.*KS*fabs(GS)/(3.*KS+fabs(GS));
		KK = kv[1]+ff[0]*(kv[0]-kv[1])/(1.+ff[1]*(kv[0]-kv[1])/(kv[1]+4./3.*mu[1]));

		K_min = 1./(c0/K2+(1.-c0)/K1);
		K_max = c0*K2+(1.-c0)*K1;

		G_min = 1./(c0/G2+(1.-c0)/G1);
		G_max = c0*G2+(1.-c0)*G1;

		KH = TakeSphere_volm_sym (c0, nju1, nju2, E1, E2, l1, l2);
		GH = TakeSphere_shear_sym(c0, nju1, nju2, E1, E2, l1, l2);
		EH = 9.*KH*fabs(GH)/(3.*KH+fabs(GH));
		//KH = TakeSphere_volm_two (c0, nju1, nju2, E1, E2, l1, l2);
		//GH = TakeSphere_shear_two(c0, nju1, nju2, E1, E2, l1, l2);

		K0 = TakeSphere_volm_sym (c0, nju1, nju2, E1, E2, 0., 0.);
		G0 = TakeSphere_shear_sym(c0, nju1, nju2, E1, E2, 0., 0.);
		E0 = 9.*K0*G0/(3.*K0+G0);

		E_min = 1./(c0/E2+(1.-c0)/E1);
		E_max = c0*E2+(1.-c0)*E1;

  		fprintf(TST, " c0 = %g, KL = %g, KC = %g, KS = %g, KH = %g, K0 = %g, K_min = %g, K_max = %g\n", c0, KL, KC, KS, KH, K0, K_min, K_max);
  		fprintf(TSG, " c0 = %g, GL = %g, GC = %g, GS = %g, GH = %g, G0 = %g, G_min = %g, G_max = %g\n", c0, GL, GC, GS, GH, G0, G_min, G_max);
  		fprintf(TSE, " c0 = %g, EL = %g, EC = %g, ES = %g, EH = %g, E0 = %g, E_min = %g, E_max = %g, LH = %g, nn = %g\n", c0, EL, EC, ES, EH, E0, E_min, E_max, LH, nn);
	}
	fclose(TST);
	fclose(TSG);
	fclose(TSE);
}
#endif
#ifdef TEST_DRAFT_LAME_ESHELBY_INTERMEDIATE_PHASE_sph
{
//////////////////
//...initial data;
	double nju1 = 0.165,//...полимерная матрица;
			 nju2 = 0.12,//...жесткое включение;  
			 nju3 = 0.30,//...промежуточный слой;  
			 E1   = 73., //...модуль Юнга матрицы;
			 E2   = 480.,//...модуль Юнга включения;
			 E3   = 1.0, //...модуль Юнга промежуточного слоя;
			 al1  = 0.001,//...KTE матрицы;
			 al2  = 0.010,//...KTE включения;
			 al3  = 0.0,  //...KTE промежуточного слоя;
			 K1   = E1/(3.*(1.-2.*nju1)),//...модуль Юнга матрицы;
			 K2   = E2/(3.*(1.-2.*nju2)),//...модуль Юнга включения;
			 K3   = E3/(3.*(1.-2.*nju3)),//...модуль Юнга промежуточного слоя;
			 G1   = E1/(2.*(1.+nju1)),   //...модуль сдвига матрицы;
			 G2   = E2/(2.*(1.+nju2)),   //...модуль сдвига включения;
			 G3   = E3/(2.*(1.+nju3)),   //...модуль сдвига промежуточного слоя;
			 //l1	= 0.1,   //...interphase layer for matrix;
			 //l2	= 0.03,  //...interphase layer for inclusion;
			 l1	= 10.00,    //...interphase layer for matrix;
			 l2	= -0.03,    //...interphase layer for inclusion;
			 limit  = 10., //...maximal length of layer;
			 c0     = 0.20,//...volume fraction; 
			 GH = 0., GS, G0, KH, KS, K0, EH, ES, E0, E_min, E_max;
	yes = 0;

/////////////////////
//...данные по слоям;
	//const int N = 3;
	//double ff[N] = {c0*.8, c0*.2, 1.-c0}, kv[N] = {K2, K3, K1},
	//		 mu[N] = {G2, G3, G1}, ll[N] = {l2, 0., l1}, nj[N] = {nju2, nju3, nju1}, 
	//		 kp[N] = {G2/(1.-2.*nju2), G3/(1.-2.*nju3), G1/(1.-2.*nju1)},
	//		 kk[N] = {E2*(1.-nju2)/((1.+nju2)*(1.-2.*nju2)), E3*(1.-nju3)/((1.+nju3)*(1.-2.*nju3)), E1*(1.-nju1)/((1.+nju1)*(1.-2.*nju1))},
	//		 lm[N] = {G2*2.*nju2/(1.-2.*nju2), G3*2.*nju3/(1.-2.*nju3), G1*2.*nju1/(1.-2.*nju1)};

	const int N = 2;
	double ff[N] = {c0, 1.-c0}, kv[N] = {K2, K1}, mu[N] = {G2, G1}, ll[N] = {l2, l1}, 
			 kp[N] = {G2/(1.-2.*nju2), G1/(1.-2.*nju1)}, nj[N] = {nju2, nju1},
			 kk[N] = {E2*(1.-nju2)/((1.+nju2)*(1.-2.*nju2)), E1*(1.-nju1)/((1.+nju1)*(1.-2.*nju1))}, 
			 lm[N] = {G2*2.*nju2/(1.-2.*nju2), G1*2.*nju1/(1.-2.*nju1)};

///////////////////////////////
//...цикл по параметрам задачи;
	FILE * TST = fopen("homog_ALL.dat", "w");
	for (int j = 0; j <= 1000; j += 1) {
		c0 = j*.001; 
		//l1 = j*.001*limit;
		//ff[0] = c0*.8; ff[1] = c0*.2; ff[2] = 1.-c0; ll[0] = l1;

		ff[0] = c0; ff[1] = 1.-c0; ll[0] = l1;
		KH = TakeSphere_volm_two (c0, nju1, nju2, E1, E2, l1, l2);
		GH = TakeSphere_shear	 (c0, nju1, nju2, E1, E2, l1, l2);
		EH = 9.*KH*fabs(GH)/(3.*KH+fabs(GH));

		KS = TakeSphere_volm_sym (c0, nju1, nju2, E1, E2, l1, l2);
		GS = TakeSphere_shear_sym(c0, nju1, nju2, E1, E2, l1, l2);
		ES = 9.*KS*fabs(GS)/(3.*KS+fabs(GS));

		K0 = TakeSphere_volm_two (c0, nju1, nju2, E1, E2, 0., 0.);
		G0 = TakeSphere_shear    (c0, nju1, nju2, E1, E2, 0., 0.);
		E0 = 9.*K0*G0/(3.*K0+G0);

		E_min = 1./(c0/E2+(1.-c0)/E1);
		E_max = c0*E2+(1.-c0)*E1;

  		fprintf(TST, " c0 = %g, EH = %g, GH = %g, KH = %g, ES = %g, GS = %g, KS = %g, E0 = %g, G0 = %g, K0 = %g, E_min = %g, E_max = %g\n", c0, EH, GH, KH, ES, GS, KS, E0, G0, K0, E_min, E_max);
  		//fprintf(TST, " c0 = %g, GH = %g, GS = %g, G0 = %g\n", c0, GH, GS, G0);
	}
	fclose(TST);
}
#endif
#ifdef TEST_DRAFT_LAME_ESHELBY_INTERMEDIATE_PHASE_cyl
{
//////////////////
//...initial data;
	double nju1 = 0.32, //...полимерная матрица;
			 nju2 = 0.17, //...жесткое включение;  
			 nju3 = 0.30, //...промежуточный слой;  
			 E1   = 1.25, //...модуль Юнга матрицы;
			 E2   = 3900., //...модуль Юнга включения;
			 E3   = 60.,  //...модуль Юнга промежуточного слоя;
			 al1  = 0.001,//...KTE матрицы;
			 al2  = 0.010,//...KTE включения;
			 al3  = 0.0,  //...KTE промежуточного слоя;
			 K1   = E1/(3.*(1.-2.*nju1)),//...модуль Юнга матрицы;
			 K2   = E2/(3.*(1.-2.*nju2)),//...модуль Юнга включения;
			 K3   = E3/(3.*(1.-2.*nju3)),//...модуль Юнга промежуточного слоя;
			 G1   = E1/(2.*(1.+nju1)),   //...модуль сдвига матрицы;
			 G2   = E2/(2.*(1.+nju2)),   //...модуль сдвига включения;
			 G3   = E3/(2.*(1.+nju3)),   //...модуль сдвига промежуточного слоя;
			 l0	= 0.6,   //...относительная ширина межфазного слоя;
			 l1	= 0.1,   //...interphase layer for matrix;
			 l2	= 0.03,  //...interphase layer for inclusion;
			 limit  = 10., //...maximal length of layer;
			 c0     = 0.20,//...volume fraction; 
			 GH = 0., GG, G0, KH, KK, LH, EH, nu_H, nH;
	yes = 0;

/////////////////////
//...данные по слоям;
	//const int N = 3;
	//double ff[N] = {c0*.8, c0*.2, 1.-c0}, kv[N] = {K2, K3, K1},
	//		 mu[N] = {G2, G3, G1}, ll[N] = {l2, 0., l1}, nj[N] = {nju2, nju3, nju1}, 
	//		 kp[N] = {G2/(1.-2.*nju2), G3/(1.-2.*nju3), G1/(1.-2.*nju1)},
	//		 kk[N] = {E2*(1.-nju2)/((1.+nju2)*(1.-2.*nju2)), E3*(1.-nju3)/((1.+nju3)*(1.-2.*nju3)), E1*(1.-nju1)/((1.+nju1)*(1.-2.*nju1))},
	//		 lm[N] = {G2*2.*nju2/(1.-2.*nju2), G3*2.*nju3/(1.-2.*nju3), G1*2.*nju1/(1.-2.*nju1)};

	const int N = 2;
	double ff[N] = {c0, 1.-c0}, kv[N] = {K2, K1}, mu[N] = {G2, G1}, ll[N] = {l2, l1}, 
			 kp[N] = {G2/(1.-2.*nju2), G1/(1.-2.*nju1)}, nj[N] = {nju2, nju1},
			 kk[N] = {E2*(1.-nju2)/((1.+nju2)*(1.-2.*nju2)), E1*(1.-nju1)/((1.+nju1)*(1.-2.*nju1))}, 
			 lm[N] = {G2*2.*nju2/(1.-2.*nju2), G1*2.*nju1/(1.-2.*nju1)};

///////////////////////////////
//...цикл по параметрам задачи;
	FILE * TST = fopen("homog_ALL.dat", "w");
	for (int j = 0; j <= 1000; j += 1) {
		c0 = j*.001;
		//l0 = 1./sqrt(c0)-1.;
		//l1 = j*.001*limit;
		//ff[0] = c0; ff[1] = c0*l0*(l0+2.); ff[2] = 1.-c0-c0*l0*(l0+2.); ll[0] = l1;
		//ff[0] = c0; ff[1] = 0.1*(1.-c0); ff[2] = 0.9*(1.-c0); ll[0] = l1;
		
 		ff[0] = c0; ff[1] = 1.-c0; ll[0] = l1;
		KH = TakeCylinder_KH(N, ff, kp, mu); 
		GH = TakeCylinder_GH(N, ff, kp, mu, nj);
		G0 = TakeCylinder_SH(N, ff, kp, mu, nj);
		nH = (KH-GH)/(2.*KH);
		EH = fabs(GH)*(3*KH-fabs(GH))/KH;
		KK = TakeCylinder_EH(N, ff, kk); 
		LH = TakeCylinder_LH(N, ff, lm, mu, nj);
		GG = TakeCylinder_GH(N, ff, mu, nj);
		nu_H = LH/(2.*KH);
		
  		fprintf(TST, " c0 = %g, EH = %g, KH = %g, GH = %g, G0 = %g, nH = %g, KK = %g, GG = %g, LH = %g, nu_H = %g\n", c0, EH, KH, GH, G0, nH, KK, GG, LH, nu_H);
	}
	fclose(TST);
}
#endif
#ifdef TEST_DRAFT_LAME_ESHELBY_INTERMEDIATE_PHASE_layer
{
//////////////////
//...initial data;
	double nju1 = 0.21, //...полимерная матрица;
			 nju2 = 0.12, //...жесткое включение;  
			 nju3 = 0.30, //...промежуточный слой;  
			 E1   = 475., //...модуль Юнга матрицы;
			 E2   = 480., //...модуль Юнга включения;
			 E3   = 57.0, //...модуль Юнга промежуточного слоя;
			 al1  = 0.001,//...KTE матрицы;
			 al2  = 0.010,//...KTE включения;
			 al3  = 0.0,  //...KTE промежуточного слоя;
			 K1   = E1/(3.*(1.-2.*nju1)),//...модуль Юнга матрицы;
			 K2   = E2/(3.*(1.-2.*nju2)),//...модуль Юнга включения;
			 K3   = E3/(3.*(1.-2.*nju3)),//...модуль Юнга промежуточного слоя;
			 G1   = E1/(2.*(1.+nju1)),   //...модуль сдвига матрицы;
			 G2   = E2/(2.*(1.+nju2)),   //...модуль сдвига включения;
			 G3   = E3/(2.*(1.+nju3)),   //...модуль сдвига промежуточного слоя;
			 l1	= 1.0,   //...interphase layer for matrix;
			 l2	= 1.0,   //...interphase layer for inclusion;
			 l3	= 1.0,   //...interphase layer for interphase layer;
			 limit  = 10., //...maximal length of layer;
			 c0     = 0.20,//...volume fraction of interphase layer; 
			 c1     = 0.30,//...volume fraction of inclusion; 
			 GH = 0., G_min, G_max, KH, K_min, K_max, EH, E_min, E_max;
	yes = 0;

/////////////////////
//...данные по слоям;
	const int N = 3;
	double ff[N] = {c0*.8, c0*.2, 1.-c0}, kv[N] = {K2, K3, K1},
			 mu[N] = {G2, G3, G1}, ll[N] = {l2, l3, l1}, nj[N] = {nju2, nju3, nju1}, 
			 kp[N] = {G2/(1.-2.*nju2), G3/(1.-2.*nju3), G1/(1.-2.*nju1)},
			 kk[N] = {E2*(1.-nju2)/((1.+nju2)*(1.-2.*nju2)), E3*(1.-nju3)/((1.+nju3)*(1.-2.*nju3)), E1*(1.-nju1)/((1.+nju1)*(1.-2.*nju1))},
			 lm[N] = {G2*2.*nju2/(1.-2.*nju2), G3*2.*nju3/(1.-2.*nju3), G1*2.*nju1/(1.-2.*nju1)};

	//const int N = 2;
	//double ff[N] = {c0, 1.-c0}, mu[N] = {G2, G1}, ll[N] = {l2, l1}, 
	//		 kk[N] = {E2*(1.-nju2)/((1.+nju2)*(1.-2.*nju2)), E1*(1.-nju1)/((1.+nju1)*(1.-2.*nju1))};

///////////////////////////////
//...цикл по параметрам задачи;
	FILE * TST = fopen("homog_All.dat", "w");
	for (int j = 0; j <= 500; j += 1) {
		c0 = j*.001; 
		//l1 = j*.001*limit;
		
		ff[0] = c1; ff[1] = c0; ff[2] = 1.-c0-c1; ll[0] = l2;
		//ff[0] = c0; ff[1] = 1.-c0; ll[0] = l2;
		KH = TakeLayer_EH(N, ff, kk, ll);
		GH = TakeLayer_EH(N, ff, mu, ll);
		EH = (3.*KH-4.*fabs(GH))*fabs(GH)/(KH-fabs(GH));

		K_min = 1./(c0/kk[0]+(1.-c0)/kk[1]);
		K_max = c0*kk[0]+(1.-c0)*kk[1];

		G_min = 1./(c0/mu[0]+(1.-c0)/mu[1]);
		G_max = c0*mu[0]+(1.-c0)*mu[1];

		E_min = 1./(c0/E2+(1.-c0)/E1);
		E_max = c0*E2+(1.-c0)*E1;

  		fprintf(TST, " c0 = %g, KH = %g, K_min = %g, K_max = %g, GH = %g, G_min = %g, G_max = %g, EH = %g, E_min = %g, E_max = %g\n", 
							c0, KH, K_min, K_max, GH, G_min, G_max, EH, E_min, E_max);
	}
	fclose(TST);
}
#endif
#ifdef TEST_DRAFT_LAME_ESHELBY
{
//////////////////////////
//...model initialization;
	CDraft<double> * sm = CreateDraftR(/*MINDL3D_DRAFT*/COHES3D_DRAFT, 8),
						* el = CreateDraftR(LAME3D_DRAFT,  8);
	double nju1 = 0.4, //...полимерная матрица;
			 nju2 = 0.22, //...жесткое включение;  
			 K1   = 1.0,  //...объемный модуль матрицы;
			 K2   = 40., //...объемный модуль включения;
			 //E1   = 3.*(1.-2.*nju1)*K1,//...модуль Юнга матрицы;
			 //E2   = 3.*(1.-2.*nju2)*K2,//...модуль Юнга включения;
			 E1   = 1.0,//...модуль Юнга матрицы;
			 E2   = 56.,//...модуль Юнга включения;
			 AA	= E1*.0,			 //...adhegion parameter;
			 BB	= E1*.5/(1.+nju1)*.0,//...adhegion parameter;
			 l1	= 4.0,   //...interphase layer for matrix;
			 l2	= 0.03,   //...interphase layer for inclusion;
			 l1_dop = 0.,  //...interphase layer_dop;
			 l2_dop = 0.,  //...interphase layer_dop;
			 limit  = 10., //...maximal length of layer;
			 c0     = 0.1,//...volume fraction; 
			 G1, G2, GH = 0., KH, G0, K0, EH, nuH, E0, nu0;
	yes = 0;

///////////////////////////////
//...цикл по параметрам задачи;
	FILE * TST = fopen("mindl3D_homog.dat", "w");
	for (int j = 1; j <= 1000; j += 1) {
		//c0 = j*.001;
		l1 = (j*.001)*limit;
		//sm->set_fasa_hmg(nju1, nju2, G1 = E1/(1.+nju1)*.5, G2 = E2/(1.+nju2)*.5, l1, l1_dop = l1/sqrt(1.-2.*nju1), l2, l2_dop = l2/sqrt(1.-2.*nju2), AA, BB);
		sm->set_fasa_hmg(nju1, nju2, G1 = E1/(1.+nju1)*.5, G2 = E2/(1.+nju2)*.5, G1/sqr(l1), G2/sqr(l2));
		el->set_fasa_hmg(nju1, nju2, G1, G2);

		KH = sm->TakeEshelby_volm_two (c0);
		GH = sm->TakeEshelby_shear_two(c0);
		//GH = sm->TakeEshelby_shear_det(c0);

		K0 = el->TakeEshelby_volm_two (c0);
		G0 = el->TakeEshelby_shear_two(c0);

		EH = 9.*KH*fabs(GH)/(3.*KH+fabs(GH));
		E0 = 9.*K0*G0/(3.*K0+G0);

		nuH = (3.*KH-2.*fabs(GH))/(3.*KH+fabs(GH))*.5;
		nu0 = (3.*K0-2.*G0)/(3.*K0+G0)*.5;

  		fprintf(TST, " l1 = %g,  l1_dop = %g, l2 = %g,  l2_dop = %g, A = %g, B = %g, c0 = %g, KH = %g, K0 = %g, GH = %g, G0 = %g, EH = %g, E0 = %g, nuH = %g, nu0 = %g\n", 
				l1, l1_dop, l2, l2_dop, AA, BB, c0, KH, K0, GH, G0, EH, E0, nuH, nu0);
	}
	fclose (TST);
	delete sm;
	delete el;
}
#endif
#ifdef LAME3D_LAYERED_ESHELBY_HOMOGENIZATION
{
//////////////////////////
//...model initialization;
	CDraft<double> * sm = CreateDraftR(COHES3D_DRAFT, 8),
						* lm = CreateDraftR(LAME2D_DRAFT, 8);
	double nju1 = 0.30, //...полимерная матрица;
			 nju2 = 0.30, //...слой;
			 nju3 = 0.22, //...жесткое включение;  
			 E1   = 0.012,//...модуль Юнга матрицы;
			 E2   = 0.045,//...слой;
			 E3   = 30.,  //...модуль Юнга включения;
			 kk1	= E1*(.5+nju1)/(1.+nju1), //...модуль растяжения/сжатия матрицы;
			 kk2	= E2*(.5+nju2)/(1.+nju2), //...слой;
			 kk3	= E3*(.5+nju3)/(1.+nju3), //...модуль растяжения/сжатия включения;
			 l0	= 0.10, //...interphase layer;
			 c0   = 0.20, //...volume fraction; 
			 G1, G2, GH = 0., G0, EH, E_min, E_max, KH, KK = 0., KD;
	yes = 0;

///////////////////////////////
//...цикл по параметрам задачи;
	const int N = 3;
	double ff[N] = {(1.-c0)*2./3., (1.-c0)*1./3., c0}, kk[N] = {kk1, kk2, kk3}, ll[N] = {l0, l0, l0}, 
			 mu[N] = {2.*E1*(1.+nju1), 2.*E2*(1.+nju2), 2.*E3*(1.+nju3)}; 
	//double ff[N] = {(1.-c0), c0}, kk[N] = {kk1, kk2}, ll[N] = {l0, l0}, 
	//		 mu[N] = {2.*E1*(1.+nju1), 2.*E2*(1.+nju2)}; 
	FILE * TST = fopen("Layered_homog.dat", "w");
	for (int j = 0; j <= 1000; j += 1) {
		c0 = j*.001; ff[0] = (1.-c0)*2./3.; ff[1] = (1.-c0)*1./3.; ff[2] = c0;
		
		E_min = sm->TakeLayer_kk(N, ff, kk); E_max = 0.;
		EH = sm->TakeLayer_kk(N, ff, kk, ll);
		for (int i = 0; i < N; i++) E_max += ff[i]*kk[i];

		KH = lm->TakeLayer_kk(N, ff, kk, mu); GH = 0.;
		KD = ((kk[0]-kk[2])-ff[1]/(ff[0]+ff[1])*(1.+(kk[2]-kk[1])/(kk[1]+mu[1]))*(kk[0]-kk[1]))/(1.+ff[1]/(ff[0]+ff[1])*(kk[0]-kk[1])/(kk[1]+mu[1]));
		KK = kk[2]+(ff[0]+ff[1])*KD/(1.+ff[2]*KD/(kk[2]+mu[2]));
		//GH = lm->TakeLayer_GG(N, ff, kk, mu);

		lm->set_fasa_hmg(nju1, nju2, E1/(1.+nju1)*.5, E2/(1.+nju2)*.5, nju3, E3/(1.+nju3)*.5);
		KD = lm->TakeEshelby_volm(ff[0], ff[1]);

  		fprintf(TST, " l0 = %g, c0 = %g, EH = %g, E_min = %g, E_max = %g, KH = %g, GH = %g, KK = %g, KD = %g\n", l0, c0, EH, E_min, E_max, KH, GH, KK, KD);
	}
	fclose (TST);
	delete sm;
}
#endif
#ifdef ESHELBY_CALCULATIONS
{
//////////////////////////
//...model initialization;
	CDraft<double> * sm = CreateDraftR(MINDL3D_DRAFT, 8),
						* el = CreateDraftR(LAME3D_DRAFT,  8);
////////////////////////////////////////////////////////
//...данные для расчетов с дисперсными частицами - ВПМ2;
	//double nju1 = 0.33, //...полимерная матрица;
	//		 //E1   = 210., //...модуль Юнга полимерной матрицы (GPa), Т = 20С;
	//		 //E1   = 150., //...модуль Юнга полимерной матрицы (GPa), Т = 600С;
	//		 E1   = 30.,  //...модуль Юнга полимерной матрицы (GPa), Т = 1400/1300С;
	//		 AA	= E1*.0,			 //...adhegion parameter;
	//		 BB	= E1*.5/(1.+nju1)*.0,//...adhegion parameter;
	//		 l1	= 15.,  //...масштабный параметр матрицы (мкм), Т = 20С;
	//		 //l1	= 20.,  //...масштабный параметр матрицы (мкм), Т = 600С;
 //  		 //l1	= 25.,  //...масштабный параметр матрицы (мкм), Т = 1400/1300С;
	//		 l1_dop = 0.; //...interphase layer_dop;
///////////////////////////////////////////////////////////
//...данные для расчетов с дисперсными частицами - ВКНА-1У;
	double nju1 = 0.33, //...полимерная матрица;
			 //E1   = 150., //...модуль Юнга полимерной матрицы (GPa), Т = 20С;
			 //E1   = 135., //...модуль Юнга полимерной матрицы (GPa), Т = 600С;
			 E1   = 40.,  //...модуль Юнга полимерной матрицы (GPa), Т = 1400/1300С;
			 AA	= E1*.0,			 //...adhegion parameter;
			 BB	= E1*.5/(1.+nju1)*.0,//...adhegion parameter;
			 l1	= 15.,  //...масштабный параметр матрицы (мкм), Т = 20С;
			 //l1	= 20.,  //...масштабный параметр матрицы (мкм), Т = 600С;
 			 //l1	= 25.,  //...масштабный параметр матрицы (мкм), Т = 1400/1300С;
			 l1_dop = 0.; //...interphase layer_dop;
///////////////////////////////////////////////////////
//...данные для расчетов с дисперсными частицами - AL2O3;
	//double nju2 = 0.20, //...жесткое включение;  
	//		 E2   = 380., //...модуль Юнга жесткого включения (GPa);
	//		 l2	= 0.005,  //...масштабный параметр включений (мкм);
	//		 l2_dop	= 0., //...interphase layer_dop;
	//		 rad = 0.05,   //...характерный радиус включений (мкм); 
	//		 c0  = 0.035,  //...предельная концентрация включений; 
	//		 G1, G2, GH = 0., KH, G0, K0, EH, nuH, E0, nu0, ff, ll;
///////////////////////////////////////////////////////////
////...данные для расчетов с дисперсными частицами - Y2O3;
	double nju2 = 0.31, //...жесткое включение;  
			 //E2   = 225., //...модуль Юнга жесткого матрицы (GPa), Т = 20С;
			 //E2   = 215., //...модуль Юнга жесткого матрицы (GPa), Т = 600С;
			 E2   = 180.,  //...модуль Юнга жесткого матрицы (GPa), Т = 1400/1300С;
			 l2	= 0.005,  //...масштабный параметр включений (мкм);
			 l2_dop	= 0., //...interphase layer_dop;
			 rad = 0.025,   //...характерный радиус включений (мкм); 
			 c0  = 0.035,  //...предельная концентрация включений; 
			 G1, G2, GH = 0., KH, G0, K0, EH, nuH, E0, nu0, ff, ll;
	yes = 0;

///////////////////////////////  
//...цикл по параметрам задачи;
	FILE * TST = fopen("mindl3D_homog.dat", "w");
	for (int j = 0; j <= 500; j += 1) {
		ff = 0.02+j*.00003; ll = 10./*(l1/rad)*/;
	//for (int j = 1; j <= 2000; j += 1) {
	//	ll = (j*.0005)*10.; ff = c0;
		sm->set_fasa_hmg(nju1, nju2, G1 = E1/(1.+nju1)*.5, G2 = E2/(1.+nju2)*.5, ll, l1_dop = (l1_dop/rad)/sqrt(1.-2.*nju1), (l2/rad), l2_dop = (l2_dop/rad)/sqrt(1.-2.*nju2), AA, BB);
		el->set_fasa_hmg(nju1, nju2, G1, G2);

		KH = sm->TakeEshelby_volm_two (ff);
		GH = sm->TakeEshelby_shear_two(ff);

		K0 = el->TakeEshelby_volm_two (ff);
		G0 = el->TakeEshelby_shear_two(ff);

		EH = 9.*KH*fabs(GH)/(3.*KH+fabs(GH));
		E0 = 9.*K0*G0/(3.*K0+G0);

		nuH = (3.*KH-2.*fabs(GH))/(3.*KH+fabs(GH))*.5;
		nu0 = (3.*K0-2.*G0)/(3.*K0+G0)*.5;

  		fprintf(TST, " l1 = %g,  l1_dop = %g, l2 = %g,  l2_dop = %g, A = %g, B = %g, c0 = %g, KH = %g, K0 = %g, GH = %g, G0 = %g, EH = %g, E0 = %g, nuH = %g, nu0 = %g\n", 
				ll, l1_dop, (l2/rad), l2_dop, AA, BB, ff, KH, K0, GH, G0, EH, E0, nuH, nu0);
	}
	fclose (TST);
	delete sm;
	delete el;
}
#endif
#ifdef ALUMO_COMPOSITES_CALCULATIONS
{
//////////////////////////
//...model initialization;
	CDraft<double> * sm = CreateDraftR(COHES3D_DRAFT, 8),
						* el = CreateDraftR(LAME3D_DRAFT,  8);
//////////////////////////////////////////////////////////////
//...данные для расчетов с дисперсными частицами - матрица Al;
	double nju1 = 0.33, //...полимерная матрица;
			 nju3 = 0.30, //...межфазный слой;
			 E1   = 62.0, //...модуль Юнга мягкой матрицы (GPa);
			 //E1   = 70.0, //...модуль Юнга мягкой матрицы (GPa);
			 E3   = 89.2, //...модуль Юнга межфазного слоя (GPa);
			 G1   = E1/(1.+nju1)*.5,  //...модуль сдвига мягкой матрицы (GPa);
			 G3   = E3/(1.+nju3)*.5,  //...модуль сдвига межфазного слоя (GPa);
			 l1	= 0.2455,  //...размер межфазного слоя (мкм, 16.365*0.015);
			 eps	= 26.; //...пористость (%);
////////////////////////////////////////////////////////////////////
////...данные для расчетов с дисперсными частицами - матрица Al-B95;
//	double nju1 = 0.33, //...полимерная матрица;
//			 nju3 = 0.30, //...межфазный слой;
//			 E1   = 70.0, //...модуль Юнга мягкой матрицы (GPa);
//			 G1   = E1/(1.+nju1)*.5,  //...модуль сдвига мягкой матрицы (GPa);
//			 l1	= 0.160, //...размер межфазного слоя (мкм);
//			 rad0 = 0.800, //...радиус начала масштабного эффекта (мкм);
//			 rad1 = 1.00,  //...радиус окончания масштабного эффекта (мкм);
//			 rad_str	= 5.; //...размер зерна в структуре (мкм);
///////////////////////////////////////////////////////
//...данные для расчетов с дисперсными частицами - AL2O3;
	//double nju2 = 0.25, //...жесткое включение;  
	//		 E2   = 500., //...модуль Юнга жесткого включения (GPa);
	//		 G2   = E2/(1.+nju2)*.5,  //...модуль сдвига жесткого матрицы (GPa);
	//		 l2	= 0.0015, //...масштабный параметр включений (мкм);
	//		 rad = 0.1,  	 //...относительная ширина межфазной зоны;
	//		 c0  = 0.0001,  //...концентрация включений; 
	//		 С1, С2, GH = 0., KH, G0, K0, EH, nuH, E0, nu0, ff, ff_l, ll, kk;
///////////////////////////////////////////////////////////////////
//...данные для расчетов с дисперсными частицами - AL2O3, кластеры;
	//double nju2 = 0.24, //...жесткое включение;  
	//		 E2   = 293., //...модуль Юнга жесткого включения (GPa);
	//		 G2   = E2/(1.+nju2)*.5,  //...модуль сдвига жесткого матрицы (GPa);
	//		 l2	= 0.1,	//...относительная ширина межфазной зоны;
	//		 rad = 0.500,  //...характерный радиус включений (мкм); 
	//		 c0  = 0.0001, //...концентрация включений; 
	//		 С1, С2, GH = 0., KH, G0, K0, EH, nuH, E0, nu0, ff, ff_l, ll, kk;
/////////////////////////////////////////////////////////////////
//...исходные данные для расчетов с дисперсными частицами - ZrO2;
	double nju2 = 0.31, //...жесткое включение;  
			 E2   = 205.,  //...модуль Юнга жесткого матрицы (GPa);
			 G2   = E2/(1.+nju2)*.5,  //...модуль сдвига жесткого матрицы (GPa);
			 l2	= 0.03,	 //...относительная ширина межфазной зоны;
			 rad = 0.015,   //...характерный радиус включений (мкм); 
			 c0  = 0.001,   //...концентрация максимальной кластеризации включений; 
			 С1, С2, GH = 0., KH, G0, K0, EH, E_min, E_max, nuH, E0, nu0, ff, ff_l, ll, ll0, kk, l1_limit, AA, BB;
////////////////////////////////////////////////////////////////
//...исходные данные для расчетов с дисперсными частицами - SiC;
	//double nju2 = 0.16, //...жесткое включение;  
	//		 E2   = 415.,  //...модуль Юнга жесткого матрицы (GPa);
	//		 G2   = E2/(1.+nju2)*.5,  //...модуль сдвига жесткого матрицы (GPa);
	//		 l2	= 0.0015, //...масштабный параметр включений (мкм);
	//		 rad = 0.015,   //...предельный радиус включений (мкм); 
	//		 c0  = 0.300,   //...предельная концентрация включений; 
	//		 С1, С2, GH = 0., KH, G0, K0, EH, nuH, E0, nu0, E_max, ff, ff_l, ll, kk;
///////////////////////////////////////////////////////////////////////////
//...данные для расчетов эпоксидной матрицы с дисперсными частицами - SiO2;
	//double nju1 = 0.39, //...полимерная матрица;
	//		 nju2 = 0.20, //...жесткое включение;  
	//		 E1   = 2.51, //...модуль Юнга эпоксидной матрицы (GPa);
	//		 E2   = 87.5, //...модуль Юнга стеклянных шариков (GPa);
	//		 //E2   = 56.0, //...альтернативный модуль Юнга стеклянных шариков (GPa);
	//		 G1   = E1/(1.+nju1)*.5,  //...модуль сдвига полимерной матрицы (GPa);
	//		 G2   = E2/(1.+nju2)*.5,  //...модуль сдвига жесткого включения (GPa);
	//		 rad  = 0.015, //...характерный радиус нановключений (мкм); 
	//		 l1	= 0.100, //...относительный масштабный параметр матрицы (мкм);
	//		 l2	= 0.030, //...относительный масштабный параметр включений (мкм);
	//		 c0   = 0.001, //...концентрация включений; 
	//		 С1, С2, GH = 0., KH, G0, K0, EH, E_min, E_max, nuH, E0, nu0, ff, ff_l, ll, kk;
	yes = 0;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//...цикл по параметрам задачи - расчет алюмокомпозита (трехфазная модель, оценка модуля Юнга по пористости);
	//FILE * TST = fopen("Alumo3D_eps.dat", "w");
	//for (int j = 1; j <= 26; j += 1) {
	//	ff = j*0.01;
	//	el->set_fasa_hmg(nju1, nju2, G1, 0.);

	//	K0 = el->TakeEshelby_volm_two (ff);
	//	G0 = el->TakeEshelby_shear_two(ff);

	//	E0 = 9.*K0*G0/(3.*K0+G0);

	//	fprintf(TST, " c0 = %g, K0 = %g, G0 = %g, E0 = %g\n", ff*100, K0, G0, E0);
	//}
	//fclose (TST);

//////////////////////////////////////////////////////////////////////////////////////////////////////
//...цикл по параметрам задачи - расчет алюмокомпозита (четырехфазная модель, оценка межфазного слоя);
int  N_data = 1;
//double data[] = {0.1, 16.3647, 0.5, 9.15491, 1., 7.06, 1.5, 6.04102},
double data[] = {0.1, 16.3647, 0.5, 8.14284, 1., 4.44806, 1.5, 3.02},
		 coef[] = {0., 0., 0.};
	//FILE * TST = fopen("Alumo3D_strata.dat", "w");
	//for (int j = 1; j <= 2000; j += 1) {
	//	ff = .0005; ll = j*.01; if (ll > (ll0 = pow(M_PI/(6.*ff), 1./3.)-1.)) ll = ll0;
	//	ff_l = ff*(sqr(1.+ll)*(1.+ll)-1.);

	//	E3 = 67.; G3 = E3/(1.+nju3)*.5;
	//	el->set_fasa_hmg(nju1, nju2, G1, G2, nju3, G3);

	//	K0 = el->TakeEshelby_volm (ff, ff_l);
	//	G0 = el->TakeEshelby_shear(ff, ff_l);

	//	E0 = 9.*K0*G0/(3.*K0+G0);
	//	nu0 = (3.*K0-2.*G0)/(3.*K0+G0)*.5;

	//	fprintf(TST, " c0 = %g, c1 = %g, l1/rad = %g, K0 = %g, G0 = %g, E0 = %g\n", ff, ff_l, ll, K0, G0, E0);
	//}
	//fclose (TST);

/////////////////////////////////////////////////////////////////////////////////////////
//...цикл по параметрам задачи - расчет алюмокомпозита (четырехфазная модель, оценка E3);
int  N_table = 5;
//double table_EL[][2] = {{0.01, 89.2},{0.05, 71.8},{0.10, 60.},{0.15, 67.6},{0.20, 67.6}};
//double table_EL[][2] = {{0.01, 89.2},{0.05, 75.8},{0.10, 55.7},{0.15, 100.},{0.20, 105.}};
double table_EL[][2] = {{0.01, 89.2},{0.05, 75.8},{0.10, 70.0},{0.15, 70.0},{0.20, 70.0}};
	//FILE * TST = fopen("Alumo3D_rigidity.dat", "w");
	//for (int k = 4, j = 1; j <= 3000; j += 1) {
	//	ff = data[k]*0.001; ll = pow(M_PI/(6.*ff), 1./3.)-1.; ll = data[k+1];
	//	ff_l = ff*(sqr(1.+ll)*(1.+ll)-1.);

	//	E3 = 10+j*.1;
	//	G3   = E3/(1.+nju3)*.5;
	//	el->set_fasa_hmg(nju1, nju2, G1, G2, nju3, G3);

	//	K0 = el->TakeEshelby_volm (ff, ff_l);
	//	G0 = el->TakeEshelby_shear(ff, ff_l);
	//	E0 = 9.*K0*G0/(3.*K0+G0);

	//	fprintf(TST, " c0 = %g, c1 = %g, l1/rad = %g, E3 = %g, K0 = %g, G0 = %g, E0 = %g\n", ff, ff_l, ll, E3, K0, G0, E0);
	//}
	//fclose (TST);

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//...цикл по параметрам задачи - расчет алюмокомпозита (четырехфазная модель, аппроксимация межфазного слоя);
	kk  = strata_approx(N_data, data, ll0 = pow(M_PI/(6.*0.0001), 1./3.)-1.);
	res = strata_approx(N_data, data, coef);

	FILE * TST = fopen("Alumo3D_homog.dat", "w");
	fprintf(TST, " coef = %g", coef[0]); 
	for (int j = 1; j <= N_data; j++) fprintf(TST, ", %g", coef[j]);	fprintf(TST, "\n"); 
	fprintf(TST, " ll0 = %g, %g\n", ll0, kk); 
	for (int j = 1; j <= 2000; j += 1) {
		ff = j*.00001; ll = strata_aglom(ff/0.001, 0.1, kk, ll0); E_max = (1.-c0)*E1+c0*E2; /* if (ff >= 0.0001) ll = pow(M_PI/(6.*ff), 1./3.)-1.;*/
		//E3 = table_approx(ff*100., table_EL, N_table); G3 = E3/(1.+nju3)*.5;
		E3 = rigid_approx(ff*100., table_EL[0][1]+5., table_EL[4][1]+20., table_EL[2][1], table_EL[2][0], table_EL[0][1], table_EL[1][1], table_EL[3][1],
			table_EL[0][0]/table_EL[2][0]-1, table_EL[1][0]/table_EL[2][0]-1, table_EL[3][0]/table_EL[2][0]-1); G3 = E3/(1.+nju3)*.5;
		ff_l = ff*(sqr(1.+ll)*(1.+ll)-1.); 
		
		rad = aglom_approx(ff/0.001, 4., 0.3, 0.015, 0.1);
		if (ff < 0.0001) rad = l1/ll; l1_limit = rad*(pow(M_PI/(6.*ff), 1./3.)-1.);

		el->set_fasa_hmg(nju1, nju2, G1, G2, nju3, G3);

		K0 = el->TakeEshelby_volm (ff, ff_l);
		G0 = el->TakeEshelby_shear(ff, ff_l);
		E0 = 9.*K0*G0/(3.*K0+G0);

		//fprintf(TST, " c0 = %g, l1/rad = %g, rad = %g, l1 = %g, l1_limit = %g, E3 = %g, K0 = %g, G0 = %g, E0 = %g\n", ff*100., ll, rad, ll*rad, l1_limit, E3, K0, G0, E0);
		fprintf(TST, " %g, %g, %g, %g, %g, %g, %g, %g, %g, %g\n", ff*100., ll, rad, ll*rad, l1_limit, E3, E_max, K0, G0, E0);
	}
	fclose (TST);

/////////////////////////////////////////////////////////////////////////////////////////////////////
//...цикл по параметрам задачи - расчет алюмокомпозита по градиентной модели(оценка межфазного слоя);
double data_grad[] = {0.1, 16.3647, 0.5, 5.3992/*4.8*//*4.46*/, 1., 0.01, 1.5, 1.86};

//	FILE * TST = fopen("Alumo3D_strata_grad.dat", "w");
//	for (int k = 6, j = 1; j <= 2000; j += 1) {
//		ff = data_grad[k]*0.001; ll = j*.01;
//
//		AA = 55270.2;
//		KH = TakeSphere_volm_two (ff, nju1, nju2, E1, E2, ll, l2, AA);
//		GH = TakeSphere_shear_two(ff, nju1, nju2, E1, E2, ll, l2, AA);
//		EH = 9.*KH*fabs(GH)/(3.*KH+fabs(GH));
//
//		fprintf(TST, " c0 = %g, l1/rad = %g, K0 = %g, G0 = %g, E0 = %g\n", ff, ll, KH, GH, EH);
//	}
//	fclose (TST);

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//...цикл по параметрам задачи, трехфазная модель - расчет композита по градиентной модели (оценка адгезии);
	double table_AA[][2] = {{0.01, 55270.2},{0.05, 53936.2},{0.10, 1000.2},{0.15, 55270.2},{0.20, 70000.2}};

	//FILE * TST = fopen("Alumo3D_adhes.dat", "w");
	//for (int k = 6, j = 0; j <= 2000; j += 1) {
	//	ll = pow(M_PI/(6.*(ff = 0.0001)), 1./3.)-1.; ff = data_grad[k]*0.001; ll = data_grad[k+1];
	//	ff = 0.002; ll = 1.39761;

	//	AA = 60000.2+j*10.;

	//	KH = TakeSphere_volm_two (ff, nju1, nju2, E1, E2, ll, l2, AA);
	//	GH = TakeSphere_shear_two(ff, nju1, nju2, E1, E2, ll, l2, AA);
	//	EH = 9.*KH*fabs(GH)/(3.*KH+fabs(GH));

	//	E_min = 1./(ff/E2+(1.-ff)/E1);
	//	E_max = ff*E2+(1.-ff)*E1;

	//	//fprintf(TST, " l1 = %g, l2 = %g, c0 = %g, KH = %g, GH = %g, EH = %g, E_min = %g, , E_max = %g, , nuH = %g\n", l1, l2, ff, KH, GH, EH, E_min, E_max, nuH);
	//	fprintf(TST, " %g, %g, %g, %g\n", ff*100., ll, AA, EH);
	//}
	//fclose (TST);

////////////////////////////////////////////////////////////////////////////////////////
//...цикл по параметрам задачи - расчет алюмокомпозита по градиентной модели с адгезией;
	//kk  = strata_approx(N_data, data_grad, ll0 = pow(M_PI/(6.*0.0001), 1./3.)-1.);

	//FILE * TST = fopen("Alumo3D_grad.dat", "w");
	//for (int j = 1; j <= 2000; j += 1) {
	//	ff = j*.00001; ll = strata_aglom(ff/0.001, 0.1, kk, ll0);
	//	rad = aglom_approx(ff/0.001, 4., 0.3, 0.015, 0.1);
	//	if (ff < 0.0001) rad = l1/ll; l1_limit = rad*(pow(M_PI/(6.*ff), 1./3.)-1.);

	//	AA = 55270.2;
	//	AA = rigid_approx(ff*100., table_AA[0][1]+20., table_AA[4][1]+20., table_AA[2][1], table_AA[2][0], table_AA[0][1], table_AA[1][1], table_AA[3][1],
	//		table_AA[0][0]/table_AA[2][0]-1, table_AA[1][0]/table_AA[2][0]-1, table_AA[3][0]/table_EL[2][0]-1);

	//	KH = TakeSphere_volm_two (ff, nju1, nju2, E1, E2, ll, l2, AA);
	//	GH = TakeSphere_shear_two(ff, nju1, nju2, E1, E2, ll, l2, AA, 0.);
	//	EH = 9.*KH*fabs(GH)/(3.*KH+fabs(GH));
	//	E_max = ff*E2+(1.-ff)*E1;

	//	fprintf(TST, " %g, %g, %g, %g, %g, %g, %g, %g, %g, %g\n", ff*100., ll, rad, ll*rad, l1_limit, AA, E_max, KH, GH, EH);
	//}
	//fclose (TST);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//...цикл по параметрам задачи - расчет алюмокомпозита в зависимости от радиуса по градиентной модели (переход от нано к микро);
	//FILE * TST = fopen("Alumo3D_homog.dat", "w");
	//for (int j = 1; j <= 5000; j += 1) {
	//	rad = j*0.002; ll = l1/rad; E_max = (1.-c0)*E1+c0*E2; 
	//	l2 = 0.16; if (ll > l2) ll = 0.2; 
	//	kk  = rad1-0.5*l1/l2-sqrt(0.25*sqr(l1/l2)+rad0-rad1*l1/l2); if (rad >= rad1) ll *= (rad1-kk)/(rad-kk); 
	//	kk  = l1+l2*(rad1-rad0)/4.; if (rad0 < rad && rad < rad1) ll = (kk-l2/(rad1-rad0)*sqr(rad-0.5*(rad1+rad0)))/rad; 
	//	
	//	sm->set_fasa_hmg(nju1, nju2, G1, G2, С1 = G1/sqr(ll), G2*100.);
	//	el->set_fasa_hmg(nju1, nju2, G1, G2);

	//	KH = sm->TakeEshelby_volm_two (c0);
	//	GH = sm->TakeEshelby_shear_two(c0);

	//	K0 = el->TakeEshelby_volm_two (c0);
	//	G0 = el->TakeEshelby_shear_two(c0);

	//	EH = 9.*KH*fabs(GH)/(3.*KH+fabs(GH));
	//	E0 = 9.*K0*G0/(3.*K0+G0);

	//	nuH = (3.*KH-2.*fabs(GH))/(3.*KH+fabs(GH))*.5;
	//	nu0 = (3.*K0-2.*G0)/(3.*K0+G0)*.5;

	//	//fprintf(TST, " l1/rad = %g, rad = %g, KH = %g, GH = %g, EH = %g, E0 = %g, E_max = %g, nuH = %g\n", ll, rad, KH, GH, EH, E0, E_max, nuH);
	//	fprintf(TST, " %g, %g, %g, %g, %g, %g, %g, %g, %g\n", ll, rad, KH, GH, EH, E0, E_max, nuH, ll*rad);
	//}
	//fclose (TST); yes = 0;
	
	delete sm;
	delete el;
}
#endif
#ifdef ALUMO_COMPOSITES_EXAMPLES
{
//////////////////////////
//...model initialization;
	CDraft<double> * el = CreateDraftR(LAME3D_DRAFT,  8);
///////////////////////////////////////////////////////////////////////
//...данные для расчетов с дисперсными частицами - матрица пористый Al;
	double nju1 = 0.33, //...полимерная матрица;
			 nju3 = 0.30, //...межфазный слой;
			 //E1   = 70.0, //...модуль Юнга сплошной матрицы (GPa);
			 E1   = 62.0, //...модуль Юнга пористой матрицы (GPa);
			 E3   = 57.5, //...модуль Юнга межфазного слоя (GPa);
			 G1   = E1/(1.+nju1)*.5,  //...модуль сдвига мягкой матрицы (GPa);
			 G3   = E3/(1.+nju3)*.5,  //...модуль сдвига межфазного слоя (GPa);
			 l1	= 0.200, //...размер межфазного слоя (мкм);
			 eps	= 12.0,   //...пористость (%);
			 rad_str	= 3.5; //...размер зерна в структуре (мкм);
/////////////////////////////////////////////////////////
//...данные для расчетов с дисперсными частицами - AL2O3;
	double nju2 = 0.31, //...жесткое включение;  
			 E2   = 205., //...модуль Юнга жесткого включения (GPa);
			 G2   = E2/(1.+nju2)*.5,  //...модуль сдвига дисперсного включения (GPa);
			 rad = 0.015,  //...характерный радиус нановключений (мкм); 
			 c0  = 0.001,  //...концентрация включений; 
			 G0, K0, E0, nu0, ff, ff_l, ll, l2, kk, GH, KH, EH;
	yes = 0;

//////////////////////////////////////////////////////////////
//...цикл по параметрам задачи - расчет матрицы по пористости;
	//FILE * TST = fopen("Alumo3D_eps.dat", "w");
	//for (int j = 0; j <= 0; j += 1) {
	//	ff = eps*0.01;
	//	el->set_fasa_hmg(nju1, nju2, G1, 0.);

	//	K0 = el->TakeEshelby_volm_two (ff);
	//	G0 = el->TakeEshelby_shear_two(ff);

	//	E0 = 9.*K0*G0/(3.*K0+G0);
	//	nu0 = (3.*K0-2.*G0)/(3.*K0+G0)*.5;

	//	fprintf(TST, "eps = %g, K0 = %g, G0 = %g, E0 = %g, nu0 = %g\n", eps, K0, G0, E0, nu0);
	//}
	//fclose (TST);

//////////////////////////////////////////////////////////////////////////////////////////////////
//...цикл по параметрам задачи - расчет алюмокомпозита (четырехфазная модель, фиксированный слой);
	//FILE * TST = fopen("Alumo3D_layer.dat", "w");
	//for (int j = 0; j <= 5000; j += 1) {
	//	rad = j*0.001; kk = (ff = pow(1./c0, 1./3.)-1.)*rad/l1; if (kk > 1.) ll = l1/rad; else ll = ff; 
	//	//ll = ff*(1.-kk*(1.-2.*kk/3.))/(1.-kk*(1.-kk)); if (kk >= 0.001) ll = (l1/rad)*(1.-exp(-2.*kk))/(1.+exp(-2.*kk));
	//	ff_l = c0*(sqr(1.+ll)*(1.+ll)-1.);

	//	el->set_fasa_hmg(nju1, nju2, G1, G2, nju3, G3);

	//	K0 = el->TakeEshelby_volm (c0, ff_l);
	//	G0 = el->TakeEshelby_shear(c0, ff_l);

	//	E0 = 9.*K0*G0/(3.*K0+G0);
	//	nu0 = (3.*K0-2.*G0)/(3.*K0+G0)*.5;

	//	//fprintf(TST, " rad = %g, l1 = %g, K0 = %g, G0 = %g, E0 = %g, nu0 = %g\n", rad, ll*rad, K0, G0, E0, nu0);
	//	fprintf(TST, " %g, %g, %g, %g, %g\n", rad, ll*rad, K0, G0, E0);
	//}
	//fclose (TST);

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//...цикл по параметрам задачи - расчет алюмокомпозита (четырехфазная модель, линейный рост радиуса от концентрации);
	//FILE * TST = fopen("Alumo3D_layer.dat", "w");
	//for (int j = 1; j <= 3500; j += 1) {
	//	ff = j*.00001; kk = pow(6.e2, 1./3.)-1.;	ll = kk/sqrt(1.+sqr(0.3*ff/c0)); 
	//	if (ll > (kk = pow(1./ff, 1./3.)-1.)) ll = kk; rad = l1/ll;
	//	ff_l = ff*(sqr(1.+ll)*(1.+ll)-1.);

	//	el->set_fasa_hmg(nju1, nju2, G1, G2, nju3, G3);

	//	K0 = el->TakeEshelby_volm (ff, ff_l);
	//	G0 = el->TakeEshelby_shear(ff, ff_l);

	//	E0 = 9.*K0*G0/(3.*K0+G0);
	//	nu0 = (3.*K0-2.*G0)/(3.*K0+G0)*.5;

	//	//fprintf(TST, " c0 = %g, rad = %g, l1/rad = %g, K0 = %g, G0 = %g, E0 = %g, nu0 = %g\n", ff*100, rad, ll, K0, G0, E0, nu0);
	//	fprintf(TST, " %g, %g, %g, %g, %g, %g\n", ff*100, rad, ll, K0, G0, E0);
	//}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//...цикл по параметрам задачи - расчет композита по градиентной модели с адгезией;
	FILE * TST = fopen("Alumo3D_adhes.dat", "w");
	for (int j = 1; j <= 5000; j += 1) {
		//ff = j*.00001; ll = 7.; l2 = 0.03;
		ff = j*.0001; ll = 7.; l2 = 0.03;

		KH = TakeSphere_volm_two (ff, nju1, nju2, E1, E2, ll, l2, -0.1*E2);
		GH = TakeSphere_shear_two(ff, nju1, nju2, E1, E2, ll, l2, -0.1*E2, -0.1*G2);
		EH = 9.*KH*GH/(3.*KH+GH);

		K0 = TakeSphere_volm_two (ff, nju1, nju2, E1, E2, ll, l2);
		G0 = TakeSphere_shear_two(ff, nju1, nju2, E1, E2, ll, l2);
		E0 = 9.*K0*G0/(3.*K0+G0);

		//fprintf(TST, " c0 = %g, KH = %g, GH = %g, EH = %g\n", ff*100, KH, GH, EH);
		fprintf(TST, " %g, %g, %g, %g, %g, %g, %g\n", ff*100, K0, G0, E0, KH, GH, EH);
	}
	fclose (TST);

	delete el;
}
#endif
#ifdef WSMP_COMPOSITE_CALCULATION
{
//////////////////////////
//...model initialization;
	CDraft<double> * sm = CreateDraftR(COHES3D_DRAFT, 8),
						* el = CreateDraftR(LAME3D_DRAFT,  8);
//////////////////////////////////////////////////////////////
//...данные для расчетов с дисперсными частицами - матрица Al;
	double nju1 = 0.30, //...полимерная матрица;
			 nju3 = 0.30, //...межфазный слой;
			 E1   = 31.4, //...модуль Юнга матрицы;
			 E3   = 45.0, //...модуль Юнга межфазного слоя;
			 G1   = E1/(1.+nju1)*.5,  //...модуль сдвига матрицы;
			 G3   = E3/(1.+nju3)*.5,  //...модуль сдвига межфазного слоя;
			 l1	= 2.0;  //...размер межфазного слоя в максимальной точке;
/////////////////////////////////////////////
//...исходные данные для коэффициента трения;
	double k_sleep = 0.29, //...коэффициент трения включения (по отношению к матрице);  
			 K_surf  = 3.0/*1.26834*/, //...коэффициент поверхностной доли;
			 A_sleep = 10.,	//...коэффициент "адгезионного" трения;
			 l1_norm	= 1.,	   //...нормирующий коэффициент для межфазной зоны в матрице;
			 l2_norm	= 1E-14,	//...нормирующий коэффициент для межфазной зоны во включении;
			 l2_sleep = 1e7,  //...межфазная зона во включении; 
			 kkH, alphaI, alphaM, ff_sleep;
			 
/////////////////////////////////////////////////////////////////
//...исходные данные для расчетов с дисперсными частицами - стеарат кальция;
	double nju2 = 0.49, //...включение;  
			 E2   = 16.0, //...модуль Юнга включения;
			 G2   = E2/(1.+nju2)*.5,  //...модуль сдвига включения;
			 l2	= 0.03,	 //...ширина межфазной зоны во включенияя;
			 rad = 0.015,   //...характерный радиус включений (мкм); 
			 c0  = 0.001,   //...концентрация максимального масштабного эффекта; 
			 С1, С2, GH = 0., KH, G0, K0, EH, E_min, E_max, nuH, E0, nu0, ff, ff_l, ll, ll0, kk, l1_limit, AA, BB;
	yes = 0;

//////////////////////////////////////////////////////////////////////////////////////////////////////
//...цикл по параметрам задачи - расчет алюмокомпозита (четырехфазная модель, оценка межфазного слоя);
int  N_data = 3;
double data[] = {0.0091, 2.2, 0.0273, 1.37, 0.0456, 1.0, 0.0917, 0.2, 0.1851, 0.01},
		 coef[] = {0., 0., 0.};
	//FILE * TST = fopen("WSMP_strata.dat", "w");
	//for (int k = 0, j = 1; j <= 2000; j += 1) {
	//	ff = data[k]; ll = j*.01; if (ll > (ll0 = pow(M_PI/(6.*ff), 1./3.)-1.)) ll = ll0;
	//	ff_l = ff*(sqr(1.+ll)*(1.+ll)-1.);

	//	el->set_fasa_hmg(nju1, nju2, G1, G2, nju3, G3);

	//	K0 = el->TakeEshelby_volm (ff, ff_l);
	//	G0 = el->TakeEshelby_shear(ff, ff_l);

	//	E0 = 9.*K0*G0/(3.*K0+G0);
	//	nu0 = (3.*K0-2.*G0)/(3.*K0+G0)*.5;

	//	fprintf(TST, " c0 = %g, c1 = %g, l1/rad = %g, K0 = %g, G0 = %g, E0 = %g\n", ff, ff_l, ll, K0, G0, E0);
	//}
	//fclose (TST);

/////////////////////////////////////////////////////////////////////////////////////////
//...цикл по параметрам задачи - расчет алюмокомпозита (четырехфазная модель, оценка E3);
int  N_table = 5;
double table_EL[][2] = {{0.01, 89.2},{0.05, 75.8},{0.10, 70.0},{0.15, 70.0},{0.20, 70.0}};
	//FILE * TST = fopen("Alumo3D_rigidity.dat", "w");
	//for (int k = 4, j = 1; j <= 3000; j += 1) {
	//	ff = data[k]*0.001; ll = pow(M_PI/(6.*ff), 1./3.)-1.; ll = data[k+1];
	//	ff_l = ff*(sqr(1.+ll)*(1.+ll)-1.);

	//	E3 = 10+j*.1;
	//	G3   = E3/(1.+nju3)*.5;
	//	el->set_fasa_hmg(nju1, nju2, G1, G2, nju3, G3);

	//	K0 = el->TakeEshelby_volm (ff, ff_l);
	//	G0 = el->TakeEshelby_shear(ff, ff_l);
	//	E0 = 9.*K0*G0/(3.*K0+G0);

	//	fprintf(TST, " c0 = %g, c1 = %g, l1/rad = %g, E3 = %g, K0 = %g, G0 = %g, E0 = %g\n", ff, ff_l, ll, E3, K0, G0, E0);
	//}
	//fclose (TST);

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//...цикл по параметрам задачи - расчет алюмокомпозита (четырехфазная модель, аппроксимация межфазного слоя);
	//kk  = strata_approx(N_data, data, ll0 = data[1]);
	//FILE * TST = fopen("WSMP_homog.dat", "w");
	//for (int j = 1; j <= 2000; j += 1) {
	//	ff = j*.0001; l1_limit = pow(M_PI/(6.*ff), 1./3.)-1.;	
	//	if (ff < data[0])   ll = ll0; else ll = strata_aglom(ff, data[0], kk, ll0); 
	//	if (ll >= l1_limit) ll = l1_limit;
	//	ff_l = ff*(sqr(1.+ll)*(1.+ll)-1.); 

	//	el->set_fasa_hmg(nju1, nju2, G1, G2, nju3, G3);

	//	K0 = el->TakeEshelby_volm (ff, ff_l);
	//	G0 = el->TakeEshelby_shear(ff, ff_l);
	//	E0 = 9.*K0*G0/(3.*K0+G0);

	//	//fprintf(TST, " c0 = %g, l1/rad = %g, l1_limit = %g, E3 = %g, K0 = %g, G0 = %g, E0 = %g\n", ff*100., ll, l1_limit, E3, K0, G0, E0);
	//	fprintf(TST, " %g, %g, %g, %g, %g, %g, %g\n", ff*100., ll, l1_limit, E3, K0, G0, E0);
	//}
	//fclose (TST);

////////////////////////////////////////////////////////////////////////////////////////////////////////
//...цикл по параметрам задачи - расчет алюмокомпозита (четырехфазная модель, аппроксимация гиперболой);
	double X0 = data[2], Y0 = data[3],
			 X1 = data[4], Y1 = data[5],
			 X2 = data[6], Y2 = data[7], alpha = (Y2-Y0)/(X2-X0)*(X1-X0)/(Y1-Y0), C = (alpha*X2-X1)/(1.-alpha),
			 A = (Y1-Y0)/(X0-X1)*(X1+C)*(X0+C), B = A/(X1+C)-Y1, X3 = 0.09, Y3 = A/(X3+C)-B,
			 e = sqr(X3+C)*Y3/A-X3, d = Y3*(X3+e);
	//FILE * TST = fopen("WSMP_homog.dat", "w");
	//fprintf(TST, " A = %g, B = %g, C = %g, e = %g, d = %g, X3 = %g\n", A, B, C, e, d, X3);
	//for (int j = 1; j <= 2000; j += 1) {
	//	ff = j*.0001; l1_limit = pow(M_PI/(6.*ff), 1./3.)-1.;	ll = A/(ff+C)-B; 
	//	if (ff > X3) ll = d/(ff+e);
	//	if (ll > l1_limit) ll = l1_limit; if (ll < data[9]) ll = data[9];
	//	ff_l = ff*(sqr(1.+ll)*(1.+ll)-1.); 

	//	el->set_fasa_hmg(nju1, nju2, G1, G2, nju3, G3);

	//	K0 = el->TakeEshelby_volm (ff, ff_l);
	//	G0 = el->TakeEshelby_shear(ff, ff_l);
	//	E0 = 9.*K0*G0/(3.*K0+G0);

	//	//fprintf(TST, " c0 = %g, l1/rad = %g, l1_limit = %g, E3 = %g, K0 = %g, G0 = %g, E0 = %g\n", ff*100., ll, l1_limit, E3, K0, G0, E0);
	//	fprintf(TST, " %g, %g, %g, %g, %g, %g, %g\n", ff*100., ll, l1_limit, E3, K0, G0, E0);
	//}
	//fclose (TST);

/////////////////////////////////////////////////////////////////////////////////////////////////////
//...цикл по параметрам задачи - расчет алюмокомпозита по градиентной модели(оценка межфазного слоя);
double data_grad[] = {0.1, 16.3647, 0.5, 5.3992, 1., 0.01, 1.5, 1.86};

	//FILE * TST = fopen("WSMP_strata_grad.dat", "w");
	//for (int k = 6, j = 1; j <= 2000; j += 1) {
	//	//ff = j*0.0001; ll = A/(ff+C)-B; if (ff > X3) ll = d/(ff+e);
	//	ff = 0.1851; ll = A/(ff+C)-B; if (ff > X3) ll = d/(ff+e);

	//	AA = j*.1; BB = 5000.;
	//	KH = TakeSphere_volm_two (ff, nju1, nju2, E1, E2, ll, l2, AA);
	//	GH = TakeSphere_shear_two(ff, nju1, nju2, E1, E2, ll, l2, AA, BB);
	//	EH = 9.*KH*fabs(GH)/(3.*KH+fabs(GH));

	//	//fprintf(TST, " c0 = %g, l1/rad = %g, AA = %g, K0 = %g, G0 = %g, E0 = %g\n", ff*100, ll, AA, KH, GH, EH);
	//	fprintf(TST, " %g, %g, %g, %g, %g, %g\n", ff*100, ll, AA, KH, GH, EH);
	//}
	//fclose (TST);

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//...цикл по параметрам задачи, трехфазная модель - расчет композита по градиентной модели (оценка адгезии);
	double table_AA[][2] = {{0.0091, 300.0},{0.0273, 250.0},{0.09,  6.1},{0.0917, 6.2},{0.1851, 6.3}};
	//FILE * TST = fopen("Alumo3D_adhes.dat", "w");
	//for (int k = 6, j = 0; j <= 2000; j += 1) {
	//	ll = pow(M_PI/(6.*(ff = 0.0001)), 1./3.)-1.; ff = data_grad[k]*0.001; ll = data_grad[k+1];
	//	ff = 0.002; ll = 1.39761;

	//	AA = 60000.2+j*10.;

	//	KH = TakeSphere_volm_two (ff, nju1, nju2, E1, E2, ll, l2, AA);
	//	GH = TakeSphere_shear_two(ff, nju1, nju2, E1, E2, ll, l2, AA);
	//	EH = 9.*KH*fabs(GH)/(3.*KH+fabs(GH));

	//	E_min = 1./(ff/E2+(1.-ff)/E1);
	//	E_max = ff*E2+(1.-ff)*E1;

	//	//fprintf(TST, " l1 = %g, l2 = %g, c0 = %g, KH = %g, GH = %g, EH = %g, E_min = %g, , E_max = %g, , nuH = %g\n", l1, l2, ff, KH, GH, EH, E_min, E_max, nuH);
	//	fprintf(TST, " %g, %g, %g, %g\n", ff*100., ll, AA, EH);
	//}
	//fclose (TST);

////////////////////////////////////////////////////////////////////////////////////////
//...цикл по параметрам задачи - расчет алюмокомпозита по градиентной модели с адгезией;
	FILE * TST = fopen("WSMP_grad.dat", "w");
	for (int j = 1; j <= 2000; j += 1) {
		ff = j*.0001; ll = A/(ff+C)-B; if (ff > X3) ll = d/(ff+e);
		rad = aglom_approx(ff*100., 0.4, 7.0, 1.0, 0.91); l1_limit = pow(M_PI/(6.*ff), 1./3.)-1.; if (ff < 0.0091) rad = (A/(0.0091+C)-B)*1.0/ll;
		AA = 250.0; BB = 5000.;
		AA = rigid_approx(ff, table_AA[0][1]+20., table_AA[4][1]+0.1, table_AA[2][1], table_AA[2][0], table_AA[0][1], table_AA[1][1], table_AA[3][1],
			table_AA[0][0]/table_AA[2][0]-1, table_AA[1][0]/table_AA[2][0]-1, table_AA[3][0]/table_AA[2][0]-1);

		KH = TakeSphere_volm_two (ff, nju1, nju2, E1, E2, ll, l2, AA);
		GH = TakeSphere_shear_two(ff, nju1, nju2, E1, E2, ll, l2, AA, 0.);
		EH = 9.*KH*fabs(GH)/(3.*KH+fabs(GH));

		fprintf(TST, " %g, %g, %g, %g, %g, %g, %g, %g, %g\n", ff*100, ll, rad, ll*rad, l1_limit*rad, AA, KH, GH, EH);
	}
	fclose (TST);

/////////////////////////////////////////////////////////////////////////////////////////////
//...цикл по параметрам задачи - расчет коэффициента трения по градиентной модели с адгезией;
	double table_slip[][3] = {
		{0.,		1., 0.},
		{0.91,	0.825, 3.15},
		{2.73,	0.833333333, 9.04},
		{4.56,	0.925, 11.65},
		{9.17,	1.025, 10.14},
		{18.51,	1.125, 10.1}
	};
	//FILE * TST = fopen("WSMP_slip.dat", "w");
	//for (int j = 1, k_table = 5; j <= 2000; j += 1) {
	//	ff = j*.0001; ll = A/(ff+C)-B; if (ff > X3) ll = d/(ff+e);


	//	ff = 0.03;
	//	double a = 0.1, Q1 = ((1.-table_slip[1][2]/table_slip[5][2])*exp(a*sqr(table_slip[1][0]))-1.)/table_slip[1][0], bbb,
	//						 Q2 = ((1.-table_slip[2][2]/table_slip[5][2])*exp(a*sqr(table_slip[2][0]))-1.)/table_slip[2][0],
	//						 Q3 = ((1.-table_slip[3][2]/table_slip[5][2])*exp(a*sqr(table_slip[3][0]))-1.)/table_slip[3][0],
 //		l1 = (ff*100.-table_slip[2][0])/(table_slip[1][0]-table_slip[2][0])*(ff*100.-table_slip[3][0])/(table_slip[1][0]-table_slip[3][0])*(ff*100.-table_slip[4][0])/(table_slip[1][0]-table_slip[4][0]),
 //		l2 = (ff*100.-table_slip[1][0])/(table_slip[2][0]-table_slip[1][0])*(ff*100.-table_slip[3][0])/(table_slip[2][0]-table_slip[3][0])*(ff*100.-table_slip[4][0])/(table_slip[2][0]-table_slip[4][0]),
 //		l3 = (ff*100.-table_slip[1][0])/(table_slip[3][0]-table_slip[1][0])*(ff*100.-table_slip[2][0])/(table_slip[3][0]-table_slip[2][0])*(ff*100.-table_slip[4][0])/(table_slip[3][0]-table_slip[4][0]);

	//	A_sleep =(1.-(1.+(bbb = l1*Q1+l2*Q2+l3*Q3)*ff*100.)*exp(-a*sqr(ff*100.)))*table_slip[5][2];

	//	ff_sleep = K_surf*pow(ff, 2./3.);
	//	alphaI = 1./(tanh(1./(l2_norm*l2_sleep))*l2_sleep);
	//	alphaM = 1./(tanh((1.-ff_sleep)/(l1_norm*ll*ff_sleep))*ll);
	//	kkH = ((1.+A_sleep)*k_sleep-(1.-k_sleep*(1.+alphaI*A_sleep))*(1.-k_sleep*(1.-alphaM*A_sleep))/(alphaI*k_sleep*(1.-alphaM*A_sleep)+alphaM))*ff_sleep+(1.-ff_sleep);
	//	kk  = ff_sleep*k_sleep+(1.-ff_sleep);

	//	fprintf(TST, " %g, %g, %g, %g, %g, %g, %g, %g, %g\n", ff*100, ff_sleep, ll, alphaI, alphaM, kk, kkH, A_sleep, bbb);
	//}
	//fclose (TST);

	delete sm;
	delete el;
}
#endif
#ifdef MINDL2D_CALCULATIONS
{
	char * name_ini = "./Models_inp/Box2D_circle/Box2D_circle_", name[2000];
	extern int gradient_model; gradient_model = 0;

//////////////////////////
//...model initialization;
	CDraft<double> * sm = CreateDraftR(MINDL2D_DRAFT, 8);
	sm->set_mpls(PackInts(9, 9)); //...степень мультиполей;
	sm->set_quad(PackInts(16, 8)); //...степень квадратуры;
	sm->set_normaliz(0.92);
	sm->set_lagrange(1e5);
	sm->change_solv(E_PERIODIC_SOLVING);
	sm->solver.change_state(/*EXTERN_STATE*/);
	sm->solver.set_mode(/*REGULARIZATION*//*PRINT_MODE*//*FULLY_MODE*/);
	yes = 0;

/////////////////////////////////////////////////////////
//...данные для расчетов с нитевидыми кристаллами - ВПМ2;
	//double nju1 = 0.33, //...полимерная матрица;
	//		 //E1   = 210., //...модуль Юнга полимерной матрицы (GPa), Т = 20С;
	//		 //E1   = 150., //...модуль Юнга полимерной матрицы (GPa), Т = 600С;
	//		 E1   = 30.,  //...модуль Юнга полимерной матрицы (GPa), Т = 1400/1300С;
	//		 AA	= E1*.0,			 //...adhegion parameter;
	//		 BB	= E1*.5/(1.+nju1)*.0,//...adhegion parameter;
	//		 l1	= 15.,  //...масштабный параметр матрицы (мкм), Т = 20С;
	//		 //l1	= 20.,  //...масштабный параметр матрицы (мкм), Т = 600С;
   //  	 //l1	= 25.,  //...масштабный параметр матрицы (мкм), Т = 1400/1300С;
	//		 l1_dop = 0.; //...interphase layer_dop;
////////////////////////////////////////////////////////////
//...данные для расчетов с нитевидыми кристаллами - ВКНА-1У;
	double nju1 = 0.33, //...полимерная матрица;
			 //E1   = 150., //...модуль Юнга полимерной матрицы (GPa), Т = 20С;
			 //E1   = 135., //...модуль Юнга полимерной матрицы (GPa), Т = 600С;
			 E1   = 40.,  //...модуль Юнга полимерной матрицы (GPa), Т = 1400/1300С;
			 AA	= E1*.0,			 //...adhegion parameter;
			 BB	= E1*.5/(1.+nju1)*.0,//...adhegion parameter;
			 l1	= 15.,  //...масштабный параметр матрицы (мкм), Т = 20С;
			 //l1	= 20.,  //...масштабный параметр матрицы (мкм), Т = 600С;
			 //l1	= 25.,  //...масштабный параметр матрицы (мкм), Т = 1400/1300С;
			 l1_dop = 0.; //...interphase layer_dop;
////////////////////////////////////////////////////////
//...данные для расчетов с нитевидыми кристаллами AL2O3;
	double nju2 = 0.16, //...жесткое включение;  
			 //E2   = 420., //...модуль Юнга жесткого включения (GPa), Т = 20/600С;
			 E2   = 380., //...модуль Юнга жесткого включения (GPa), Т = 1400/1300С;
			 l2	= 0.05, //...масштабный параметр включений (мкм);
			 l2_dop	= 0.,//...interphase layer_dop;
			 rad = 0.5,   //...характерный радиус включений (мкм); 
			 c0  = 0.45,  //...предельная концентрация включений; 
			 G1, G2, KH, GH, EH, nH, KM = E1/(1.-2.*nju1)/3., GM = E1/(1.+nju1)*.5, EM = E1, nM = nju1;
	sm->set_fasa_hmg(nju1, nju2, G1 = E1/(1.+nju1)*.5, G2 = E2/(1.+nju2)*.5, l1, l1_dop = l1_dop/sqrt(1.-2.*nju1), l2, l2_dop = l2_dop/sqrt(1.-2.*nju2), AA, BB);

///////////////////////////////  
//...цикл по параметрам задачи;
	FILE * TST = fopen("mindl2D_homog.dat", "a");
	for (int jj = 30; jj <= 45; jj += 5) {
		double X0, Y0, ell_X = 0., ell_Y = 0., rot_Z = 0.;
		sprintf(name, "%s%i%s", name_ini, jj, "_M208.inp"); 

///////////////////////////////////////////////////////
//...чтение модели и граничных условий из файла данных;
		int id_reading = 0, i, j, l;
		if (sm) {
			sprintf(buf, "Loading model from file '%s'", name);
			Message(" ");
			Message(buf);
			Message("Reading data file ...");

			sm->stru.nodes_in(name);
			sm->bar_condit_in(name);
			sm->LinkUniStruct();
			sm->SetBUniStruct(POLY_BLOCK);

			if (sm->id_prop && sm->pp_cond)//...reading parameters of inclusion;
			for (j = 0; j < sm->id_prop[0]; j++)
			if (sm->id_prop[j*2+2] == BSOURCE_BND) {
				X0		= sm->pp_cond[j*6]; 
				Y0		= sm->pp_cond[j*6+1];
				ell_X = sm->pp_cond[j*6+2];
				ell_Y = sm->pp_cond[j*6+3];
				rot_Z = sm->pp_cond[j*6+4];
				id_reading = 1;
				break;
			}
			Message("Finish!");
		}
		double par[6];	sm->SetGeomBounding(par);
		if (! id_reading) {
			X0 = (par[0]+par[1])*.5;
			Y0 = (par[2]+par[3])*.5;
			ell_X = 0.15;
			ell_Y = 0.15;
			rot_Z = 0.;
		}
		if (ell_X != 0. && ell_Y != 0.) {
			CCells * ce = new(CCells);
			ce->cells_new(1, 2, (l = size_of_map(1, CYL_GENUS))+1);
			ce->mp[0] = (CMap)ID_MAP(1, CYL_GENUS);
			ce->mp[1] = X0;
			ce->mp[2] = Y0;
			ce->mp[4] = rot_Z/180.*M_PI;
			ce->mp[7] = ell_X;
			ce->mp[8] = ell_Y;
			ce->mp[l] = (CMap)NULL_CELL;
			sm->bar = new(CCells);
			sm->bar->bar_add(ce);
		}

///////////////////////////
//...solving of the probem;
		if (sm->computing_kernel(MAPPING_COMPUT) != OK_STATE) {
			Message("Error in sample computing...");
			delete sm;
			goto err;
		}

//////////////////
//..visualization;
		{	double K[17], ku1, lm1, mu1, ku2, lm2, mu2, Ez, Kxy, Gxy, Gxz, nxz, ff_vol; memset(K, 0, 17*sizeof(double));
			sm->GetRigidy(K);

/////////////////////
//...объемный модуль;
			ff_vol = K[15];
			//ff_vol = M_PI*ell_X*ell_Y/((par[1]-par[0])*(par[3]-par[2]));

///////////////////////
//...матрица жесткости;
			ku1 = K[0];
			lm1 = K[2];
			mu1 = K[7];
			ku2 = K[14]*G1*(1.-nju1)/(.5-nju1)+K[15]*G2*(1.-nju2)/(.5-nju2)+
					(G2*nju2/(.5-nju2)-G1*nju1/(.5-nju1))/(G2/(1.-2.*nju2)-G1/(1.-2.*nju1))*
					(K[12]-K[14]*G1*nju1/(.5-nju1)-K[15]*G2*nju2/(.5-nju2));
			lm2 = K[13];
			mu2 = K[14]*G1+K[15]*G2;

///////////////////////////
//...технические константы;
  			nxz = lm2/(ku1+lm1);
			Kxy = 0.5*(ku1+lm1);	
			Gxy = 0.5*(ku1-lm1);	
			Gxz = mu2;	
			Ez  = ku2-2.*lm2*nxz;

///////////////////////////////////////////////////////////////////
//...результат пространственного осреднения волокон по Кристенсену;
			KH = (Ez+4.*sqr(1.+nxz)*Kxy)/9.;
			GH = (Ez+sqr(1.-2.*nxz)*Kxy+6.*(Gxy+Gxz))/15.;
			EH = 9.*KH*GH/(3.*KH+GH);
			nH = (3.*KH-2.*GH)/(3.*KH+GH)*.5;

			//nH = 1./(2.*(Ez+Gxy+Gxz)+(8.*sqr(nxz)+12.*nxz+7.)*Kxy);
			//EH = 5.*GH*nH*(Ez+4.*sqr(1.+nxz)*Kxy);
			//nH = .5*nH*(Ez+2.*(2.*sqr(nxz)+8.*nxz+3.)*Kxy-4.*(Gxy+Gxz));

			fprintf(TST, "ff_vol = %g  KH = %g  KM = %g  GH = %g  GM = %g  EH = %g  EM = %g  nH = %g  nM = %g  Ez = %g  Kxy = %g  Gxy = %g  Gxz = %g  nxz = %g  mu1 = %g (%g, %g, %g, %g, %g, %g, %g)\n", 						 
							  ff_vol, KH, KM, GH, GM, EH, EM, nH, nM, Ez, Kxy, Gxy, Gxz, nxz, mu1, ell_X, ell_Y, rot_Z, E2, E1, nju2, nju1);

			int id_visual = 1;
			if (id_visual) {//..visualization;
				CGrid * nd = CreateNodes();
				sm->BlockActivate(NULL_STATE);

				int NX = 100, NY = 100;
				for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(par[0]+.5*i/NX*(par[1]-par[0]));
				for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(par[2]+.5*j/NY*(par[3]-par[2]));

				nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

				for (i = 0; i < nd->N;  i++)
				for (j = 0; j < nd->N1; j++) {
					int hit = -1;
					sm->Poly_struc_in2D (hit, nd->X[i], nd->Y[j]);
					sm->StructEllCorrect(hit, nd->X[i], nd->Y[j]);
					nd->hit[i+j*nd->N] = hit;
				}
				system("del *.grd");
				sm->GetSurferFormat("bb",	 nd,					ERR_VALUE);
				sm->GetSurferFormat("rr",	 nd,				 DISPL_VALUE);
				sm->GetSurferFormat("tf_x", nd,			 STRESS_X_VALUE);
				sm->GetSurferFormat("tt_x", nd, STRESS_X_CLASSIC_VALUE);
				
				delete nd;
			}
		}
	}
	fclose (TST);
	delete sm;
}
#endif
#ifdef TEST_DRAFT_HEAT_ESHELBY
{
//////////////////////
//...параметры задачи;
	double K1 = 1.7,	//...оксид циркония (matrtix);
			 K2 = 30.,	//...корунд (inclusion);
			 K3 = 3.,	//...промежуточный слой;
			 c1 = 0.70, //...interphase layer;
			 c0 = 0.20, ll = 0.7, R1 = 1.5, KH, KH_cl, KH2; //...volume fraction;

//////////////////////////
//...model initialization;
	CDraft<double> * sm = CreateDraftR(HEAT3D_DRAFT);
	sm->set_fasa_hmg(K1, K2, K3);
	yes = 0;

///////////////////////////////
//...цикл по параметрам задачи;
	FILE * TST = fopen("heat3D_homog.dat", "w");
	for (int j = 200; j <= 1000; j += 10) {
		c0 = j*.001;
		sm->set_fasa_hmg(R1, R1*pow(c0, -1./3.), K1, K2, K3, 1./sqr(ll));
		
		KH	= sm->TakeEshelby_grad(c0);
		KH_cl = sm->TakeEshelby_two(c0);

		fprintf(TST, " c0 = %g, с1 = %g, KH = %g\n", c0, c1, KH);
	}
	fclose (TST);
	delete sm;
}
#endif
#ifdef TEST_DRAFT_HEAT_NONLINEAR_LAYER
{
	char * name = "heat1D_nonlinear_layer.dat";
//////////////////////////
//...model initialization;
	CDraft<double> * sm = CreateDraftR(HEAT2D_DRAFT);
	int N1 = 20, N2 = 10, N_cells = 5, NN = (N1+N2)*N_cells, m = 1000, MM = 30000, M0 = MM/m, k, j, l;
	double x = 0., h = 0.05, t = 0., dt = 0.001, alpha = dt/sqr(h), 
			*T = (double *)new_struct((NN+1)*sizeof(double)), ** out = NULL, 
			//T0 = 273, TS = 300;
			T0 =  15, TS =  45;
			//T0 = 120, TS = 170;
	set_matrix(out, NN+2, M0+1);

////////////////////////////////////////////////////
//...начальные и граничные данные, распечатка сетки;
	for (T[0] = TS, k = 1; k <= NN; k++) T[k] = T0;

	for (l = 0, k = 0; k <= NN; k++, x += h) out[k][l] = x; 
	out[k][l] = h;

	for (l = 1, k = 0; k <= NN; k++) out[k][l] = T[k]; 
	out[k][l] = t;

///////////////////////////////
//...цикл по параметрам задачи;
	for (j = 1; j < MM; j++) {
		//sm->TakeStabStep(T, NN, alpha); t += dt;
		sm->TakeStabStep_layer(T, N1, N2, N_cells, alpha); t += dt;
		if (!(j%m) && (++l) <= M0) {
			for (k = 0; k <= NN; k++) out[k][l] = T[k]; 
			out[k][l] = t;
		}
	}

////////////////////////////
//...распечатка результатов;
	FILE *  TST = fopen(name, "w");
	fprintf(TST, "h = %g", out[NN+1][0]);
	for (j = 1; j <= M0; j++) fprintf(TST, ", t = %g", out[NN+1][j]);
	fprintf(TST, "\n");

	for (k = 0; k <= NN; k++) {
		fprintf(TST, "%g", out[k][0]);
		for (j = 1; j <= M0; j++) fprintf(TST, ", %g", out[k][j]);
		fprintf(TST, "\n");
	}
	fclose(TST);

	delete_struct(out);
	delete_struct(T);
	delete sm;
}
#endif
#ifdef TEST_DRAFT_HEAT_FIRST_MEMBER
{
	char * name = "./Parametric/Unit2d_1.nas";
	char * name_out = "heat1D_nonlinear_layer.dat";
//	char * name = "./Box2d_homog/heat_clayer488.nas";
//	char * name = "./Box2d_homog/heat_cyl_layer1148.nas";
//	char * name = "./Box2d_homog/heat_ell_layer1174.nas";
//	char * name = "./Box2d_homog/sph_025_16.nas";

//////////////////////
//...параметры задачи;
	double L = 0.5, eps_in = 1e-2;
	int i, k, j, l; 
	double KK1 = 1.,		//...heat conduction (matrix);
			 KK2 = 413./150.,		//...heat conduction (inclusion);
			 KK3 = KK2,		//...heat conduction (intermediate);
			 R1 = 0.3,		//...inclusion geometry;
			 R2 = 0.3125;		//...intermediate geometry; 

//////////////////////////
//...инициализация модели;
	CDraft<double> * sm = CreateDraftR(HEAT2D_DRAFT, 8);		
	sm->set_fasa_hmg(R1, R2, KK1, KK2, KK3);
	sm->set_mpls(PackInts(13, 13)); //...степень мультиполей;
	sm->set_quad(PackInts(16, 8)); //...степень квадратуры;
	sm->set_normaliz(0.92);			//...normalization coefficient;
	sm->set_lagrange(1e-4);		  //...Lagrange coefficient for energy;
	sm->solver.set_mode(/*PRINT_MODE | FULLY_MODE | MASKS_MODE | ACCUMULATION*/);
	sm->solver.change_state(/*EXTERN_STATE*/);
	sm->change_solv(SPECIAL_SOLVING);
	yes = 0;

///////////////////////////////////
//...чтение модели из файла данных;
	if (sm) {
      sprintf(buf, "Loading model from file '%s'", name);
      Message(" ");
      Message(buf);
      Message("Reading data file ...");

		sm->stru.nodes_in(name);
		sm->bar_condit_in(name);
		sm->LinkUniStruct();
		sm->SetBUniStruct(CLAYER_BLOCK);
		Message("Finish!");
	}

////////////////////////////
//...solving of the problem;
	if (sm->computing_kernel(PERIOD_COMPUT) != OK_STATE) {
		Message("Error in sample computing...");
		if (sm) delete sm;
		goto err;
	}

///////////////////
//..homogenization;
#ifdef ___MPI_INIT___
	if (comm_mpi.GetMyid() == 0) 
#endif
	{
//////////////////
//..visualization;
		int id_visual = 0;
		if (id_visual) {
			CGrid * nd = CreateNodes();
			double par[6];	sm->SetGeomBounding(par);
			sm->BlockActivate(NULL_STATE);

			int NX = 100, NY = 100;
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

			system("del *.grd");
			sm->GetSurferFormat("rr", nd,        HEAT_VALUE, 0);
			sm->GetSurferFormat("pp", nd, FLUX_COMPOS_VALUE, 0);

			delete nd;
		}
	}
	//int N1 = 400, N2 = 200, N_cells = 10, NN = (N1+N2)*N_cells, m = 100000, MM = 3000000, M0 = MM/m, m_shift = 1;
	//double x = 0., h = 0.000002, t = 0., dt = 0.00000000002, alpha = dt/sqr(h), fnorm = 1e-6, t0 = 0.5e-4,
	int N1 = 400, N2 = 200, N_cells = 10, NN = (N1+N2)*N_cells, m = 1000000, MM = 25000000, M0 = MM/m, m_shift = 1;
	double x = 0., h = 0.000002, t = 0., dt = 0.00000002, alpha = dt/sqr(h), fnorm = 1e-3, t0 = 0.5,
	//int N1 = 400, N2 = 200, N_cells = 10, NN = (N1+N2)*N_cells, m = 100000, MM = 3000000, M0 = MM/m, m_shift = 1;
	//double x = 0., h = 0.000002, t = 0., dt = 0.00000002, alpha = dt/sqr(h), fnorm = 1e-3, t0 = 0.05,
			*T = (double *)new_struct((NN+1)*sizeof(double)), ** out = NULL, 
			//T0 =  15, TS =  45;
			T0 = 273, TS = 300;
			//T0 = 120, TS = 170; 
	set_matrix(out, NN+2, M0+1);

////////////////////////////////////////////////////
//...начальные и граничные данные, распечатка сетки;
	for (T[0] = TS, k = 1; k <= NN; k++) T[k] = T0;

	for (l = 0, k = 0; k <= NN; k++, x += h) out[k][l] = x; 
	out[k][l] = h;

	for (l = 1, k = 0; k <= NN; k++) out[k][l] = T[k]; 
	out[k][l] = t;

///////////////////////////////
//...цикл по параметрам задачи;
	for (j = 1; j < MM; j++) {
		sm->TakeStabStep(T, NN, alpha); t += dt;
		//sm->TakeStabStep_layer(T, N1, N2, N_cells, alpha); t += dt;
		if (!(j%m) && (++l) <= M0) {
			for (k = 0; k <= NN; k++) out[k][l] = T[k]; 
			out[k][l] = t;
		}
	}

////////////////////////////
//...распечатка результатов;
	FILE *  TST = fopen(name_out, "w");
	fprintf(TST, "h = %g", out[NN+1][0]);
	for (j = 1; j <= M0; j++) fprintf(TST, ", t = %g", out[NN+1][j]);
	fprintf(TST, "\n");

	for (k = 0; k <= NN; k++) {
		fprintf(TST, "%g", out[k][0]);
		for (j = 1; j <= M0; j++) fprintf(TST, ", %g", out[k][j]);
		fprintf(TST, "\n");
	}
	fclose(TST);

//////////////////////////////////////////////////////////
//...расчет функций быстрых переменных (для разных ячеек);
	int nn = 7, mm = 3, n, ii = (int)(t0/dt)/m+2-m_shift, nn_fast = 40;
	CDraft<double> ** dr = (CDraft<double> **)new_struct(nn*sizeof(CDraft<double> *)*nn_fast);
	double * K1 = (double *)new_struct(nn*sizeof(double)*nn_fast), 
			 * K2 = (double *)new_struct(nn*sizeof(double)*nn_fast), eps = 1.6e-3; 
	for (n = 0; n < nn*nn_fast; n++) {
		dr[n] = CreateDraftR(HEAT2D_DRAFT, 8);		
		dr[n]->set_mpls(PackInts(13, 13)); //...степень мультиполей;
		dr[n]->set_quad(PackInts(16, 8)); //...степень квадратуры;
		dr[n]->set_normaliz(0.92);			//...normalization coefficient;
		dr[n]->set_lagrange(1e-4);		  //...Lagrange coefficient for energy;
		dr[n]->solver.set_mode(/*PRINT_MODE | FULLY_MODE | MASKS_MODE | ACCUMULATION*/);
		dr[n]->solver.change_state(/*EXTERN_STATE*/);
		dr[n]->change_solv(SPECIAL_SOLVING);
///////////////////////////////////
//...характеристики кремния и меди;
		int n0 = 12, id_num; k = (int)((n+0.5)*eps/(h*nn_fast));
		double K_SC[] = {300.,2300.,5000.,3500.,1340.,410.,260.,150.,99.,62.,42.,31.},
				 K_CU[] = {16200.,24000.,10800.,2170.,560.,429.,413.,401.,393.,379.,366.,352.},
				 TH[] = {4.,10.,20.,30.,80.,150.,200.,300.,400.,600.,800.,1000.}, TT = out[k][ii];
		id_num  = 0;
		while (id_num < n0 && TT >= TH[id_num]) id_num++;
		if (id_num <= 0) K1[n] = K_SC[id_num];
		if (id_num > 0 && id_num  < n0) K1[n] = K_SC[id_num-1]+(K_SC[id_num]-K_SC[id_num-1])*(TT-TH[id_num-1])/(TH[id_num]-TH[id_num-1]);
		if (id_num == n0) K1[n] = K_SC[id_num-1];

		id_num  = 0;
		while (id_num < n0 && TT >= TH[id_num]) id_num++;
		if (id_num <= 0) K2[n] = K_CU[id_num];
		if (id_num > 0 && id_num  < n0) K2[n] = K_CU[id_num-1]+(K_CU[id_num]-K_CU[id_num-1])*(TT-TH[id_num-1])/(TH[id_num]-TH[id_num-1]);
		if (id_num == nn) K2[n] = K_CU[id_num-1];

///////////////////////////////////
//...чтение модели из файла данных;
		dr[n]->stru.nodes_in(name);
		dr[n]->bar_condit_in(name);
		dr[n]->LinkUniStruct();
		dr[n]->SetBUniStruct(CLAYER_BLOCK);

////////////////////////////
//...solving of the problem;
		dr[n]->set_fasa_hmg(0.3, 0.3125, 1., K2[n]/K1[n], K2[n]/K1[n]);
		if (dr[n]->computing_kernel(PERIOD_COMPUT) != OK_STATE) {
			Message("Error in sample computing...");
			if (dr[n]) delete dr[n];
			goto err;
		}
		int id_visual = 0;
		if (id_visual) {
			CGrid * nd = CreateNodes();
			double par[6];	dr[n]->SetGeomBounding(par);
			dr[n]->BlockActivate(NULL_STATE);

			int NX = 100, NY = 100;
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

			system("del *.grd");
			dr[n]->GetSurferFormat("rr", nd,        HEAT_VALUE, 0);
			dr[n]->GetSurferFormat("pp", nd, FLUX_COMPOS_VALUE, 0);

			delete nd;
		}
	}

////////////////////////////
//..первый член асимптотики;
	int id_visual = 1;
	if (id_visual) {
		CGrid * nd = CreateNodes();
		double par[6];	dr[0]->SetGeomBounding(par);
		for (n = 0; n < nn*nn_fast; n++) dr[n]->BlockActivate(NULL_STATE);

		int NX = 100, NY = 100;
		for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
		for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

		nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

		FILE * SURF = fopen("rr.grd", "w+b"), 
			  * SURF1 = fopen("pp.grd", "w+b"); 
		size_t res;

	  if (nd && nd->N > 0 && nd->N1 > 0 && SURF && SURF1) {
			short int i0 = (short int)nd->N*nn, 
						 j0 = (short int)nd->N1*mm;
			double * out_F = (double *)new_struct(surfer_dim(dr[0]->type())*sizeof(double)), 
					 * out_F1 = (double *)new_struct(surfer_dim(dr[0]->type())*sizeof(double)), X, Y, Z, d, dd, 
						min1F = 0., max1F = 1., 
						min2F = 0., max2F = 1.;
			int hit;
			if (SURF) {
				res = fwrite("DSBB", sizeof(char)*4,  1, SURF);
				res = fwrite(& i0,   sizeof(short int), 1, SURF); res = fwrite(& j0,         sizeof(short int), 1, SURF);
				res = fwrite(& (d = 0.),  sizeof(double),  1, SURF); res = fwrite(& (d = eps*nn),  sizeof(double),  1, SURF);
				res = fwrite(& (d = 0.),  sizeof(double),  1, SURF); res = fwrite(& (d = eps*mm), sizeof(double),  1, SURF);
				res = fwrite(& min1F, sizeof(double), 1, SURF); res = fwrite(& max1F,        sizeof(double),  1, SURF);
			}
			if (SURF1) {
				res = fwrite("DSBB", sizeof(char)*4,  1, SURF1);
				res = fwrite(& i0,   sizeof(short int), 1, SURF1); res = fwrite(& j0,         sizeof(short int), 1, SURF1);
				res = fwrite(& (d = 0.),  sizeof(double),  1, SURF1); res = fwrite(& (d = eps*nn),  sizeof(double),  1, SURF1);
				res = fwrite(& (d = 0.),  sizeof(double),  1, SURF1); res = fwrite(& (d = eps*mm), sizeof(double),  1, SURF1);
				res = fwrite(& min2F, sizeof(double), 1, SURF1); res = fwrite(& max2F,        sizeof(double),  1, SURF1);
			}
			min1F = min2F = MAX_HIT; 
			max1F = max2F = MIN_HIT;
			for (l = 0; l < mm;		l++)
			for (j = 0; j < nd->N1; j++)
			for (n = 0; n < nn;		n++)
			for (i = 0; i < nd->N;  i++) {
				X = nd->X[i];
				Y = nd->Y[j];
				Z = 0.;

				float ff = NOT_HIT; 
				if (nd->hit) hit = nd->hit[i+j*nd->N];
				if (hit != -1)  {
/////////////////////////////////////////////////////////
//..вычисляем истинные координаты, функцию и производную;
					k = (int)(x = (X+n)*eps/h);
					d = (x-k)*(out[k+1][ii]-out[k][ii])+out[k][ii];
					dd = (out[k+1][ii]-out[k][ii])/h;
					int n_fast = min(n*nn_fast+(int)(X*nn_fast), nn*nn_fast-1);

					if (SURF) {
						dr[n_fast]->GetFuncAllValues(X, Y, Z, out_F, hit, HEAT_VALUE);
						out_F[0] = d+out_F[0]*dd*eps;
						
						res = fwrite(& (ff = (float)out_F[0]), sizeof(float), 1, SURF);
						if (min1F > out_F[0]) min1F = out_F[0];
						if (max1F < out_F[0]) max1F = out_F[0];
					}
					if (SURF1) {
						dr[n_fast]->GetFuncAllValues(X, Y, Z, out_F1, hit, FLUX_COMPOS_VALUE);
						out_F1[0] = out_F1[0]*dd*K1[n_fast]*fnorm;

						res = fwrite(& (ff = (float)out_F1[0]), sizeof(float), 1, SURF1);
						if (min2F > out_F1[0]) min2F = out_F1[0];
						if (max2F < out_F1[0]) max2F = out_F1[0];
					}
				}
				else {
					if (SURF ) res = fwrite(& ff, sizeof(float), 1, SURF);
					if (SURF1) res = fwrite(& ff, sizeof(float), 1, SURF1);
				}
			}
			delete_struct(out_F);
			delete_struct(out_F1);

//////////////////////////////////////////////////////////////
//...перезапись максимального и минимального значения функции;
			if (SURF) {
				res = fseek(SURF, sizeof(char)*4+sizeof(short int)*2+sizeof(double)*4, SEEK_SET);
				res = fwrite(& min1F, sizeof(double), 1, SURF);
				res = fwrite(& max1F, sizeof(double), 1, SURF);
				res = fseek(SURF, 0L, SEEK_END);
			}
			if (SURF1) {
				res = fseek(SURF1, sizeof(char)*4+sizeof(short int)*2+sizeof(double)*4, SEEK_SET);
				res = fwrite(& min2F, sizeof(double), 1, SURF1);
				res = fwrite(& max2F, sizeof(double), 1, SURF1);
				res = fseek(SURF1, 0L, SEEK_END);
			}
		}
		if (SURF ) fclose(SURF);
		if (SURF1) fclose(SURF1);
		delete nd;
	}
	delete_struct(out);
	delete_struct(T);
	delete sm;
	for (n = 0; n < nn; n++) delete dr[n];
	delete_struct(dr);
	delete_struct(K1);
	delete_struct(K2);
}
#endif
#ifdef TEST_DRAFT_HEAT_FIRST_MEMBER_NONLINEAR_LAYER
{
	char * name = "./Parametric/Unit2d_1.nas";
	char * name_out = "heat1D_nonlinear_layer.dat";

//////////////////////
//...параметры задачи;
	double L = 0.5, eps_in = 1e-2;
	int i, k, j, l; 
	double KK1 = 1.,				  //...heat conduction (matrix);
			 KK2 = 413./150.,		 //...heat conduction (inclusion);
			 KK3 = KK2,			   //...heat conduction (intermediate);
			 R1 = 0.3,			  //...inclusion geometry;
			 R2 = 0.3125;		 //...intermediate geometry; 

//////////////////////////
//...инициализация модели;
	CDraft<double> * sm = CreateDraftR(HEAT2D_DRAFT, 8);		
	sm->set_fasa_hmg(R1, R2, KK1, KK2, KK3);
	sm->set_mpls(PackInts(1, 1)); //...степень мультиполей;
	sm->set_quad(PackInts(1, 1)); //...степень квадратуры;
	sm->set_normaliz(0.92);			//...normalization coefficient;
	sm->change_solv(SPECIAL_SOLVING);
	yes = 0;

///////////////////////////////////
//...чтение модели из файла данных;
	if (sm) {
      sprintf(buf, "Loading model from file '%s'", name);
      Message(" ");
      Message(buf);
      Message("Reading data file ...");

		sm->stru.nodes_in(name);
		sm->bar_condit_in(name);
		sm->LinkUniStruct();
		sm->SetBUniStruct(CLAYER_BLOCK);
		Message("Finish!");
	}

////////////////////////////
//...solving of the problem;
	if (sm->computing_kernel(PERIOD_COMPUT) != OK_STATE) {
		Message("Error in sample computing...");
		if (sm) delete sm;
		goto err;
	}

///////////////////
//..homogenization;
#ifdef ___MPI_INIT___
	if (comm_mpi.GetMyid() == 0) 
#endif
	{
//////////////////
//..visualization;
		int id_visual = 0;
		if (id_visual) {
			CGrid * nd = CreateNodes();
			double par[6];	sm->SetGeomBounding(par);
			sm->BlockActivate(NULL_STATE);

			int NX = 100, NY = 100;
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

			system("del *.grd");
			sm->GetSurferFormat("rr", nd, HEAT_ANALYT_VALUE, 0);
			sm->GetSurferFormat("pp", nd, FLUX_ANALYT_VALUE, 0);

			delete nd;
		}
	}
	int N1 = 30, N2 = 50, N_cells = 10, NN = (N1+N2)*(N_cells+1), m = 10000, MM = 3000000, M0 = MM/m, m_shift = 1;
	double x = 0., h = 0.00002, t = 0., dt = 0.0000002, alpha = dt/sqr(h), fnorm = 1e-3, t0 = 0.5,
			*T = (double *)new_struct((NN+1)*sizeof(double)), ** out = NULL, 
			T0 = 273, TS = 300;
	set_matrix(out, NN+2, M0+1);

////////////////////////////////////////////////////
//...начальные и граничные данные, распечатка сетки;
	for (T[0] = TS, k = 1; k <= NN; k++) T[k] = T0;

	for (l = 0, k = 0; k <= NN; k++, x += h) out[k][l] = x; 
	out[k][l] = h;

	for (l = 1, k = 0; k <= NN; k++) out[k][l] = T[k]; 
	out[k][l] = t;

///////////////////////////////
//...цикл по параметрам задачи;
	for (j = 1; j < MM; j++) {
		//sm->TakeStabStep(T, NN, alpha); t += dt;
		sm->TakeStabStep_layer(T, N1, N2, N_cells, alpha); t += dt;
		if (!(j%m) && (++l) <= M0) {
			for (k = 0; k <= NN; k++) out[k][l] = T[k]; 
			out[k][l] = t;
		}
	}

////////////////////////////
//...распечатка результатов;
	FILE *  TST = fopen(name_out, "w");
	fprintf(TST, "h = %g", out[NN+1][0]);
	for (j = 1; j <= M0; j++) fprintf(TST, ", t = %g", out[NN+1][j]);
	fprintf(TST, "\n");

	for (k = 0; k <= NN; k++) {
		fprintf(TST, "%g", out[k][0]);
		for (j = 1; j <= M0; j++) fprintf(TST, ", %g", out[k][j]);
		fprintf(TST, "\n");
	}
	fclose(TST);

//////////////////////////////////////////////////////////
//...расчет функций быстрых переменных (для разных ячеек);
	int nn = 7, mm = 3, n, ii = (int)(t0/dt)/m+2-m_shift, nn_fast = 40;
	CDraft<double> ** dr = (CDraft<double> **)new_struct(nn*sizeof(CDraft<double> *)*nn_fast);
	double * K1 = (double *)new_struct(nn*sizeof(double)*nn_fast), 
			 * K2 = (double *)new_struct(nn*sizeof(double)*nn_fast), eps = 1.6e-3; 
	for (n = 0; n < nn*nn_fast; n++) {
		dr[n] = CreateDraftR(HEAT2D_DRAFT, 8);		
		dr[n]->set_mpls(PackInts(13, 13)); //...степень мультиполей;
		dr[n]->set_quad(PackInts(16, 8)); //...степень квадратуры;
		dr[n]->set_normaliz(0.92);			//...normalization coefficient;
		dr[n]->set_lagrange(1e-4);		  //...Lagrange coefficient for energy;
		dr[n]->solver.set_mode(/*PRINT_MODE | FULLY_MODE | MASKS_MODE | ACCUMULATION*/);
		dr[n]->solver.change_state(/*EXTERN_STATE*/);
		dr[n]->change_solv(SPECIAL_SOLVING);
///////////////////////////////////
//...характеристики кремния и меди;
		int n0 = 12, id_num; k = (int)((n+0.5)*eps/(h*nn_fast));
		double K_SC[] = {300.,2300.,5000.,3500.,1340.,410.,260.,150.,99.,62.,42.,31.},
				 K_CU[] = {16200.,24000.,10800.,2170.,560.,429.,413.,401.,393.,379.,366.,352.},
				 TH[] = {4.,10.,20.,30.,80.,150.,200.,300.,400.,600.,800.,1000.}, TT = out[k][ii];
		id_num  = 0;
		while (id_num < n0 && TT >= TH[id_num]) id_num++;
		if (id_num <= 0) K1[n] = K_SC[id_num];
		if (id_num > 0 && id_num  < n0) K1[n] = K_SC[id_num-1]+(K_SC[id_num]-K_SC[id_num-1])*(TT-TH[id_num-1])/(TH[id_num]-TH[id_num-1]);
		if (id_num == n0) K1[n] = K_SC[id_num-1];

		id_num  = 0;
		while (id_num < n0 && TT >= TH[id_num]) id_num++;
		if (id_num <= 0) K2[n] = K_CU[id_num];
		if (id_num > 0 && id_num  < n0) K2[n] = K_CU[id_num-1]+(K_CU[id_num]-K_CU[id_num-1])*(TT-TH[id_num-1])/(TH[id_num]-TH[id_num-1]);
		if (id_num == nn) K2[n] = K_CU[id_num-1];

///////////////////////////////////
//...чтение модели из файла данных;
		dr[n]->stru.nodes_in(name);
		dr[n]->bar_condit_in(name);
		dr[n]->LinkUniStruct();
		dr[n]->SetBUniStruct(CLAYER_BLOCK);

////////////////////////////
//...solving of the problem;
		dr[n]->set_fasa_hmg(0.3, 0.3125, 1., K2[n]/K1[n], K2[n]/K1[n]);
		if (dr[n]->computing_kernel(PERIOD_COMPUT) != OK_STATE) {
			Message("Error in sample computing...");
			if (dr[n]) delete dr[n];
			goto err;
		}
		int id_visual = 0;
		if (id_visual) {
			CGrid * nd = CreateNodes();
			double par[6];	dr[n]->SetGeomBounding(par);
			dr[n]->BlockActivate(NULL_STATE);

			int NX = 100, NY = 100;
			for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
			for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

			nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

			system("del *.grd");
			dr[n]->GetSurferFormat("rr", nd,        HEAT_VALUE, 0);
			dr[n]->GetSurferFormat("pp", nd, FLUX_COMPOS_VALUE, 0);

			delete nd;
		}
	}

/////////////////////////////////////////////
//..первый член асимптотики в формате Surfer;
	int id_visual = 1;
	if (id_visual) {
		CGrid * nd = CreateNodes();
		double par[6];	dr[0]->SetGeomBounding(par);
		for (n = 0; n < nn*nn_fast; n++) dr[n]->BlockActivate(NULL_STATE);

		int NX = 100, NY = 100;
		for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
		for (j = 0; j <= 2*NY; j++) nd->add_new_point_Y(.5*j/NY*(par[3]-par[2])+par[2]);

		nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

		FILE * SURF = fopen("rr.grd", "w+b"), 
			  * SURF1 = fopen("pp.grd", "w+b"); 
		size_t res;

	  if (nd && nd->N > 0 && nd->N1 > 0 && SURF && SURF1) {
			short int i0 = (short int)nd->N*nn, 
						 j0 = (short int)nd->N1*mm;
			double * out_F = (double *)new_struct(surfer_dim(dr[0]->type())*sizeof(double)), 
					 * out_F1 = (double *)new_struct(surfer_dim(dr[0]->type())*sizeof(double)), X, Y, Z, d, dd, 
						min1F = 0., max1F = 1., 
						min2F = 0., max2F = 1.;
			int hit;
			if (SURF) {
				res = fwrite("DSBB", sizeof(char)*4,  1, SURF);
				res = fwrite(& i0,   sizeof(short int), 1, SURF); res = fwrite(& j0,         sizeof(short int), 1, SURF);
				res = fwrite(& (d = 0.),  sizeof(double),  1, SURF); res = fwrite(& (d = eps*nn),  sizeof(double),  1, SURF);
				res = fwrite(& (d = 0.),  sizeof(double),  1, SURF); res = fwrite(& (d = eps*mm), sizeof(double),  1, SURF);
				res = fwrite(& min1F, sizeof(double), 1, SURF); res = fwrite(& max1F,        sizeof(double),  1, SURF);
			}
			if (SURF1) {
				res = fwrite("DSBB", sizeof(char)*4,  1, SURF1);
				res = fwrite(& i0,   sizeof(short int), 1, SURF1); res = fwrite(& j0,         sizeof(short int), 1, SURF1);
				res = fwrite(& (d = 0.),  sizeof(double),  1, SURF1); res = fwrite(& (d = eps*nn),  sizeof(double),  1, SURF1);
				res = fwrite(& (d = 0.),  sizeof(double),  1, SURF1); res = fwrite(& (d = eps*mm), sizeof(double),  1, SURF1);
				res = fwrite(& min2F, sizeof(double), 1, SURF1); res = fwrite(& max2F,        sizeof(double),  1, SURF1);
			}
			min1F = min2F = MAX_HIT; 
			max1F = max2F = MIN_HIT;
			for (l = 0; l < mm;		l++)
			for (j = 0; j < nd->N1; j++)
			for (n = 0; n < nn;		n++)
			for (i = 0; i < nd->N;  i++) {
				X = nd->X[i];
				Y = nd->Y[j];
				Z = 0.;

				float ff = NOT_HIT; 
				if (nd->hit) hit = nd->hit[i+j*nd->N];
				if (hit != -1)  {
/////////////////////////////////////////////////////////
//..вычисляем истинные координаты, функцию и производную;
					k = (int)(x = (X+n)*eps/h);
					d = (x-k)*(out[k+1][ii]-out[k][ii])+out[k][ii];
					dd = (out[k+1][ii]-out[k][ii])/h;
					int n_fast = min(n*nn_fast+(int)(X*nn_fast), nn*nn_fast-1);

					if (SURF) {
						dr[n_fast]->GetFuncAllValues(X, Y, Z, out_F, hit, HEAT_ANALYT_VALUE);
						out_F[0] = d+out_F[0]*dd*eps;
						
						res = fwrite(& (ff = (float)out_F[0]), sizeof(float), 1, SURF);
						if (min1F > out_F[0]) min1F = out_F[0];
						if (max1F < out_F[0]) max1F = out_F[0];
					}
					if (SURF1) {
						dr[n_fast]->GetFuncAllValues(X, Y, Z, out_F1, hit, FLUX_ANALYT_VALUE);
						out_F1[0] = out_F1[0]*dd*K1[n_fast]*fnorm;

						res = fwrite(& (ff = (float)out_F1[0]), sizeof(float), 1, SURF1);
						if (min2F > out_F1[0]) min2F = out_F1[0];
						if (max2F < out_F1[0]) max2F = out_F1[0];
					}
				}
				else {
					if (SURF ) res = fwrite(& ff, sizeof(float), 1, SURF);
					if (SURF1) res = fwrite(& ff, sizeof(float), 1, SURF1);
				}
			}
			delete_struct(out_F);
			delete_struct(out_F1);

//////////////////////////////////////////////////////////////
//...перезапись максимального и минимального значения функции;
			if (SURF) {
				res = fseek(SURF, sizeof(char)*4+sizeof(short int)*2+sizeof(double)*4, SEEK_SET);
				res = fwrite(& min1F, sizeof(double), 1, SURF);
				res = fwrite(& max1F, sizeof(double), 1, SURF);
				res = fseek(SURF, 0L, SEEK_END);
			}
			if (SURF1) {
				res = fseek(SURF1, sizeof(char)*4+sizeof(short int)*2+sizeof(double)*4, SEEK_SET);
				res = fwrite(& min2F, sizeof(double), 1, SURF1);
				res = fwrite(& max2F, sizeof(double), 1, SURF1);
				res = fseek(SURF1, 0L, SEEK_END);
			}
		}
		if (SURF ) fclose(SURF);
		if (SURF1) fclose(SURF1);
		delete nd;
	}

///////////////////////////////////////////
//..первый член асимптотики в формате Exel;
	id_visual = 1;
	if (id_visual) {
		CGrid * nd = CreateNodes();
		double par[6];	dr[0]->SetGeomBounding(par);
		for (n = 0; n < nn*nn_fast; n++) dr[n]->BlockActivate(NULL_STATE);

		int NX = 40;
		for (i = 0; i <= 2*NX; i++) nd->add_new_point_X(.5*i/NX*(par[1]-par[0])+par[0]);
		nd->hit = (int *)new_struct(nd->N*nd->N1*sizeof(int));

		FILE * EXEL = fopen("rr.dat", "w"); 
		size_t res;

	  if (nd && nd->N > 0 && EXEL) {
			double * out_F = (double *)new_struct(surfer_dim(dr[0]->type())*sizeof(double)), X, Y = 0., Z = 0., d, dd;
			for (l = 0; l < mm;	  l++)
			for (n = 0; n < nn;	  n++)
			for (i = 0; i < nd->N; i++) {
				X = nd->X[i];

/////////////////////////////////////////////////////////
//..вычисляем истинные координаты, функцию и производную;
				k = (int)(x = (X+n)*eps/h);
				d = (x-k)*(out[k+1][ii]-out[k][ii])+out[k][ii];
				dd = (out[k+1][ii]-out[k][ii])/h;
				int n_fast = min(n*nn_fast+(int)(X*nn_fast), nn*nn_fast-1);

				if (EXEL) {
					dr[n_fast]->GetFuncAllValues(X, Y, Z, out_F, 0, HEAT_ANALYT_VALUE);
					out_F[0] = d+out_F[0]*dd*eps;

					fprintf(EXEL, "%g,   %g\n", x*h, out_F[0]);
				}
			}
			delete_struct(out_F);
		}
		if (EXEL) fclose(EXEL);
		delete nd;
	}
	delete_struct(out);
	delete_struct(T);
	delete sm;
	for (n = 0; n < nn; n++) delete dr[n];
	delete_struct(dr);
	delete_struct(K1);
	delete_struct(K2);
}
#endif
err:
	printf("\nFull time: %ld sec\n", sec = time(NULL)-start);
	if (yes) {
		printf("\nTEST >> Is the work finished? (Y/N) : "); if (yes) res = scanf("%s", buf);
	}
	printf("\n");

#ifdef ___IGROUPS_NGROUPS___
	};
#endif
#ifdef ___MPI_INIT___
	MPI_Barrier (MPI_COMM_WORLD);
	MPI_Finalize();
#endif
  } 
  catch (const char *m) {
      std::cerr << "error: " << m << std::endl;
  }
	return 0;
}

